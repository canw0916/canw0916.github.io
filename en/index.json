[{"content":"简介 什么是框架？\n所谓的框，其实说白了就是一个【项目的半成品】，该项目的半成品需要被集成了各种功能且具有较强的通用性。\nScrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架，非常出名，非常强悍。所谓的框架就是一个已经被集成了各种功能（高性能异步下载，队列，分布式，解析，持久化等）的具有很强通用性的项目模板。对于框架的学习，重点是要学习其框架的特性、各个功能的用法即可。\n初期如何学习框架？\n只需要学习框架集成好的各种功能的用法即可！前期切勿钻研框架的源码！\n安装 Linux/mac系统： pip install scrapy（任意目录下） Windows系统： a. pip install wheel（任意目录下） b. 下载twisted文件，下载网址如下： http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted c. 终端进入下载目录，执行 pip install Twisted‑17.1.0‑cp35‑cp35m‑win_amd64.whl 注意：如果该步骤安装出错，则换一个版本的whl文件即可 d. pip install pywin32（任意目录下） e. pip install scrapy（任意目录下） 如果安装好后，在终端中录入scrapy指令按下回车，如果没有提示找不到该指令，则表示安装成功 基本使用 创建项目\nscrapy startproject 项目名称\n项目的目录结构：\nfirstBlood # 项目所在文件夹, 建议用pycharm打开该文件夹 ├── firstBlood # 项目跟目录 │ ├── __init__.py │ ├── items.py # 封装数据的格式 │ ├── middlewares.py # 所有中间件 │ ├── pipelines.py\t# 所有的管道 │ ├── settings.py\t# 爬虫配置信息 │ └── spiders\t# 爬虫文件夹, 稍后里面会写入爬虫代码 │ └── __init__.py └── scrapy.cfg\t# scrapy项目配置信息,不要删它,别动它,善待它. 创建爬虫爬虫文件：\ncd project_name（进入项目目录） scrapy genspider 爬虫文件的名称（自定义一个名字即可） 起始url （例如：scrapy genspider first www.xxx.com） 创建成功后，会在爬虫文件夹下生成一个py的爬虫文件 编写爬虫文件\n理解爬虫文件的不同组成部分\nimport scrapy class FirstSpider(scrapy.Spider): #爬虫名称：爬虫文件唯一标识：可以使用该变量的值来定位到唯一的一个爬虫文件 name = \u0026#39;first\u0026#39; #无需改动 #允许的域名：scrapy只可以发起百度域名下的网络请求 # allowed_domains = [\u0026#39;www.baidu.com\u0026#39;] #起始的url列表：列表中存放的url可以被scrapy发起get请求 start_urls = [\u0026#39;https://www.baidu.com/\u0026#39;,\u0026#39;https://www.sogou.com\u0026#39;] #专门用作于数据解析 #参数response：就是请求之后对应的响应对象 #parse的调用次数，取决于start_urls列表元素的个数 def parse(self, response): print(\u0026#39;响应对象为：\u0026#39;,response) 配置文件修改:settings.py\n不遵从robots协议：ROBOTSTXT_OBEY = False 指定输出日志的类型：LOG_LEVEL = \u0026lsquo;ERROR\u0026rsquo; 指定UA：USER_AGENT = \u0026lsquo;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.109 Safari/537.36\u0026rsquo; 运行项目\nscrapy crawl 爬虫名称 ：该种执行形式会显示执行的日志信息（推荐） scrapy crawl 爬虫名称 --nolog：该种执行形式不会显示执行的日志信息（一般不用） 数据解析 注意，如果终端还在第一个项目的文件夹中，则需要在终端中执行cd ../返回到上级目录，在去新建另一个项目。\n新建数据解析项目：\n创建工程：scrapy startproject 项目名称 cd 项目名称 创建爬虫文件：scrapy genspider 爬虫文件名 www.xxx.com 配置文件的修改：settings.py\n不遵从robots协议：ROBOTSTXT_OBEY = False 指定输出日志的类型：LOG_LEVEL = \u0026lsquo;ERROR\u0026rsquo; 指定UA：USER_AGENT = \u0026lsquo;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.109 Safari/537.36\u0026rsquo; 编写爬虫文件：spiders/duanzi.py\nimport scrapy class DuanziSpider(scrapy.Spider): name = \u0026#39;duanzi\u0026#39; # allowed_domains = [\u0026#39;www.xxx.com\u0026#39;] #对首页进行网络请求 #scrapy会对列表中的url发起get请求 start_urls = [\u0026#39;https://ishuo.cn/duanzi\u0026#39;] def parse(self, response): #如何获取响应数据 #调用xpath方法对响应数据进行xpath形式的数据解析 li_list = response.xpath(\u0026#39;//*[@id=\u0026#34;list\u0026#34;]/ul/li\u0026#39;) for li in li_list: # content = li.xpath(\u0026#39;./div[1]/text()\u0026#39;)[0] # title = li.xpath(\u0026#39;./div[2]/a/text()\u0026#39;)[0] # #\u0026lt;Selector xpath=\u0026#39;./div[2]/a/text()\u0026#39; data=\u0026#39;一年奔波，尘缘遇了谁\u0026#39;\u0026gt; # print(title)#selector的对象，且我们想要的字符串内容存在于该对象的data参数里 #解析方案1： # title = li.xpath(\u0026#39;./div[2]/a/text()\u0026#39;)[0] # content = li.xpath(\u0026#39;./div[1]/text()\u0026#39;)[0] # #extract()可以将selector对象中data参数的值取出 # print(title.extract()) # print(content.extract()) #解析方案2： #title和content为列表，列表只要一个列表元素 title = li.xpath(\u0026#39;./div[2]/a/text()\u0026#39;) content = li.xpath(\u0026#39;./div[1]/text()\u0026#39;) #extract_first()可以将列表中第0个列表元素表示的selector对象中data的参数值取出 print(title.extract_first()) print(content.extract_first()) 持久化存储 两种方案：\n基于终端指令的持久化存储 基于管道的持久化存储（推荐） 基于终端指令的持久化存储 只可以将parse方法的返回值存储到指定后缀的文本文件中。\n编码流程：\n在爬虫文件中，将爬取到的数据全部封装到parse方法的返回值中\nimport scrapy class DemoSpider(scrapy.Spider): name = \u0026#39;demo\u0026#39; # allowed_domains = [\u0026#39;www.xxx.com\u0026#39;] start_urls = [\u0026#39;https://ishuo.cn/duanzi\u0026#39;] def parse(self, response): # 如何获取响应数据 # 调用xpath方法对响应数据进行xpath形式的数据解析 li_list = response.xpath(\u0026#39;//*[@id=\u0026#34;list\u0026#34;]/ul/li\u0026#39;) all_data = []#爬取到的数据全部都存储到了该列表中 for li in li_list: title = li.xpath(\u0026#39;./div[2]/a/text()\u0026#39;).extract_first() content = li.xpath(\u0026#39;./div[1]/text()\u0026#39;).extract_first() #将段子标题和内容封装成parse方法的返回 dic = { \u0026#39;title\u0026#39;:title, \u0026#39;content\u0026#39;:content } all_data.append(dic) return all_data 将parse方法的返回值存储到指定后缀的文本文件中:\nscrapy crawl 爬虫文件名称 -o duanzi.csv 总结：\n优点：简单，便捷 缺点：局限性强 只可以将数据存储到文本文件无法写入数据库 存储数据文件后缀是指定好的，通常使用.csv 需要将存储的数据封装到parse方法的返回值中 基于管道实现持久化存储 优点：极大程度的提升数据存储的效率\n缺点：编码流程较多\n编码流程 1.在爬虫文件中进行数据解析\ndef parse(self, response): # 如何获取响应数据 # 调用xpath方法对响应数据进行xpath形式的数据解析 li_list = response.xpath(\u0026#39;//*[@id=\u0026#34;list\u0026#34;]/ul/li\u0026#39;) all_data = [] # 爬取到的数据全部都存储到了该列表中 for li in li_list: title = li.xpath(\u0026#39;./div[2]/a/text()\u0026#39;).extract_first() content = li.xpath(\u0026#39;./div[1]/text()\u0026#39;).extract_first() 2.将解析到的数据封装到Item类型的对象中\n2.1 在items.py文件中定义相关的字段\nclass SavedataproItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() #爬取的字段有哪些，这里就需要定义哪些变量存储爬取到的字段 title = scrapy.Field() content = scrapy.Field() 2.2 在爬虫文件中引入Item类，实例化item对象，将解析到的数据存储到item对象中\ndef parse(self, response): from items import SavedataproItem #导入item类 # 如何获取响应数据 # 调用xpath方法对响应数据进行xpath形式的数据解析 li_list = response.xpath(\u0026#39;//*[@id=\u0026#34;list\u0026#34;]/ul/li\u0026#39;) all_data = [] # 爬取到的数据全部都存储到了该列表中 for li in li_list: title = li.xpath(\u0026#39;./div[2]/a/text()\u0026#39;).extract_first() content = li.xpath(\u0026#39;./div[1]/text()\u0026#39;).extract_first() #实例化一个item类型的对象 item = SavedataproItem() #通过中括号的方式访问item对象中的两个成员，且将解析到的两个字段赋值给item对象的两个成员即可 item[\u0026#39;title\u0026#39;] = title item[\u0026#39;content\u0026#39;] = content 3.将item对象提交给管道\n#将存储好数据的item对象提交给管道 yield item 4.在管道中接收item类型对象(pipelines.py就是管道文件)\n管道只可以接收item类型的对象，不可以接收其他类型对象\nclass SavedataproPipeline: #process_item用来接收爬虫文件传递过来的item对象 #item参数，就是管道接收到的item类型对象 def process_item(self, item, spider): print(item) return item 5.在管道中对接收到的数据进行任意形式的持久化存储操作\n可以存储到文件中也可以存储到数据库中\n# Define your item pipelines here # # Don\u0026#39;t forget to add your pipeline to the ITEM_PIPELINES setting # See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html # useful for handling different item types with a single interface from itemadapter import ItemAdapter class SavedataproPipeline: #重写父类的方法 fp = None def open_spider(self,spider): print(\u0026#39;我是open_spider方法，我在项目开始运行环节，只会被执行一次！\u0026#39;) self.fp = open(\u0026#39;duanzi.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) #process_item用来接收爬虫文件传递过来的item对象 #item参数，就是管道接收到的item类型对象 #process_item方法调用的次数取决于爬虫文件给其提交item的次数 def process_item(self, item, spider): #item类型的对象其实就是一个字典 # print(item) #将item字典中的标题和内容获取 title = item[\u0026#39;title\u0026#39;] content = item[\u0026#39;content\u0026#39;] self.fp.write(title+\u0026#39;:\u0026#39;+content+\u0026#39;\\n\u0026#39;) print(title,\u0026#39;:爬取保存成功！\u0026#39;) return item def close_spider(self,spider): print(\u0026#39;在爬虫结束的时候会被执行一次！\u0026#39;) self.fp.close() 6.在配置文件中开启管道机制\n注意：默认情况下，管道机制是没有被开启的，需要在配置文件中手动开启 在setting.py中把ITEM_PIPELINES解除注释就表示开启了管道机制 管道深入操作 如何将数据存储到数据库\n注意：一个管道类负责将数据存储到一个具体的载体中。如果想要将爬取到的数据存储到多个不同的载体/数据库中，则需要定义多个管道类。 思考：\n在有多个管道类的前提下，爬虫文件提交的item会同时给没一个管道类还是单独的管道类？ 爬虫文件只会将item提交给优先级最高的那一个管道类。优先级最高的管道类的process_item中需要写return item操作，该操作就是表示将item对象传递给下一个管道类，下一个管道类获取了item对象，才可以将数据存储成功！ 管道类：\n# Define your item pipelines here # # Don\u0026#39;t forget to add your pipeline to the ITEM_PIPELINES setting # See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html # useful for handling different item types with a single interface from itemadapter import ItemAdapter import pymysql import redis import pymongo #负责将数据存储到mysql中 class MysqlPipeline: conn = None #mysql的链接对象 cursor = None def open_spider(self,spider): self.conn = pymysql.Connect( host = \u0026#39;127.0.0.1\u0026#39;, port = 3306, user = \u0026#39;root\u0026#39;, password = \u0026#39;boboadmin\u0026#39;, db = \u0026#39;spider3qi\u0026#39;, charset = \u0026#39;utf8\u0026#39; ) self.cursor = self.conn.cursor() #爬虫文件每向管道提交一个item，则process_item方法就会被调用一次 def process_item(self, item, spider): title = item[\u0026#39;title\u0026#39;] sql = \u0026#39;insert into xiaoshuo (title) values (\u0026#34;%s\u0026#34;)\u0026#39;%title self.cursor.execute(sql) self.conn.commit() print(\u0026#39;成功写入一条数据！\u0026#39;) return item def close_spider(self,spider): self.cursor.close() self.conn.close() #将数据持久化存储到redis中 class RedisPipeLine: conn = None def open_spider(self,spider): #在链接前务必手动启动redis的服务 self.conn = redis.Redis( host=\u0026#39;127.0.0.1\u0026#39;, port=6379 ) def process_item(self,item,spider): #注意：如果想要将一个python字典直接写入到redis中，则redis模块的版本务必是2.10.6 #如果redis模块的版本不是2.10.6则重新安装：pip install redis==2.10.6 self.conn.lpush(\u0026#39;xiaoshuo\u0026#39;,item) print(\u0026#39;数据存储redis成功！\u0026#39;) return item class MongoPipeline: conn = None #链接对象 db_sanqi = None #数据仓库 def open_spider(self,spider): self.conn = pymongo.MongoClient( host=\u0026#39;127.0.0.1\u0026#39;, port=27017 ) self.db_sanqi = self.conn[\u0026#39;sanqi\u0026#39;] def process_item(self,item,spider): self.db_sanqi[\u0026#39;xiaoshuo\u0026#39;].insert_one({\u0026#39;title\u0026#39;:item[\u0026#39;title\u0026#39;]}) print(\u0026#39;插入成功！\u0026#39;) return item 配置文件：\nITEM_PIPELINES = { #数字表示管道类被执行的优先级，数字越小表示优先级越高 \u0026#39;xiaoshuoPro.pipelines.MysqlPipeline\u0026#39;: 300, \u0026#39;xiaoshuoPro.pipelines.RedisPipeLine\u0026#39;: 301, \u0026#39;xiaoshuoPro.pipelines.MongoPipeline\u0026#39;: 302, } scrapy爬取多媒体资源数据 使用一个专有的管道类ImagesPipeline\n具体的编码流程：\n1.在爬虫文件中进行图片/视频的链接提取\n2.将提取到的链接封装到items对象中，提交给管道\n3.在管道文件中自定义一个父类为ImagesPipeline的管道类，且重写三个方法即可：\ndef get_media_requests(self, item, info):接收爬虫文件提交过来的item对象，然后对图片地址发起网路请求，返回图片的二进制数据 def file_path(self, request, response=None, info=None, *, item=None)：指定保存图片的名称 def item_completed(self, results, item, info)：返回item对象给下一个管道类 4.在配置文件中开启指定的管道，且通过IMAGES_STORE = \u0026lsquo;girlsLib\u0026rsquo;操作指定图片存储的文件夹。\n# Define your item pipelines here # # Don\u0026#39;t forget to add your pipeline to the ITEM_PIPELINES setting # See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html # useful for handling different item types with a single interface import scrapy from itemadapter import ItemAdapter from scrapy.pipelines.images import ImagesPipeline #自定义的管道类一定要继承与ImagesPipeline class mediaPileline(ImagesPipeline): #重写三个父类的方法来完成图片二进制数据的请求和持久化存储 #可以根据图片地址，对其进行请求，获取图片数据 #参数item：就是接收到的item对象 def get_media_requests(self, item, info): img_src = item[\u0026#39;src\u0026#39;] yield scrapy.Request(img_src) #指定图片的名称（只需要返回图片存储的名称即可） def file_path(self, request, response=None, info=None, *, item=None): imgName = request.url.split(\u0026#39;/\u0026#39;)[-1] print(imgName,\u0026#39;下载保存成功！\u0026#39;) return imgName #如果没有下一个管道类，该方法可以不写 def item_completed(self, results, item, info): return item #可以将当前的管道类接收到item对象传递给下一个管道类2. scrapy深度爬取 如何爬取多页的数据（全站数据爬取）\n手动请求发送：\n#callback用来指定解析方法 yield scrapy.Request(url=new_url,callback=self.parse) 如何爬取深度存储的数据\n什么是深度，说白了就是爬取的数据没有存在于同一张页面中。\n必须使用请求传参的机制才可以完整的实现。\n请求传参：\nyield scrapy.Request(meta={},url=detail_url,callback=self.parse_detail) 可以将meta字典传递给callback这个回调函数 import scrapy from ..items import DeepproItem class DeepSpider(scrapy.Spider): name = \u0026#39;deep\u0026#39; # allowed_domains = [\u0026#39;www.xxx.com\u0026#39;] start_urls = [\u0026#39;https://wz.sun0769.com/political/index/politicsNewest\u0026#39;] #解析首页数据 def parse(self, response): li_list = response.xpath(\u0026#39;/html/body/div[2]/div[3]/ul[2]/li\u0026#39;) for li in li_list: title = li.xpath(\u0026#39;./span[3]/a/text()\u0026#39;).extract_first() detail_url = \u0026#39;https://wz.sun0769.com\u0026#39;+li.xpath(\u0026#39;./span[3]/a/@href\u0026#39;).extract_first() # print(title) item = DeepproItem() item[\u0026#39;title\u0026#39;] = title #对详情页的url发起请求 #参数meta可以将自身这个字典传递给callback指定的回调函数 yield scrapy.Request(meta={\u0026#39;item\u0026#39;:item},url=detail_url,callback=self.parse_detail) #解析详情页数据 def parse_detail(self,response): meta = response.meta #接收请求传参过来的meta字典 item = meta[\u0026#39;item\u0026#39;] content = response.xpath(\u0026#39;/html/body/div[3]/div[2]/div[2]/div[2]//text()\u0026#39;).extract() content = \u0026#39;\u0026#39;.join(content) # print(content) item[\u0026#39;content\u0026#39;] = content yield item ImagePipeLines的请求传参 环境安装：pip install Pillow\nUSER_AGENT = \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.109 Safari/537.36\u0026#39; 需求：将图片的名称和详情页中图片的数据进行爬取，持久化存储。\n分析：\n深度爬取：请求传参 多页的数据爬取：手动请求的发送 爬虫文件：\nimport scrapy from ..items import DeepimgproItem class ImgSpider(scrapy.Spider): name = \u0026#39;img\u0026#39; # allowed_domains = [\u0026#39;www.xxx.com\u0026#39;] start_urls = [\u0026#39;https://pic.netbian.com/4kmeinv/\u0026#39;] #通用的url模板 url_model = \u0026#39;https://pic.netbian.com/4kmeinv/index_%d.html\u0026#39; page_num = 2 def parse(self, response): #解析出了图片的名称和详情页的url li_list = response.xpath(\u0026#39;//*[@id=\u0026#34;main\u0026#34;]/div[3]/ul/li\u0026#39;) for li in li_list: title = li.xpath(\u0026#39;./a/b/text()\u0026#39;).extract_first() + \u0026#39;.jpg\u0026#39; detail_url = \u0026#39;https://pic.netbian.com\u0026#39;+li.xpath(\u0026#39;./a/@href\u0026#39;).extract_first() item = DeepimgproItem() item[\u0026#39;title\u0026#39;] = title #需要对详情页的url发起请求，在详情页中获取图片的下载链接 yield scrapy.Request(url=detail_url,callback=self.detail_parse,meta={\u0026#39;item\u0026#39;:item}) if self.page_num \u0026lt;= 2: new_url = format(self.url_model%self.page_num) self.page_num += 1 yield scrapy.Request(url=new_url,callback=self.parse) #解析详情页的数据 def detail_parse(self,response): meta = response.meta item = meta[\u0026#39;item\u0026#39;] img_src = \u0026#39;https://pic.netbian.com\u0026#39;+response.xpath(\u0026#39;//*[@id=\u0026#34;img\u0026#34;]/img/@src\u0026#39;).extract_first() item[\u0026#39;img_src\u0026#39;] = img_src yield item 管道：\n# Define your item pipelines here # # Don\u0026#39;t forget to add your pipeline to the ITEM_PIPELINES setting # See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html # useful for handling different item types with a single interface import scrapy from itemadapter import ItemAdapter from scrapy.pipelines.images import ImagesPipeline class DeepimgproPipeline(ImagesPipeline): # def process_item(self, item, spider): # return item def get_media_requests(self, item, info): img_src = item[\u0026#39;img_src\u0026#39;] #请求传参，将item中的图片名称传递给file_path方法 #meta会将自身传递给file_path print(item[\u0026#39;title\u0026#39;],\u0026#39;保存下载成功！\u0026#39;) yield scrapy.Request(url=img_src,meta={\u0026#39;title\u0026#39;:item[\u0026#39;title\u0026#39;]}) def file_path(self, request, response=None, info=None, *, item=None): #返回图片的名称 #接收请求传参过来的数据 title = request.meta[\u0026#39;title\u0026#39;] return title def item_completed(self, results, item, info): return item 如何提高scrapy的爬取效率 增加并发： 默认scrapy开启的并发线程为32个，可以适当进行增加。在settings配置文件中修改CONCURRENT_REQUESTS = 100值为100,并发设置成了为100。 降低日志级别： 在运行scrapy时，会有大量日志信息的输出，为了减少CPU的使用率。可以设置log输出信息为WORNING或者ERROR即可。在配置文件中编写：LOG_LEVEL = ‘ERROR’ 禁止cookie： 如果不是真的需要cookie，则在scrapy爬取数据时可以禁止cookie从而减少CPU的使用率，提升爬取效率。在配置文件中编写：COOKIES_ENABLED = False 禁止重试： 对失败的HTTP进行重新请求（重试）会减慢爬取速度，因此可以禁止重试。在配置文件中编写：RETRY_ENABLED = False 减少下载超时： 如果对一个非常慢的链接进行爬取，减少下载超时可以能让卡住的链接快速被放弃，从而提升效率。在配置文件中进行编写：DOWNLOAD_TIMEOUT = 10 超时时间为10s post请求发送 问题：在之前代码中，我们从来没有手动的对start_urls列表中存储的起始url进行过请求的发送，但是起始url的确是进行了请求的发送，那这是如何实现的呢？\n解答：其实是因为爬虫文件中的爬虫类继承到了Spider父类中的start_requests（self）这个方法，该方法就可以对start_urls列表中的url发起请求：\ndef start_requests(self): for u in self.start_urls: yield scrapy.Request(url=u,callback=self.parse) 【注意】该方法默认的实现，是对起始的url发起get请求，如果想发起post请求，则需要子类重写该方法。\nyield scrapy.Request():发起get请求 yield scrapy.FormRequest():发起post请求 import scrapy class FanyiSpider(scrapy.Spider): name = \u0026#39;fanyi\u0026#39; # allowed_domains = [\u0026#39;www.xxx.com\u0026#39;] start_urls = [\u0026#39;https://fanyi.baidu.com/sug\u0026#39;] #父类中的方法：该方法是用来给起始的url列表中的每一个url发请求 def start_requests(self): data = { \u0026#39;kw\u0026#39;:\u0026#39;dog\u0026#39; } for url in self.start_urls: #formdata是用来指定请求参数 yield scrapy.FormRequest(url=url,callback=self.parse,formdata=data) def parse(self, response): result = response.json() print(result) scrapy的核心组件 从中可以大致了解scrapy框架的一个运行机制 - 引擎(Scrapy) 用来处理整个系统的数据流处理, 触发事务(框架核心) - 调度器(Scheduler) 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 - 下载器(Downloader) 用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的) - 爬虫(Spiders) 爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面 - 项目管道(Pipeline) 负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。 中间件 scrapy的中间件有两个：\n爬虫中间件 下载中间件 中间件的作用是什么？ 观测中间件在五大核心组件的什么位置，根据位置了解中间件的作用 下载中间件位于引擎和下载器之间 引擎会给下载器传递请求对象，下载器会给引擎返回响应对象。 作用：可以拦截到scrapy框架中所有的请求和响应。 拦截请求干什么？ 修改请求的ip，修改请求的头信息，设置请求的cookie 拦截响应干什么？ 可以修改响应数据 中间件重要方法：\n# Define here the models for your spider middleware # # See documentation in: # https://docs.scrapy.org/en/latest/topics/spider-middleware.html from scrapy import signals # useful for handling different item types with a single interface from itemadapter import is_item, ItemAdapter class MiddleproDownloaderMiddleware: #类方法：作用是返回一个下载器对象（忽略） @classmethod def from_crawler(cls, crawler): # This method is used by Scrapy to create your spiders. s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s #拦截处理所有的请求对象 #参数：request就是拦截到的请求对象，spider爬虫文件中爬虫类实例化的对象 #spider参数的作用可以实现爬虫类和中间类的数据交互 def process_request(self, request, spider): return None #拦截处理所有的响应对象 #参数：response就是拦截到的响应对象，request就是被拦截到响应对象对应的唯一的一个请求对象 def process_response(self, request, response, spider): return response #拦截和处理发生异常的请求对象 #参数：reqeust就是拦截到的发生异常的请求对象 def process_exception(self, request, exception, spider): pass #控制日志数据的（忽略） def spider_opened(self, spider): spider.logger.info(\u0026#39;Spider opened: %s\u0026#39; % spider.name) 开发代理中间件 request.meta[\u0026lsquo;proxy\u0026rsquo;] = proxy\n# Define here the models for your spider middleware # # See documentation in: # https://docs.scrapy.org/en/latest/topics/spider-middleware.html from scrapy import signals # useful for handling different item types with a single interface from itemadapter import is_item, ItemAdapter from scrapy import Request class MiddleproDownloaderMiddleware: #类方法：作用是返回一个下载器对象（忽略） @classmethod def from_crawler(cls, crawler): # This method is used by Scrapy to create your spiders. s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s #拦截处理所有的请求对象 #参数：request就是拦截到的请求对象，spider爬虫文件中爬虫类实例化的对象 #spider参数的作用可以实现爬虫类和中间类的数据交互 def process_request(self, request, spider): #是的所有的请求都是用代理，则代理操作可以写在该方法中 request.meta[\u0026#39;proxy\u0026#39;] = \u0026#39;http://ip:port\u0026#39; #弊端：会使得整体的请求效率变低 print(request.url+\u0026#39;:请求对象拦截成功！\u0026#39;) return None #拦截处理所有的响应对象 #参数：response就是拦截到的响应对象，request就是被拦截到响应对象对应的唯一的一个请求对象 def process_response(self, request, response, spider): print(request.url+\u0026#39;:响应对象拦截成功！\u0026#39;) return response #拦截和处理发生异常的请求对象 #参数：reqeust就是拦截到的发生异常的请求对象 #方法存在的意义：将发生异常的请求拦截到，然后对其进行修正 def process_exception(self, request, exception, spider): print(request.url+\u0026#39;:发生异常的请求对象被拦截到！\u0026#39;) #修正操作 #只有发生了异常的请求才使用代理机制，则可以写在该方法中 request.meta[\u0026#39;proxy\u0026#39;] = \u0026#39;https://ip:port\u0026#39; return request #对请求对象进行重新发送 #控制日志数据的（忽略） def spider_opened(self, spider): spider.logger.info(\u0026#39;Spider opened: %s\u0026#39; % spider.name) 开发UA中间件 request.headers[\u0026lsquo;User-Agent\u0026rsquo;] = ua\ndef process_request(self, request, spider): request.headers[\u0026#39;User-Agent\u0026#39;] = \u0026#39;从列表中随机选择的一个UA值\u0026#39; print(request.url+\u0026#39;:请求对象拦截成功！\u0026#39;) return None 开发Cookie中间件 request.cookies = cookies\ndef process_request(self, request, spider): request.headers[\u0026#39;cookie\u0026#39;] = \u0026#39;xxx\u0026#39; #request.cookies = \u0026#39;xxx\u0026#39; print(request.url+\u0026#39;:请求对象拦截成功！\u0026#39;) return None selenium+scrapy 需求：将网易新闻中的国内，国际，军事，航空四个板块下的新闻标题和内容进行数据爬取\n注意：哪些数据是动态加载的！ 技术：selenium，scrapy，中间件 分析：\n抓取首页中四个板块下所有的新闻标题和新闻内容 获取首页中四个板块对应的详情页链接 首页是没有动态加载数据，可以直接爬取+解析 对每一个板块的url发起请求，获取详情页中的新闻标题等内容 通过分析发现每一个板块中的新闻数据全部是动态加载的数据，如何解决呢？ 通过selenium解决 scrapy+selenium的编码流程\n1.在爬虫文件中定义浏览器对象，将浏览器对象作为爬虫类的一个成员变量 2.在中间件中通过spider获取爬虫文件中定义的浏览器对象，进行请求发送和获取响应数据 3.在爬虫文件中重写一个closed方法，来关闭浏览器对象 爬虫文件\nimport scrapy from ..items import WangyiproItem from selenium import webdriver class WangyiSpider(scrapy.Spider): name = \u0026#39;wangyi\u0026#39; # allowed_domains = [\u0026#39;www.xxx.com\u0026#39;] start_urls = [\u0026#39;https://news.163.com/\u0026#39;] #创建浏览器对象，把浏览器对象作为爬虫类的一个成员 bro = webdriver.Chrome(executable_path=\u0026#39;/Users/zhangxiaobo/Desktop/三期/chromedriver1\u0026#39;) model_urls = [] #存储4个板块对应的url def parse(self, response): #从首页解析每一个板块对应详情页的url，将其存储到model_urls列表中 model_index = [2,3,5,6] li_list = response.xpath(\u0026#39;//*[@id=\u0026#34;index2016_wrap\u0026#34;]/div[3]/div[2]/div[2]/div[2]/div/ul/li\u0026#39;) for index in model_index: model_url = li_list[index].xpath(\u0026#39;./a/@href\u0026#39;).extract_first() self.model_urls.append(model_url) #应该对每一个板块的详情页发起请求（动态加载） for model_url in self.model_urls: yield scrapy.Request(url=model_url,callback=self.parse_detail) #目的是为了解析出每一个板块中的新闻标题和新闻详情页的url def parse_detail(self,response): #response就是一个不符合需求要求的响应对象 #该response中没有存储动态加载的新闻数据，因此该响应对象被视为不符合要求的响应对象 #需要将不符合要求的响应对象变为符合要求的响应对象即可，如何做呢？ #方法：篡改不符合要求的响应对象的响应数据，将该响应对象的响应数据修改为包含了动态加载的新闻数据即可。 div_list = response.xpath(\u0026#39;/html/body/div/div[3]/div[4]/div[1]/div[1]/div/ul/li/div/div\u0026#39;) for div in div_list: try: #解析新闻标题+新闻详情页的url title = div.xpath(\u0026#39;./div/div[1]/h3/a/text()\u0026#39;).extract_first() new_detail_url = div.xpath(\u0026#39;./div/div[1]/h3/a/@href\u0026#39;).extract_first() item = WangyiproItem() item[\u0026#39;title\u0026#39;] = title except Exception as e: print(\u0026#39;遇到了广告，忽略此次行为即可！\u0026#39;) #对新闻的详情页发起请求 if new_detail_url != None: yield scrapy.Request(url=new_detail_url,callback=self.new_content_parse,meta={\u0026#39;item\u0026#39;:item}) def new_content_parse(self,response): item = response.meta[\u0026#39;item\u0026#39;] #解析新闻的详情内容 content = response.xpath(\u0026#39;//*[@id=\u0026#34;content\u0026#34;]/div[2]//text()\u0026#39;).extract() content = \u0026#39;\u0026#39;.join(content).strip() item[\u0026#39;content\u0026#39;] = content yield item #重写一个父类方法，close_spider，该方法只会在爬虫最后执行一次 def closed(self,spider): #关闭浏览器 print(\u0026#39;关闭浏览器成功！\u0026#39;) self.bro.quit() 中间件文件：\n# Define here the models for your spider middleware # # See documentation in: # https://docs.scrapy.org/en/latest/topics/spider-middleware.html import requests from scrapy import signals # useful for handling different item types with a single interface from itemadapter import is_item, ItemAdapter from time import sleep from scrapy.http import HtmlResponse#scrapy封装的响应对象对应的类 class WangyiproDownloaderMiddleware: def process_request(self, request, spider): return None def process_response(self, request, response, spider): #可以拦截到所有的响应对象 #当前项目一共会产生多少个响应对象呢？ #1 + 4 + n个响应对象，在这些响应对象中只有4这4个响应对象需要被修改 #如何筛选出指定的4个板块对应的响应对象呢？ #1.可以先找出指定4个板块的请求对象，然后根据请求对象定位指定4个响应对象 #2.可以根据4个板块的url定位到四个板块的请求对象 model_urls = spider.model_urls if request.url in model_urls: bro = spider.bro #从爬虫类中获取创建好的浏览器对象 bro.get(request.url) sleep(1) # bro.execute_script(\u0026#39;document.documentElement.scrollTo(0,9000)\u0026#39;) # sleep(1) #获取动态加载的数据 page_text = bro.page_source #说明该request就是指定响应对象的请求对象 #此处的response就是指定板块对应的响应对象 response = HtmlResponse(url=request.url, request=request, encoding=\u0026#39;utf-8\u0026#39;, body=page_text) #body就是响应对象的响应数据 return response else: return response def process_exception(self, request, exception, spider): pass 配置文件：\nDOWNLOADER_MIDDLEWARES = { \u0026#39;wangyiPro.middlewares.WangyiproDownloaderMiddleware\u0026#39;: 543, } 拓展功能：将人工智能+数据爬取中\n实现将爬取到的新闻进行分类和关键字提取\n百度AI的使用：https://ai.baidu.com/\n使用流程：\n点击首页右上角的控制台，进行登录。\n登录后进入到了智能云的首页\n点击页面左上角的三条杠，选择你想要实现的功能，点击，进入到指定功能页面\n在功能页面，首先点击【创建应用】，进行应用的创建 创建好之后，点击管理应用就可以看到： AppID，apiKey，secret key这三个值，会在程序中用到 在功能页面点击左侧的【技术文档】，选择SDK说明，选择对应的Python语言即可，先看快速开始内容，在选择你想要实现的具体功能的文档界面即可。\n环境安装：pip install baidu-aip 提取文章关键字：\nfrom aip import AipNlp \u0026#34;\u0026#34;\u0026#34; 你的 APPID AK SK \u0026#34;\u0026#34;\u0026#34; APP_ID = \u0026#39;xxx\u0026#39; API_KEY = \u0026#39;xxx\u0026#39; SECRET_KEY = \u0026#39;xxx\u0026#39; client = AipNlp(APP_ID, API_KEY, SECRET_KEY) title = \u0026#34;iphone手机出现“白苹果”原因及解决办法，用苹果手机的可以看下\u0026#34; content = \u0026#34;如果下面的方法还是没有解决你的问题建议来我们门店看下成都市锦江区红星路三段99号银石广场24层01室。\u0026#34; \u0026#34;\u0026#34;\u0026#34; 调用文章标签 \u0026#34;\u0026#34;\u0026#34; result = client.keyword(title, content) for dic in result[\u0026#39;items\u0026#39;]: if dic[\u0026#39;score\u0026#39;] \u0026gt;= 0.8: key = dic[\u0026#39;tag\u0026#39;] print(key) 文章分类：\nfrom aip import AipNlp \u0026#34;\u0026#34;\u0026#34; 你的 APPID AK SK \u0026#34;\u0026#34;\u0026#34; APP_ID = \u0026#39;xxx\u0026#39; API_KEY = \u0026#39;x\u0026#39; SECRET_KEY = \u0026#39;xx\u0026#39; client = AipNlp(APP_ID, API_KEY, SECRET_KEY) title = \u0026#34;秦刚访问特斯拉美国工厂马斯克陪同 传递什么信号？\u0026#34; content = \u0026#34;今天（4日），驻美大使秦刚访问了特斯拉硅谷工厂，同特斯拉CEO马斯克针对各项尖端科技、人类未来等主题展开探讨，并体验了特斯拉的新款Model S及最新自动辅助驾驶系统。他在海外社交平台上表示：“性能强劲，但乘坐平顺舒适”。\u0026#34; \u0026#34;\u0026#34;\u0026#34; 调用文章分类 \u0026#34;\u0026#34;\u0026#34; result = client.topic(title, content) class_new = result[\u0026#39;item\u0026#39;][\u0026#39;lv1_tag_list\u0026#39;][0][\u0026#39;tag\u0026#39;] print(class_new) CrawlSpider 实现网站的全站数据爬取\n就是将网站中所有页码对应的页面数据进行爬取。 crawlspider其实就是scrapy封装好的一个爬虫类，通过该类提供的相关的方法和属性就可以实现全新高效形式的全站数据爬取。\n使用流程：\n新建一个scrapy项目\ncd 项目\n创建爬虫文件（*）：\nscrapy genspider-t crawl spiderName www.xxx.com\n爬虫文件中发生的变化有哪些？\n当前爬虫类的父类为CrawlSpider 爬虫类中多了一个类变量叫做rules LinkExtractor：链接提取器 可以根据allow参数表示的正则在当前页面中提取符合正则要求的链接 Rule：规则解析器 可以接收链接提取器提取到的链接，并且对每一个链接进行请求发送 可以根据callback指定的回调函数对每一次请求到的数据进行数据解析 思考:如何将一个网站中所有的链接都提取到呢？ 只需要在链接提取器的allow后面赋值一个空正则表达式即可 目前在scrapy中有几种发送请求的方式？ start_urls列表可以发送请求 scrapy.Request() scrapy.FormRequest() Rule规则解析器 注意：\n链接提取器和规则解析器是一一对应的（一对一的关系） 建议在使用crawlSpider实现深度爬取的时候，需要配合手动请求发送的方式进行搭配！ USER_AGENT = \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36\u0026#39; 分布式 分布式在日常开发中并不常用，只是一个噱头！\n概念：\n可以使用多台电脑搭建一个分布式机群，使得多台对电脑可以对同一个网站的数据进行联合且分布的数据爬取。 声明：\n原生的scrapy框架并无法实现分布式操作！why？ 多台电脑之间无法共享同一个调度器 多台电脑之间无法共享同一个管道 如何是的scrapy可以实现分布式呢？\n借助于一个组件：scrapy-redis scrapy-redis的作用是什么？ 可以给原生的scrapy框架提供可被共享的调度器和管道！ 环境安装：pip install scrapy-redis 注意：scrapy-redis该组件只可以将爬取到的数据存储到redis数据库 编码流程（重点）：\n1.创建项目\n2.cd 项目\n3.创建基于crawlSpider的爬虫文件\n3.1 修改爬虫文件 导包：from scrapy_redis.spiders import RedisCrawlSpider 修改当前爬虫类的父类为 RedisCrawlSpider 将start_urls替换成redis_key的操作 redis_key变量的赋值为字符串，该字符串表示调度器队列的名称 进行常规的请求操作和数据解析 4.settings配置文件的修改\n常规内容修改（robots和ua等），先不指定日志等级\n指定可以被共享的管道类\nITEM_PIPELINES = { \u0026#39;scrapy_redis.pipelines.RedisPipeline\u0026#39;: 400 } 指定可以被共享的调度器\n# 使用scrapy-redis组件的去重队列 DUPEFILTER_CLASS = \u0026#34;scrapy_redis.dupefilter.RFPDupeFilter\u0026#34; # 使用scrapy-redis组件自己的调度器 SCHEDULER = \u0026#34;scrapy_redis.scheduler.Scheduler\u0026#34; # 是否允许暂停 SCHEDULER_PERSIST = True 指定数据库\nREDIS_HOST = \u0026#39;127.0.0.1\u0026#39; REDIS_PORT = 6379 5.修改redis数据库的配置文件（redis.windows.conf）\n在配置文件中改行代码是没有没注释的：\nbind 127.0.0.1 #将上述代码注释即可（解除本机绑定，实现外部设备访问本机数据库 如果配置文件中还存在：protected-mode = true，将true修改为false， 修改为false后表示redis数据库关闭了保护模式，表示其他设备可以远程访问且修改你数据库中的数据 6.启动redis数据库的服务端和客户端\n7.运行项目,发现程序暂定一直在等待，等待爬取任务\n8.需要向可以被共享的调度器的队列（redis_key的值）中放入一个起始的url\n在redis数据库的客户端执行如下操作：\nlpush 队列名称 起始的url 起始url：https://wz.sun0769.com/political/index/politicsNewest?id=1\u0026amp;page=1 增量式 爬虫应用场景分类\n通用爬虫 聚焦爬虫 功能爬虫 分布式爬虫 增量式： 用来监测网站数据更新的情况（爬取网站最新更新出来的数据）。 只是一种程序设计的思路，使用什么技术都是可以实现的。 核心： 去重。 使用一个记录表来实现数据的去重： 记录表：存储爬取过的数据的记录 如何构建和设计一个记录表： 记录表需要具备的特性： 去重 需要持久保存的 方案1：使用Python的set集合充当记录表？ 不可以的！因为set集合无法实现持久化存储 方案2：使用redis的set集合充当记录表？ 可以的，因为redis的set既可以实现去重又可以进行数据的持久化存储。 基于两个场景实现增量式爬虫：\n场景1：如果爬取的数据都是存储在当前网页中，没有深度的数据爬取的必要。 场景2：爬取的数据存在于当前页和详情页中，具备深度爬取的必要。 场景1的实现：\n数据指纹：\n数据的唯一标识。记录表中可以不直接存储数据本身，直接存储数据指纹更好一些。\n#爬虫文件 import scrapy import redis from ..items import Zlsdemo1ProItem class DuanziSpider(scrapy.Spider): name = \u0026#39;duanzi\u0026#39; # allowed_domains = [\u0026#39;www.xxxx.com\u0026#39;] start_urls = [\u0026#39;https://ishuo.cn/\u0026#39;] #Redis的链接对象 conn = redis.Redis(host=\u0026#39;127.0.0.1\u0026#39;,port=6379) def parse(self, response): li_list = response.xpath(\u0026#39;//*[@id=\u0026#34;list\u0026#34;]/ul/li\u0026#39;) for li in li_list: content = li.xpath(\u0026#39;./div[1]/text()\u0026#39;).extract_first() title = li.xpath(\u0026#39;./div[2]/a/text()\u0026#39;).extract_first() all_data = title+content #生成该数据的数据指纹 import hashlib # 导入一个生成数据指纹的模块 m = hashlib.md5() m.update(all_data.encode(\u0026#39;utf-8\u0026#39;)) data_id = m.hexdigest() ex = self.conn.sadd(\u0026#39;data_id\u0026#39;,data_id) if ex == 1:#sadd执行成功（数据指纹在set集合中不存在） print(\u0026#39;有最新数据的更新，正在爬取中......\u0026#39;) item = Zlsdemo1ProItem() item[\u0026#39;title\u0026#39;] = title item[\u0026#39;content\u0026#39;] = content yield item else:#sadd没有执行成功（数据指纹在set集合中存储） print(\u0026#39;暂无最新数据更新，请等待......\u0026#39;) 场景2的实现：\n使用详情页的url充当数据指纹即可。\nimport scrapy import redis from ..items import Zlsdemo2ProItem class JianliSpider(scrapy.Spider): name = \u0026#39;jianli\u0026#39; # allowed_domains = [\u0026#39;www.xxx.com\u0026#39;] start_urls = [\u0026#39;https://sc.chinaz.com/jianli/free.html\u0026#39;] conn = redis.Redis(host=\u0026#39;127.0.0.1\u0026#39;,port=6379) def parse(self, response): div_list = response.xpath(\u0026#39;//*[@id=\u0026#34;container\u0026#34;]/div\u0026#39;) for div in div_list: title = div.xpath(\u0026#39;./p/a/text()\u0026#39;).extract_first() #充当数据指纹 detail_url = \u0026#39;https:\u0026#39;+div.xpath(\u0026#39;./p/a/@href\u0026#39;).extract_first() ex = self.conn.sadd(\u0026#39;data_id\u0026#39;,detail_url) item = Zlsdemo2ProItem() item[\u0026#39;title\u0026#39;] = title if ex == 1: print(\u0026#39;有最新数据的更新，正在采集......\u0026#39;) yield scrapy.Request(url=detail_url,callback=self.parse_detail,meta={\u0026#39;item\u0026#39;:item}) else: print(\u0026#39;暂无数据更新！\u0026#39;) def parse_detail(self,response): item = response.meta[\u0026#39;item\u0026#39;] download_url = response.xpath(\u0026#39;//*[@id=\u0026#34;down\u0026#34;]/div[2]/ul/li[1]/a/@href\u0026#39;).extract_first() item[\u0026#39;download_url\u0026#39;] = download_url yield item scrapy项目部署 scrapyd部署工具介绍 scrapyd是一个用于部署和运行scrapy爬虫的程序，它由 scrapy 官方提供的。它允许你通过JSON API来部署爬虫项目和控制爬虫运行。 所谓json api本质就是post请求的webapi\n选择一台主机当做服务器，安装并启动 scrapyd 服务。再这之后，scrapyd 会以守护进程的方式存在系统中，监听爬虫地运行与请求，然后启动进程来执行爬虫程序。 环境安装 scrapyd服务: ​\tpip install scrapyd\nscrapyd客户端: ​\tpip install scrapyd-client\n​\t一定要安装较新的版本10以上的版本，如果是现在安装的一般都是新版本\n启动scrapyd服务 打开终端在scrapy项目路径下 启动scrapyd的命令： scrapyd scrapyd 也提供了 web 的接口。方便我们查看和管理爬虫程序。默认情况下 scrapyd 监听 6800 端口，运行 scrapyd 后。在本机上使用浏览器访问 http://localhost:6800/地址即可查看到当前可以运行的项目。 点击job可以查看任务监控界面 scrapy项目部署 配置需要部署的项目 编辑需要部署的项目的scrapy.cfg文件(需要将哪一个爬虫部署到scrapyd中，就配置该项目的该文件) [deploy:部署名(部署名可以自行定义)] url = http://localhost:6800/ project = 项目名(创建爬虫项目时使用的名称) username = bobo # 如果不需要用户名可以不写 password = 123456 # 如果不需要密码可以不写 部署项目到scrapyd 同样在scrapy项目路径下执行如下指令：\nscrapyd-deploy 部署名(配置文件中设置的名称) -p 项目名称 部署成功之后就可以看到部署的项目\n使用以下命令检查部署爬虫结果：\nscrapyd-deploy -L 部署名 管理scrapy项目 指令管理 安装curl命令行工具\nwindow需要安装 linux和mac无需单独安装 window安装步骤：\n下载curl文件：https://curl.se/download.html，打开网页后向下拖动，找到window系统对应版本下载 下载后，放置到一个无中文的文件夹下直接解压缩，解压后将bin文件夹配置环境变量！ 参考网页：https://www.cnblogs.com/lisa2016/p/12193494.html 启动项目：\ncurl http://localhost:6800/schedule.json -d project=项目名 -d spider=爬虫名 返回结果：注意期中的jobid，在关闭项目时候会用到\n{\u0026#34;status\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;jobid\u0026#34;: \u0026#34;94bd8ce041fd11e6af1a000c2969bafd\u0026#34;, \u0026#34;node_name\u0026#34;: \u0026#34;james-virtual-machine\u0026#34;} 关闭项目：\ncurl http://localhost:6800/cancel.json -d project=项目名 -d job=项目的jobid 删除爬虫项目：\ncurl http://localhost:6800/delproject.json -d project=爬虫项目名称 requests模块控制scrapy项目 import requests # 启动爬虫 url = \u0026#39;http://localhost:6800/schedule.json\u0026#39; data = { \u0026#39;project\u0026#39;: 项目名, \u0026#39;spider\u0026#39;: 爬虫名, } resp = requests.post(url, data=data) # 停止爬虫 url = \u0026#39;http://localhost:6800/cancel.json\u0026#39; data = { \u0026#39;project\u0026#39;: 项目名, \u0026#39;job\u0026#39;: 启动爬虫时返回的jobid, } resp = requests.post(url, data=data) 生产者消费者模式 认识生产者和消费者模式 生产者和消费者是异步爬虫中很常见的一个问题。产生数据的模块，我们称之为生产者，而处理数据的模块，就称为消费者。\n例如：\n​\t图片数据爬取中，解析出图片链接的操作就是在生产数据\n​\t对图片链接发起请求下载图片的操作就是在消费数据\n为什么要使用生产者和消费者模式 ​ 在异步世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。\nimport requests import threading from lxml import etree from queue import Queue from urllib.request import urlretrieve from time import sleep headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36\u0026#34;, } #生产数据：解析提取图片地址 class Producer(threading.Thread):#生产者线程 def __init__(self,page_queue,img_queue): super().__init__() self.page_queue = page_queue self.img_queue = img_queue def run(self): while True: if self.page_queue.empty(): print(\u0026#39;Producer任务结束\u0026#39;) break #从page_queue中取出一个页码链接 url = self.page_queue.get() #从当前的页码对应的页面中解析出更多的图片地址 self.parse_detail(url) def parse_detail(self,url): response = requests.get(url,headers=headers) response.encoding = \u0026#39;gbk\u0026#39; page_text = response.text tree = etree.HTML(page_text) li_list = tree.xpath(\u0026#39;//*[@id=\u0026#34;main\u0026#34;]/div[3]/ul/li\u0026#39;) for li in li_list: img_src = \u0026#39;https://pic.netbian.com\u0026#39;+li.xpath(\u0026#39;./a/img/@src\u0026#39;)[0] img_title = li.xpath(\u0026#39;./a/b/text()\u0026#39;)[0]+\u0026#39;.jpg\u0026#39; dic = { \u0026#39;title\u0026#39;:img_title, \u0026#39;src\u0026#39;:img_src } self.img_queue.put(dic) #消费数据：对图片地址进行数据请求 class Consumer(threading.Thread):#消费者线程 def __init__(self,page_queue,img_queue): super().__init__() self.page_queue = page_queue self.img_queue = img_queue def run(self): while True: if self.img_queue.empty() and self.page_queue.empty(): print(\u0026#39;Consumer任务结束\u0026#39;) break dic = self.img_queue.get() title = dic[\u0026#39;title\u0026#39;] src = dic[\u0026#39;src\u0026#39;] print(src) urlretrieve(src,\u0026#39;imgs/\u0026#39;+title) print(title,\u0026#39;下载完毕！\u0026#39;) def main(): #该队列中存储即将要要去的页面页码链接 page_queue = Queue(20) #该队列存储生产者生产出来的图片地址 img_queue = Queue(60) #该循环可以将2，3，4这三个页码链接放入page_queue中 for x in range(2,10): url = \u0026#39;https://pic.netbian.com/4kmeinv/index_%d.html\u0026#39;%x page_queue.put(url) #生产者 for x in range(3): t = Producer(page_queue,img_queue) t.start() #消费者 for x in range(3): t = Consumer(page_queue,img_queue) t.start() main() ","permalink":"https://canw0916.github.io/en/posts/tech/scrapy%E6%A1%86%E6%9E%B6/","summary":"简介 什么是框架？ 所谓的框，其实说白了就是一个【项目的半成品】，该项目的半成品需要被集成了各种功能且具有较强的通用性。 Scrapy是一个为了爬","title":"Scrapy框架"},{"content":"MongoDB数据存储 MongoDB是一个非关系型数据库(NoSQL). 非常适合超大数据集的存储, 由 C++ 语言编写,旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n下面是Sql与mongodb的术语对比\nSQL Mongodb 表（Talbe） 集合（Collection） 行（Row） 文档（Document） 列（Col） 字段（Field） 主键（Primary Key） 对象ID（ObjectId） 一, MongoDB与安装(windows) 首先去官网下载MongoDB的安装包, https://www.mongodb.com/try/download/community\n将mongodb目录下的bin文件夹添加到环境变量\n对于mac的安装:https://blog.csdn.net/qq991658923/article/details/121436106\nMac启动： mongod \u0026ndash;dbpath /opt/mongodb/data \u0026ndash;logpath /opt/mongodb/log/mongo.log \u0026ndash;fork mongo 二, MongoDB的简单使用 简单介绍一下mongoDB中一些操作(了解)\nshow dbs: 显示所有数据库 show databases: 显示所有数据库 use xxxx: 使用指定数据库/创建数据库（新库中插入数据才可以显示新库） db: 当前正在使用的数据库 db.dropDatabase(): 删除数据库 show collections: 显示当前数据库中所有的集合(表) 三, MongoDB的增删改查 1. mongodb中常见的数据类型(了解): Object ID: 主键ID【\u0026#34;_id\u0026#34; : ObjectId(\u0026#34;56063f17ade2f21f36b03133\u0026#34;)】 String: 字符串 Boolean: 布尔值 Integer: 数字 Doube: 小数 Arrays: 数组,[1,2,3] Object: 文档(关联其他对象) {sname: 李嘉诚, sage: 18, class:{cccc}} Null : 空值 Timestamp: 时间戳 Date: 时间日期 2. mongodb插入数据/文档 #collection_name集合/表不存在则会新建 db.collection_name.insert({字段:值,字段:值}) 示例:\ndb.c1.insert({name:\u0026#34;bobo\u0026#34;, age:18, hobby:[\u0026#39;eat\u0026#39;, \u0026#39;sleep\u0026#39;]}) 插入多条数据：\n#c1是表名/集合名 db.getCollection(\u0026#39;c1\u0026#39;).insertMany([ { \u0026#34;name\u0026#34;:\u0026#34;bobo\u0026#34;, }, { \u0026#34;address\u0026#34;:\u0026#34;河北\u0026#34; }, ] ); 注意, 如果集合不存在. 则会自动创建集合\n插入数据后可以查询所有数据查看是否插入成功：\ndb.stu.find() 3. mongodb修改数据 3.1 update更新 #d1是表名 db.d1.update({查询条件}, {待修改内容}, {multi: 是否多条数据修改}) multi:true表示修改满足条件所有的内容，否则只修改满足条件的第一条内容,multi不写默认为false 示例:\ndb.d1.update({name:\u0026#34;bobo\u0026#34;}, {$set:{title:\u0026#34;alex\u0026#34;, hobby:[\u0026#39;抽烟\u0026#39;, \u0026#39;喝酒\u0026#39;, \u0026#39;烫头\u0026#39;]}}, {multi:true}); 4.mongodb删除数据 4.1 remove() db.collection_name.remove({条件}, {justOne:true|false}) db.collection_name.remove() 删除所有记录 db.collection_name.drop() 删除collection/表 示例:\ndb.nor_col.remove({name:\u0026#34;jay\u0026#34;}, {justOne:true}) 4.2 deleteOne() db.collection_name.deleteOne({条件}) 示例:\ndb.nor_col.deleteOne({name:\u0026#34;jay\u0026#34;}) 4.3 deleteMany() db.collection_name.deleteMany({条件}) 示例:\ndb.nor_col.deleteMany({name:\u0026#34;jay\u0026#34;}) 5. mongodb查询数据 准备数据:\ndb.stu.insert([ {name: \u0026#34;朱元璋\u0026#34;, age:800, address:\u0026#39;安徽省凤阳\u0026#39;, score: 160}, {name: \u0026#34;朱棣\u0026#34;, age:750, address:\u0026#39;江苏省南京市\u0026#39;, score: 120}, {name: \u0026#34;朱高炽\u0026#34;, age:700, address:\u0026#39;北京紫禁城\u0026#39;, score: 90}, {name: \u0026#34;李嘉诚\u0026#34;, age:38, address:\u0026#39;香港xxx街道\u0026#39;, score: 70}, {name: \u0026#34;麻花藤\u0026#34;, age:28, address:\u0026#39;广东省xxx市\u0026#39;, score: 80}, {name: \u0026#34;大老王\u0026#34;, age:33, address:\u0026#39;火星第一卫星\u0026#39;, score: -60}, {name: \u0026#34;咩咩\u0026#34;, age:33, address:\u0026#39;开普勒225旁边的黑洞\u0026#39;, score: -160} ]) 5.1 普通查询 db.c1.find() 查询所有 db.c1.find({\u0026#34;字段\u0026#34;:\u0026#34;固定值\u0026#34;}) 查询满足条件的所有数据 db.c1.findOne({条件}) 查询满足条件的第一条数据 db.getCollection(\u0026#39;c1\u0026#39;).find({\u0026#34;字段1\u0026#34;:\u0026#34;固定值1\u0026#34;,\u0026#34;字段2\u0026#34;:\u0026#34;固定值2\u0026#34;}) 5.2 比较运算 等于： 默认是等于判断， $eq 小于：$lt （less than） 小于等于：$lte （less than equal） 大于：$gt （greater than） 大于等于：$gte 不等于：$ne db.stu.find({age:28}) 查询年龄是28岁的学生信息 db.stu.find({age: {$eq: 28}}) 查询年龄是28岁的学生信息 db.stu.find({age: {$gt: 30}}) 查询年龄大于30岁的学生 db.stu.find({age: {$lt: 30}}) 查询年龄小于30岁的学生 db.stu.find({age: {$gte: 38}}) 查询年龄大于等于30岁的学生 db.stu.find({age: {$lte: 38}}) 查询年龄小于等于30岁的学生 db.stu.find({age: {$ne: 38}}) 查询年龄不等于38的学生 5.3 逻辑运算符 and $and: [条件1, 条件2, 条件3\u0026hellip;.] 查询年龄等于33, 并且, 名字是\u0026#34;大老王\u0026#34;的学生信息 db.stu.find({$and:[{age: {$eq:33}}, {name:\u0026#39;大老王\u0026#39;}]}) or $or: [条件1, 条件2, 条件3] 查询名字叫\u0026#34;李嘉诚\u0026#34;的, 或者, 年龄超过100岁的人 db.stu.find({$or: [{name: \u0026#39;李嘉诚\u0026#39;}, {age: {$gt: 100}}]}) nor\n$nor: [条件1, 条件2, 条件3]\n查询年龄不小于38岁的人, 名字还不能是朱元璋. db.stu.find({$nor: [{age: {$lt: 38}}, {name: \u0026#34;朱元璋\u0026#34;}]}) 5.4 范围运算符 ​\t使用$in， $nin判断数据是否在某个数组内\ndb.stu.find({age: {$in:[28, 38]}}) 年龄是28或者38的人 5.5 正则表达式 ​\t使用$regex进行正则表达式匹配\ndb.stu.find({address: {$regex:\u0026#39;^北京\u0026#39;}}) 查询地址是北京的人的信息 db.stu.find({address: /^北京/}) 效果一样 5.6 skip和limit db.stu.find().skip(3).limit(3)\t跳过3个. 提取3个. 类似limit 3, 3 可以用来做分页\n5.7 排序 sort({字段:1, 字段:-1})\n1表示升序 -1表示降序\n对查询结果排序, 先按照age升序排列, 相同项再按照score降序排列 db.stu.find().sort({age:1, score: -1}) 5.8 统计数量 count(条件) 查询数量\ndb.stu.count({age:33}) 四，pymongo的使用 python处理mongodb首选就是pymongo. 首先, 安装一下这个模块\npip install pymongo 建立连接\nimport pymongo conn = pymongo.MongoClient(host=\u0026#39;localhost\u0026#39;, port=27017) # 切换数据库 py = conn[\u0026#39;python\u0026#39;] # 登录该数据库(需要的话) #py.authenticate(\u0026#34;python_admin\u0026#34;, \u0026#39;123456\u0026#39;) # 简单来个查询 result = py[\u0026#34;stu\u0026#34;].find() for r in result: print(r) 完成增删改查\nimport pymongo from pymongo import MongoClient #创建返回链接对象 def get_db(database): client = MongoClient(host=\u0026#34;localhost\u0026#34;, port=27017) db = client[database] return db # 增删改查 # 增加数据 def add_one(table, data): db = get_db(\u0026#34;python\u0026#34;) result = db[table].insert_one(data) return result def add_many(table, data_list): db = get_db(\u0026#34;python\u0026#34;) result = db[table].insert_many(data_list) return result.inserted_ids def upd(table, condition, data):#condition条件 db = get_db(\u0026#34;python\u0026#34;) result = db[table].update_many(condition, {\u0026#39;$set\u0026#39;:data}) return result def delete(table, condition):#condition条件 db = get_db(\u0026#34;python\u0026#34;) result = db[table].delete_many(condition) return result if __name__ == \u0026#39;__main__\u0026#39;: # r = add_one(\u0026#34;stu\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;西瓜\u0026#34;, \u0026#34;age\u0026#34;:18}) # print(r.inserted_id) # r = add_many(\u0026#34;stu\u0026#34;, [{\u0026#34;name\u0026#34;: \u0026#34;嘎嘎\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;咔咔\u0026#34;}]) # print(r) # result = upd(\u0026#34;stu\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#39;西瓜\u0026#39;}, {\u0026#34;age\u0026#34;: 100}) # print(result) result = delete(\u0026#34;stu\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;嘎嘎\u0026#34;}) print(result) ","permalink":"https://canw0916.github.io/en/posts/tech/mongodb/","summary":"MongoDB数据存储 MongoDB是一个非关系型数据库(NoSQL). 非常适合超大数据集的存储, 由 C++ 语言编写,旨在为 WEB 应用提供可扩展的高性","title":"MongoDB"},{"content":"redis基本使用 介绍：\nredis是一款非关系型数据库或者缓存数据库（性能最高的非关系型数据库之一），拥有每秒近十万次的读写能力。 安装\u0026amp;启动\n安装：\n使用免安装版本即可，免安装版本压缩包在window和mac文件夹中，对压缩包解压缩即可。 启动：\nwindow：\n终端进入到解压缩文件夹的bin目录下，执行./redis-server启动服务，执行./redis-cli启动客户端 mac：\n终端进入到解压缩文件夹的src目录下，执行./redis-server启动服务，执行./redis-cli启动客户端 redis-cli #无密码且数据库在你本机，执行该指令 redis-cli -h ip地址 -p 端口 --raw auth 密码 #raw可以让redis显示出中文(windows无效)如果有密码可以这样来登录, 如果没有,不用这一步 redis常见数据类型\nstring类型\nset key value # 添加一条数据 get key\t# 查看一条数据 hash类型\nhset key k1 v1 # 将k1, v1存储在key上 hget key k1 # 将key上的k1提取出来 hmset key k1 v1 k2 v2 k3 v3.... # 一次性将多个k,v存储在key hmget key k1 k2....# 一次性将key中的k1, k2...提取出来 hgetall key # 一次性将key中所有内容全部提取 hkeys key\t# 将key中所有的k全部提取 hvals key # 将key中所有的v全部提取 例如： hmset stu id 1 name bobo age 18 HMGET stu name age # bobo 18 list类型(重点)：底层是一个双向链表. 可以从左边和右边进行插入\nLPUSH key 数据1 数据2 数据3.... # 从左边插入数据 RPUSH key 数据1 数据2 数据3.... # 从右边插入数据 LRANGE key start stop # 从start到stop提取数据. LLEN key\t# 返回key对应列表的长度 LPOP key # 从左边删除一个.并返回被删除元素 RPOP key\t# 从右边删除一个.并返回被删除元素 set类型（重点）：set是无序的超大集合。无序, 不重复\nSADD key 值 # 向集合内存入数据 SMEMBERS key # 查看集合内所有元素 SPOP key # 随机从key中删除一个数据 python链接redis 环境安装：pip install redis==2.10.6\nimport redis #创建链接对象 conn = redis.Redis(host=\u0026#39;127.0.0.1\u0026#39;,port=6379) #插入数据 # result = conn.sadd(\u0026#39;class\u0026#39;,\u0026#39;num4\u0026#39;) # print(result) # result = conn.lpush(\u0026#39;hobby\u0026#39;,\u0026#39;haha\u0026#39;) # print(result) #查询set集合里的数据 print(conn.smembers(\u0026#39;class\u0026#39;)) ","permalink":"https://canw0916.github.io/en/posts/tech/redis/","summary":"redis基本使用 介绍： redis是一款非关系型数据库或者缓存数据库（性能最高的非关系型数据库之一），拥有每秒近十万次的读写能力。 安装\u0026am","title":"Redis"},{"content":"python操作链接数据库 pymysql模块:pip install pymysql\n作用:可以实现使用python程序链接mysql数据库，且可以直接在python中执行sql语句 import pymysql #1.创建链接对象 conn = pymysql.Connect( host=\u0026#39;127.0.0.1\u0026#39;,#数据库服务器主机地址 port=3306, #mysql的端口号 user=\u0026#39;root\u0026#39;, #数据库的用户名 password=\u0026#39;boboadmin\u0026#39;, #数据库密码 db=\u0026#39;AnHui\u0026#39;,#数据仓库的名称 charset=\u0026#39;utf8\u0026#39;) #创建一个游标对象 cusor = conn.cursor() #2.增加记录操作 # sql = \u0026#39;insert into emp(name,sex,age,dep_id)values(\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,%d,%d)\u0026#39;%(\u0026#39;haha\u0026#39;,\u0026#39;female\u0026#39;,20,200) # cusor.execute(sql) # conn.commit() #对数据进行整改后，记得进行事物的提交 #3.删除记录 # sql = \u0026#39;delete from emp where name = \u0026#34;%s\u0026#34;\u0026#39;%\u0026#39;haha\u0026#39; # print(sql) # cusor.execute(sql) # conn.commit() #4.修改操作 # new_age = input(\u0026#39;enter a new age:\u0026#39;) # new_age = int(new_age) # sql = \u0026#39;update emp set age = %d where id = 3\u0026#39;%new_age # print(sql) # cusor.execute(sql) # conn.commit() #查询操作 sql = \u0026#39;select * from emp where age \u0026gt; 30\u0026#39; cusor.execute(sql) #负责执行sql语句 #fetchall返回的是一个元组，元组元素又为一个元素，该元组中存储的是查询到的一条记录 # all_data = cusor.fetchall() #获取查询到所有的数据，如果没有查询到数据返回一个空元组 # print(all_data) #fetchone只会返回查询到的第一条数据 one_data = cusor.fetchone() #如果没有查询到数据返回None print(one_data) #关闭打开的资源对象 cusor.close() conn.close() 登录注册 import pymysql conn = pymysql.Connect( host=\u0026#39;127.0.0.1\u0026#39;, port=3306, user=\u0026#39;root\u0026#39;, password=\u0026#39;boboadmin\u0026#39;, db=\u0026#39;AnHui\u0026#39;, charset=\u0026#39;utf8\u0026#39; ) cusor = conn.cursor() def regist(): username = input(\u0026#39;enter username:\u0026#39;) password = input(\u0026#39;enter password:\u0026#39;) email = input(\u0026#39;enter email:\u0026#39;) phone = input(\u0026#39;enter phone:\u0026#39;) #判定用户名是否重复 s = \u0026#39;select * from userData where username=\u0026#34;%s\u0026#34;\u0026#39;%username cusor.execute(s) r = cusor.fetchone() #如果查询到结果则表示用户名存在 if r == None: sql = \u0026#39;insert into userData(username,passwowrd,email,phone) values(\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;)\u0026#39;%(username,password,email,phone) cusor.execute(sql) conn.commit() print(\u0026#39;注册成功！\u0026#39;) else: print(\u0026#39;注册失败，用户名已经存在！\u0026#39;) def login(): username = input(\u0026#39;enter username:\u0026#39;) password = input(\u0026#39;enter password:\u0026#39;) sql1 = \u0026#39;select * from userData where username=\u0026#34;%s\u0026#34;\u0026#39;%username cusor.execute(sql1) r1 = cusor.fetchone() if r1 == None: #如果fetchone没有查询到数据返回的是None print(\u0026#39;登录失败，用户名不存在！\u0026#39;) else:#用户名存在 pwd = r1[2] if pwd == password: print(\u0026#39;登录成功！\u0026#39;) else: print(\u0026#39;登录失败，密码错误！\u0026#39;) 事物处理(大致了解) 什么是事物？\nMysql的事物主要是指一组处理操作量大，复杂度高的数据的操作。 事务其实就是MySQL中处理数据的一种方式,主要用在数据完整性高,数据之间依赖性大的情况下的一种数据处理方式. 举个例子 ,在小张点击了确认转账的按钮时,系统突然崩溃了.会出现这样几中不正确的情况: 1.小张的钱打到小李的账户上,但是自己的账户上的钱没被扣. 2.小张的钱打没到小李的账户上了,但是自己账户上的钱被扣. 这样的业务场景就需要MySQL事务保持,即使机器出故障的情况下,数据仍然是正确的. import pymysql #1.创建链接对象 conn = pymysql.Connect( host=\u0026#39;127.0.0.1\u0026#39;,#数据库服务器主机地址 port=3306, #mysql的端口号 user=\u0026#39;root\u0026#39;, #数据库的用户名 password=\u0026#39;boboadmin\u0026#39;, #数据库密码 db=\u0026#39;AnHui\u0026#39;,#数据仓库的名称 charset=\u0026#39;utf8\u0026#39;) #创建一个游标对象 cusor = conn.cursor() #小张向小李的银行卡打200块钱 sql1 = \u0026#39;update bankTab set monry -= 200 where name = \u0026#34;小张\u0026#34;\u0026#39; sql2 = \u0026#39;update bankTab set monry += 200 where123 name = \u0026#34;小李\u0026#34;\u0026#39; try: cusor.execute(sql1) #成功执行 cusor.execute(sql2) #发成异常 conn.commit() #说明转账成功，数据就写死到数据库，没有办法在回撤 except Exception as e: print(e) conn.rollback() #事物的回滚:将try中执行成功的sql效果撤回 cusor.close() conn.close() 事物的特点\n原子性 一个事务必须被作为一个不可分割的最小工作单元,每个事务中的所有操作必须要么成功,或者要么失败,永远不可能一些操作失败,一些操作成功,这就是所谓的原子性的概念. 一致性 一致性就像上面举的一个例子一样,当发生异常情况下,数据仍然是正确的.就是说当一个事务执行失败了,数据之间是不会受异常的情况而影响,永远保持着他的正确性. 隔离性 当一个事务还未提交,每个事务之间是相互隔离的,互补受到影响. 持久性 当一个事务进行提交之后,发生的变化就会永远保存在数据库中. 事物的提交和回滚\ncommit rollback ","permalink":"https://canw0916.github.io/en/posts/tech/mysql%E9%AB%98%E7%BA%A7/","summary":"python操作链接数据库 pymysql模块:pip install pymysql 作用:可以实现使用python程序链接mysql数据库，且可以直接在python中执","title":"Mysql高级"},{"content":"数据库概述 为什么要使用数据库？\n那我们在没有学习数据库的时候，数据存放在json或者磁盘文件中不也挺好的嘛，为啥还要学习数据库？\n文件中存储数据，无法基于文件直接对数据进行操作或者运算，必须借助python将数据读取到计算机内存中然后基于Python程序操作数据，麻烦而且性能不高。\n使用文件存储数据，无法实现数据的共享。\n什么是数据库呢？先介绍几个概念：\n数据：Data\n描述事物的符号记录称为数据，描述事物的符号既可以是数字，也可以是文字、图片，图像、声音、语言等，数据由多种表现形式，它们都可以经过数字化后存入计算机。\n例如：描述一个人的基本信息就是一组数据，在数据库中叫一行记录。\nname age sex Ailsa 23 女 数据库：DataBase(DB)\n即存放数据的仓库，我们可以把它想象成文件夹，里面存放了很多张表，每个表就是一个文件，不过数据库中的数据是按照一定的规则进行组织、描述和储存，且具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享\n数据库管理软件\n在了解了Data与DB的概念后，如何科学地组织和存储数据，如何高效获取和维护数据成了关键，这就用到了一个系统软件\u0026mdash;数据库管理系统\n如MySQL、Oracle、SQLite、Access、MS SQL Server\n但是我们日常工作中经常会把数据库管理软件称为数据库，注意理解对象的意思：例如\n小王啊，你们公司用的什么数据库啊，这个指的是数据库管理软件 小王啊，这个学生管理系统的数据库是哪个？这个指的就是数据库文件夹，一般情况下一个项目的所有涉及到的数据会存放在一个数据库中，方便统一管理。 总结：\n数据库服务器：运行数据库管理软件 数据库管理软件：管理数据库 数据库：即文件夹，用来组织文件/表 表：即文件，用来存放多行内容/多条记录 Mysql介绍 数据库管理软件按照分类分为 关系型数据库和非关系型数据库 关系型数据库 在数据库中各个表之间存在关联关系，需要设计表结构，一张表中每个字段之间也存在关系，通过SQL语句对数据库进行增删改查的操作。 例如：MySQL、oracle 、sql server、sqllite，access，db2 注意：sql语句通用 非关系型数据库 非关系型数据库是key-value存储的，没有表结构，存取速度快 例如：redis、mongodb Mysql： MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 MySQL被广泛的应用在Internet上的大中小型网站中。由于体积小、速度快、总体拥有成本低，开放源代码 特点:开源,免费,应用广泛 Mysql下载和安装 下载 我们下载安装的是mysql管理软件，它相当于是一个服务端，每个建立好的连接的用户都可以访问，但是这里为了让自己自主学习，所以我们会把这个软件下载安装到每个人的自己电脑上，相当于在自己电脑上安装了mysql的服务端，这个软件他也自带一个客户端，我们可以通过cmd终端的形式进行访问，当然也可以通过可视化工具navicate来访问，接下来我们会一一讲解。\nmysql管理下载\n第一步：打开网址，https://www.mysql.com，点击downloads之后跳转到https://www.mysql.com/downloads\n第二步：选择Community选项\n第三步：选择对应的操作系统版本\n第四步：选择具体版本的mysql，建议选择5.6或者5.7版本\n第五步：直接下载\n解压 下载的zip文件解压，将解压之后的文件夹放到任意目录下，这个目录就是mysql的安装目录。 注意:安装目录尽量在某盘的根目录下,如果不在根目录,则安装路径中不能有中文,不能有特殊转义符的出现。 配置环境变量 在系统变量PATH后面添加: 你的mysql的bin文件夹的路径（如C:\\Program Files\\mysql-5.6.41-winx64\\bin） 执行初始化 在任意路径下，以管理员的身份打开终端执行：\nmysqld --initialize-insecure 初始化时将root用户的登录密码设置为空。\n注意，如果报错：提示缺少MSVCP120.dll文件的话，后面有解决办法。\n初始化成功如下图：\n初始化成功的另一个标志是，在MySQL的安装目录中，会多个data目录，这个data目录是是MySQL在初始化过程中创建的数据目录。\n安装Mysql服务 1.以管理员身份打开cmd窗口，记住,一定要是管理员身份 2.输入如下指令： mysqld install 回车运行 启动Mysql服务 现在系统的服务中就可以找到MySQL了。 但此时MySQL服务还没有启动，你可以在服务中点击启动，也可以在终端中使用net命令来启动/关闭MySQL服务。 ok，现在MySQL服务正常启动了，并且，由于系统服务中的MySQL服务设置的是自动，下次系统启动时，MySQL服务也默认启动了。 服务启动成功之后，就可以登录了 输入mysql -u root -p（第一次登录没有密码，直接按回车过） 但登录成功之后需要设置密码: 语法: set password = password(\u0026lsquo;密码\u0026rsquo;) 为了方便记忆，密码尽量简单一点，但是实际工作中为了保证数据安全，密码尽量设置的复杂一些。 可能发生问题处理 缺少MSVCP120.dll文件 报错原因是，系统缺少Visual C ++可再发行组件包。\n解决：\n打开microsoft官网：https://www.microsoft.com/en-us/download/details.aspx?id=40784，点击下载: 根据系统位数选择下载： 以管理员的身份运行，然后默认安装即可。 重新以管理员身份打开终端，重新执行初始化步骤吧！ mysqld --initialize-insecure Navicate下载安装 Navicate是一种操作数据库的可视化工具。 下载地址：https://www.navicat.com.cn/products 使用Navicate链接数据库：连接成功之后，你就可以通过该软件查看所有的数据库文件了 Sql概述 先来看一个例子：小王第一次使用数据库，然后跟数据库来了个隔空对话\n其实，我们想一想，mysql是一个软件，它有它自己一套的管理规则，我们想要跟它打交道，就必须遵守它的规则，如果我想获取数据，它自己有一套规则，这个规则就是SQL。 什么是sql？\nSQL : 结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程言，是一种数据库查询和程序设计语言，SQL语言主要用于存取数据、查询数据、更新数据和管理关系数据库系统,SQL语言由IBM开发。 其实简单的说，就是你发送给他能识别的暗号，他懂了就会给你返回数据。 注意： 对于关系型数据库而言，SQL语句是通用的，学会了一种，其他只是一些细微的差别，毕竟人家数据库也是一个种族，语言是通用的，只不过有些存在方言的差别。 sql的分类\nSQL语言分为3种类型：\n1、DDL语句 数据库定义语言： 数据库、表、视图、索引、存储过程，例如CREATE DROP ALTER\n2、DML语句 数据库操纵语言： 插入数据INSERT、删除数据DELETE、更新数据UPDATE、查询数据SELECT\n3、DCL语句 数据库控制语言： 例如控制用户的访问权限GRANT、REVOKE\n库表操作DDL 库的增删改查 这里的库指的数据库，也就是我们所谓的那个文件夹，一般情况下，我们在开发项目前，会先设计数据库中相关表结构，一个项目中所有表都会放在同一个文件夹下，对于库的操作属于SQL分类中的DDL，也就是数据库定义语言。\n创建数据库\ncreate database 仓库名; 创建数据库并制定编码:utf8设置好后，就表示数据库中可以存储中文数据\ncreate database 仓库名 charset utf8; 使用数据库\nuse 仓库名; 查看所有数据库和单独常看当前数据库\nshow databases; #查看当前所有的数据仓库 select database(); #查看当前使用的是哪一个数据仓库 #注意：sql语句不区分大小写，但是sql中使用的标识符尽量控制大小写 修改数据库\n数据库的名称一旦创建好之后就无法修改 修改数据库一般只修改编码 alter database 仓库名 charset gbk #将数据的字符集编码修改成了gbk 删除数据库\ndrop database 仓库名; 表的增删改查 创建表 create table 表名( 字段名1 类型(宽度) 约束条件, 字段名2 类型(宽度) 约束条件, 字段名3 类型(宽度) 约束条件, ); 注意: 1.字段名不能重复 2.宽度和约束条件可选 3.字段名和类型是必须的 查看表结构 desc 表名； 数据类型 **字符串：**顾名思义，就是存储的一连串的字符，例如文字\n​\n数值型：常用的有：int ，double， float\n整数型：int 基本int能够处理日常工作中大部分整数存储问题\n小数型：double float\n强调一下float(5,2)其中5代表总长度，2代表小数长度,这个意思是整数是3位,小数是2位 日常工作中float足以解决小数问题了。\n日期类型\nnow()函数：返回当前系统时间\ndate：年月日\ntime：时分秒\ndatetime：年月日时分秒\ncreate table t(date1 date,date2 time,date3,datetime); insert into t(now(),now(),now()); mysql\u0026gt; select * from t; +------------+----------+---------------------+ | date1 | date2 | date3 | +------------+----------+---------------------+ | 2020-04-15 | 16:02:43 | 2020-04-15 16:02:43 | +------------+----------+---------------------+ 1 row in set (0.00 sec) ENUM和SET类型：\n这里的类似于下拉字段，在进行数据插入的时候，必须选择事先设置的内容 对于set而言，可以多选，但是enum只能单选 create table UserData ( id int, #用户编号 money float(9,2),#用户余额 registTime datetime,#用户的注册时间 usernmae varchar(50), sex enum(\u0026#39;male\u0026#39;,\u0026#39;female\u0026#39;),#单选 address set(\u0026#39;BJ\u0026#39;,\u0026#39;SH\u0026#39;,\u0026#39;GZ\u0026#39;)#多选 ) 约束条件 为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。\n约束条件与数据类型的宽度一样，都是可选参数，主要分为以下几种：\nNOT NULL ：非空约束，指定某列不能为空； DEFAULT:默认值 UNIQUE : 唯一约束，指定某列或者几列组合不能重复 PRIMARY KEY ：主键，指定该列的值可以唯一地标识该列记录 FOREIGN KEY ：外键，指定该行记录从属于主表中的一条记录，主要用于参照完整性 not null:不为空，当你设置一个字段时，不允许它为空，可以使用此约束条件\ncreate table t1 ( id int, name varchar(20) not null#name字段的值不可以为空 ) default 默认值\n例如：对于性别一列，如果大部分都是男性，可以设置成默认值，不填则取默认值，填写了则覆盖默认值 create table t2 ( id int, name varchar(20), sex char(10) DEFAULT(\u0026#39;male\u0026#39;) ) unique 唯一:当有一列字段你不想让它有重复值时，可以设置为唯一\ncreate table t3 ( id int unique, #唯一约束 name varchar(20) ) 联合唯一：只有当你设置的这些字段同时重复时才会报错 create table t4 ( id int, name varchar(20), dep char(10), UNIQUE(name,dep) #联合唯一约束 ) primary key\n主键为了保证表中的每一条数据的该字段都是表格中的唯一值。换言之，它是用来独一无二地确认一个表格中的每一行数据。\n主键可以包含一个字段或多个字段。当主键包含多个字段时，称为组合键 (Composite Key),也可以叫联合主键。\n单字段主键：\ncreate table t5 ( id int PRIMARY KEY , #主键约束 name varchar(20), salary float(6,2) ) 联合主键:\ncreate table t6 ( id int, #主键约束 name varchar(20), salary float(6,2), PRIMARY KEY(id,name) #联合主键 ) auto_increment 自增字段:\n对于主键id而言，往往我们可以设置为自增字段，不用手动填写\ncreate table t7 ( id int PRIMARY KEY auto_increment, #主键约束 name varchar(20) ) foreign key\n思考：\n假设我们要描述所有公司的员工，需要描述的属性有这些 ： 姓名,年龄，性别，部门，部门描述\n公司有3个部门，但是有1个亿的员工，那意味着部门和部门描述这两个字段需要重复存储，部门名字和部门描述内容越长，越浪费内存，如何处理呢？\n解决方法： 我们完全可以定义一个部门表然后让员工信息表关联该表，如何关联，即foreign key\nforeign key(当前表中建立关系的外键字段) references 被关联表名(id) #创建两张表： #被关联表：dep： create table dep( id int primary key auto_increment, dep_name varchar(16), dep_desc varchar(255)); #关联表：emp:\tcreate table emp( id int primary key auto_increment, name varchar(6), age int, gender enum(\u0026#39;male\u0026#39;,\u0026#39;female\u0026#39;), dep_id int not null, foreign key(dep_id) references dep(id)); 级联删除，级联更新\n两张表建立关联之后，如果部门表某个部门的砍掉了，那对应的人员表中的那些部门的人员相应的该怎么处理呢？可以保存，也可以随之一起删除.\n如果要保证两表一致，则需要在设置外键时添加on delete cascade\n如果部门id更新了，要一起更新的话，则添加on update cascade\n#被关联表：dep： create table dep( id int primary key auto_increment, dep_name varchar(16), dep_desc varchar(255)); #关联表：emp:\tcreate table emp( id int primary key auto_increment, name varchar(6), age int, gender enum(\u0026#39;male\u0026#39;,\u0026#39;female\u0026#39;), dep_id int not null, foreign key(dep_id) references dep(id) on delete cascade on update cascade ) 修改表 修改表名\nalter table 旧表名 rename 新表名 修改表字段的数据类型\nalter table 表名 modify 字段 新数据类型 修改表字段名\nalter table 表名 change 旧字段名 新字段名 新数据类型 新增字段\nalter table 表名 add 新增字段名 数据类型 约束条件#约束条件可选 删除字段\nalter table 表名 drop 字段名 查看所有的表\nshow tables 删除表 drop table 表名 记录操作DML 插入数据 插入完整的数据\ninsert into 表名 (字段1，字段2) values (\u0026#39;字段1的值\u0026#39;,\u0026#39;字段2的值\u0026#39;) create table new_dep( id int PRIMARY KEY auto_increment, dep_name varchar(10), dep_desc varchar(100) ); #给指定字段插入数据 insert into new_dep (dep_name,dep_desc) values (\u0026#39;yanfabu\u0026#39;,\u0026#39;ssss\u0026#39;); insert into new_dep (dep_name,dep_desc) values (\u0026#39;销售部\u0026#39;,\u0026#39;ssss\u0026#39;); 插入多条数据\ninsert into 表名 values (\u0026#39;xx1\u0026#39;,\u0026#39;xx2\u0026#39;),(xx1,xx2) #插入几条数据就写几个括号 更新数据 单独更新一个字段\nupdate 表名 set 字段名 = 字段值 where 条件 更新多个字段\nupdate 表名 set 字段1 = 字段值1,字段2 = 字段值2 where 条件 删除数据 删除指定数据数据\ndelete from 表名 where 条件 删除表中所有数据\n#不加where条件就是清空表,一定要慎重使用delete # 如果有自增id，新增的数据，仍然是以删除前的最后一样作为起始。 delete from 表名 # 数据量大，删除速度比上一条快，且直接从零开始 truncate table t1; 查询数据 单表查询 准备数据\n#创建员工表，字段为： #id自增，员工名不能为空，性别只可以为male或者female且不能为空，默认值为male #age不能为空，默认值28，入职日期只显示年月日，职位名称，工资保留两位小数，办公室门牌号，部门id create table emp ( id int PRIMARY KEY auto_increment, name char(20) not null, gender enum(\u0026#39;male\u0026#39;,\u0026#39;female\u0026#39;) default \u0026#39;male\u0026#39;, age int not null default 28, hire_date date, job_title varchar(30), salary float(10,2), office_num int, dep_id int ) 数据 insert into emp (name,gender,age,hire_date,job_title,salary,office_num,dep_id)values (\u0026#39;weiwei\u0026#39;,\u0026#39;male\u0026#39;,78,\u0026#39;20150302\u0026#39;,\u0026#39;teacher\u0026#39;,1000000.31,401,1), (\u0026#39;lala\u0026#39;,\u0026#39;male\u0026#39;,81,\u0026#39;20130305\u0026#39;,\u0026#39;teacher\u0026#39;,8300,401,1), (\u0026#39;zhangsan\u0026#39;,\u0026#39;male\u0026#39;,73,\u0026#39;20140701\u0026#39;,\u0026#39;teacher\u0026#39;,3500,401,1), (\u0026#39;liulaogen\u0026#39;,\u0026#39;male\u0026#39;,28,\u0026#39;20121101\u0026#39;,\u0026#39;teacher\u0026#39;,2100,401,1), (\u0026#39;aal\u0026#39;,\u0026#39;female\u0026#39;,18,\u0026#39;20110211\u0026#39;,\u0026#39;teacher\u0026#39;,9000,401,1), (\u0026#39;zhugelang\u0026#39;,\u0026#39;male\u0026#39;,18,\u0026#39;19000301\u0026#39;,\u0026#39;teacher\u0026#39;,30000,401,1), (\u0026#39;成龙\u0026#39;,\u0026#39;male\u0026#39;,48,\u0026#39;20101111\u0026#39;,\u0026#39;teacher\u0026#39;,10000,401,1), (\u0026#39;歪歪\u0026#39;,\u0026#39;female\u0026#39;,48,\u0026#39;20150311\u0026#39;,\u0026#39;sale\u0026#39;,3000.13,402,2),#以下是销售部门 (\u0026#39;丫丫\u0026#39;,\u0026#39;female\u0026#39;,38,\u0026#39;20101101\u0026#39;,\u0026#39;sale\u0026#39;,2000.35,402,2), (\u0026#39;丁丁\u0026#39;,\u0026#39;female\u0026#39;,18,\u0026#39;20110312\u0026#39;,\u0026#39;sale\u0026#39;,1000.37,402,2), (\u0026#39;星星\u0026#39;,\u0026#39;female\u0026#39;,18,\u0026#39;20160513\u0026#39;,\u0026#39;sale\u0026#39;,3000.29,402,2), (\u0026#39;格格\u0026#39;,\u0026#39;female\u0026#39;,28,\u0026#39;20170127\u0026#39;,\u0026#39;sale\u0026#39;,4000.33,402,2), (\u0026#39;张野\u0026#39;,\u0026#39;male\u0026#39;,28,\u0026#39;20160311\u0026#39;,\u0026#39;operation\u0026#39;,10000.13,403,3), #以下是运营部门 (\u0026#39;程咬金\u0026#39;,\u0026#39;male\u0026#39;,18,\u0026#39;19970312\u0026#39;,\u0026#39;operation\u0026#39;,20000,403,3), (\u0026#39;程咬银\u0026#39;,\u0026#39;female\u0026#39;,18,\u0026#39;20130311\u0026#39;,\u0026#39;operation\u0026#39;,19000,403,3), (\u0026#39;程咬铜\u0026#39;,\u0026#39;male\u0026#39;,18,\u0026#39;20150411\u0026#39;,\u0026#39;operation\u0026#39;,18000,403,3), (\u0026#39;程咬铁\u0026#39;,\u0026#39;female\u0026#39;,18,\u0026#39;20140512\u0026#39;,\u0026#39;operation\u0026#39;,17000,403,3) 查询所有字段信息\nselect * from 表名; #星华表示的是通配符，表示所有的字段 查询指定字段信息\nselect 字段1，字段2 from 表名 select name,salary from emp #查看所有员工的姓名和薪资的信息 通过四则运算查询\n#查看员工的姓名和其年薪 select name,salary*12 from emp #as可以给列起一个别名，as关键字可以省略 select name,salary*12 as year_salary from emp 为库表重命名\nselect * from emp as e #e就是emp的别名 条件查询where语句\n单条件查询\n#查询销售员工的姓名和薪资 select name,salary from emp where job_title = \u0026#39;sale\u0026#39; 多条件查询1：结合and\n#查询薪资大于1w的老师对应的名字和薪资 select name,salary from emp where job_title = \u0026#39;teacher\u0026#39; and salary \u0026gt; 10000 多条件查询2：结合or\n#查询薪资为3，3.5，4，9k的员工名字和具体薪资 select name,salary from emp where salary = 3000 or salary = 3500 or salary = 4000 or salary = 9000 多条件查询3：结合between\u0026hellip;and\n#查询薪资范围在1000-5000之间的员工名字和具体信息 select name,salary from emp where salary between 1000 and 5000 多条件查询4:结合in\n#查询薪资为3，3.5，4，9k的员工名字和具体薪资 select name,salary from emp where salary in (3000,3500,4000,9000) 多条件查询5:结合not in\nselect name,salary from emp where salary not in (3000,3500,4000,9000) 模糊查询like\n通配符%:表示多个字符\nselect * from emp where name like \u0026#39;a%\u0026#39; 通配符_:表示一个字符\nselect * from emp where name like \u0026#39;zhang___\u0026#39; 分组查询：group by\n简单的分组查询\n注意：使用group by的查询字段必须是分组字段(或者是其他字段的聚合形式)，否则会出错，想要获取其他字段信息,可以借助于聚合函数 select job_title from emp group by job_title 分组聚合\n#查看每一个岗位的人数 #count()使用来做计数操作 select job_title, count(id)from emp group by job_title #计算男女员工的平均年龄 select gender,avg(age) from emp group by gender #计算不同岗位员工的平均薪资 select job_title,avg(salary) from emp group by job_title #查看男女员工的最大,最小年级和整体年龄 select gender,max(age),min(age),sum(age) from emp group by gender having子句\nwhere 与 having的区别：\nwhere 是针对分组之前的字段内容进行过滤,而having是针对分组后的 注意：having后面的条件字段只可以是分组后结果中存在的字段名，否则会报错！\n#查看销售岗位的平均薪资 select job_title,avg(salary) from emp GROUP BY job_title having job_title = \u0026#39;sale\u0026#39; 排序：order by\n升序： order by 字段 asc(默认升序,可以不写)\n降序： order by 字段 desc\n单列排序：\nselect * from emp order by salary 多列排序：越前面的列优先级越高\nselect * from emp order by salary desc limit\n显示前三条数据\nselect * from emp limit 3 从0开始,先查出第一条,然后包含这条再往后查5条\nselect * from emp limit 0,5 从第3开始,即先查出第4条,然后包含这条再往后查7条\nselect * from emp limit 3,7 使用正则：regexp\n# ^ 以什么开头 select id,name,job_title from emp where name regexp \u0026#34;^a\u0026#34;; # $ 以什么结尾 select id,name,job_title from emp where name regexp \u0026#34;san$\u0026#34;; # 匹配指定字符内容 select id,name,job_title from emp where name regexp \u0026#34;i{1}\u0026#34;; 多表查询 根据指定条件将两张表中的数据进行合并，然后在合并后的结果表中进行数据的查询\n准备数据\ncreate table dep( id int primary key, name char(20) ); create table emp( id int primary key auto_increment, name char(20), sex enum(\u0026#34;male\u0026#34;,\u0026#34;female\u0026#34;) not null default \u0026#34;male\u0026#34;, age int, dep_id int ); # 插入数据 insert into dep values (200,\u0026#39;技术\u0026#39;), (201,\u0026#39;人力资源\u0026#39;), (202,\u0026#39;销售\u0026#39;), (203,\u0026#39;运营\u0026#39;); insert into emp(name,sex,age,dep_id) values (\u0026#39;ailsa\u0026#39;,\u0026#39;male\u0026#39;,18,200), (\u0026#39;lala\u0026#39;,\u0026#39;female\u0026#39;,48,201), (\u0026#39;huahua\u0026#39;,\u0026#39;male\u0026#39;,38,201), (\u0026#39;zhangsan\u0026#39;,\u0026#39;female\u0026#39;,28,202), (\u0026#39;zhaosi\u0026#39;,\u0026#39;male\u0026#39;,18,200), (\u0026#39;shenteng\u0026#39;,\u0026#39;female\u0026#39;,18,204) ; 内连接:\n两张表公共的部分,必须同时有,没有就不显示 #语法；select * from 表1 inner join 表2 on 合并条件 select * from emp inner join dep on emp.dep_id = dep.id 外连接之左连接\n外连接之左连接 以左表为主表,根据左表数据匹配右表,左表数据是全的,而右表若匹配不上则为null select * from emp left join dep on emp.dep_id = dep.id 外连接之右连接\n以右表为主表,根据右表数据匹配左表,右表数据是全的,而左表若匹配不上则为null select * from emp right join dep on emp.dep_id = dep.id 符合条件的多表联查\n#示例1：以内连接的方式查询emp和dep表，并且emp表中的age字段值必须大于25,即找出年龄大于25岁的员工以及员工所在的部门 select * from emp inner join dep on emp.dep_id = dep.id where age \u0026gt; 25 #给表通过as起别名 select d.name,e.name from emp as e inner join dep as d on e.dep_id = d.id where age \u0026gt; 25 #示例2：以内连接的方式查询emp和dep表，并且emp表中的age字段值必须大于25，并且以age字段的升序方式显示 select * from emp as e inner join dep as d on d.id = e.dep_id where age \u0026gt; 25 order by age 子查询:子查询是将一个查询语句嵌套在另一个查询语句中\n带in关键字的子查询\n查询平均年龄在25岁以上的部门名 select name from dep where id in (200,201) #下述sql返回的就是201和202 select dep_id from emp group by dep_id having avg(age) \u0026gt; 25 #整合后的子查询语句 select name from dep where id in ( select dep_id from emp group by dep_id having avg(age) \u0026gt; 25 ) 查看技术部员工姓名 select name from emp where dep_id in (200) #获取部门编号200 select id from dep where name = \u0026#39;技术\u0026#39; #子查询 select name from emp where dep_id in ( select id from dep where name = \u0026#39;技术\u0026#39; ) 带比较运算符的子查询(比较运算符: =、!=、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、\u0026lt;\u0026gt;)\n查询大于所有人平均年龄的员工名字与年龄\nselect id,name from emp where age \u0026gt; xx #xx就是所有员工的平均年龄 #如何获取所有员工的平均年龄 select avg(age) from emp #整合后的子查询 select id,name from emp where age \u0026gt; (select avg(age) from emp) 综合练习 准备数据\nCREATE TABLE class ( cid int(11) NOT NULL AUTO_INCREMENT, caption varchar(32) NOT NULL, PRIMARY KEY (cid) ) INSERT INTO class VALUES (1, \u0026#39;三年二班\u0026#39;), (2, \u0026#39;三年三班\u0026#39;), (3, \u0026#39;一年二班\u0026#39;), (4, \u0026#39;二年九班\u0026#39;); CREATE TABLE teacher( tid int(11) NOT NULL AUTO_INCREMENT, tname varchar(32) NOT NULL, PRIMARY KEY (tid) ) INSERT INTO teacher VALUES (1, \u0026#39;张磊老师\u0026#39;), (2, \u0026#39;李平老师\u0026#39;), (3, \u0026#39;刘海燕老师\u0026#39;), (4, \u0026#39;朱云海老师\u0026#39;), (5, \u0026#39;李杰老师\u0026#39;); CREATE TABLE course( cid int(11) NOT NULL AUTO_INCREMENT, cname varchar(32) NOT NULL, teacher_id int(11) NOT NULL, PRIMARY KEY (cid), FOREIGN KEY (teacher_id) REFERENCES teacher (tid) ) INSERT INTO course VALUES (1, \u0026#39;生物\u0026#39;, 1), (2, \u0026#39;物理\u0026#39;, 2), (3, \u0026#39;体育\u0026#39;, 3), (4, \u0026#39;美术\u0026#39;, 2); CREATE TABLE student( sid int(11) NOT NULL AUTO_INCREMENT, gender char(1) NOT NULL, class_id int(11) NOT NULL, sname varchar(32) NOT NULL, PRIMARY KEY (sid), FOREIGN KEY (class_id) REFERENCES class (cid) ) INSERT INTO student VALUES (1, \u0026#39;男\u0026#39;, 1, \u0026#39;理解\u0026#39;), (2, \u0026#39;女\u0026#39;, 1, \u0026#39;钢蛋\u0026#39;), (3, \u0026#39;男\u0026#39;, 1, \u0026#39;张三\u0026#39;), (4, \u0026#39;男\u0026#39;, 1, \u0026#39;张一\u0026#39;), (5, \u0026#39;女\u0026#39;, 1, \u0026#39;张二\u0026#39;), (6, \u0026#39;男\u0026#39;, 1, \u0026#39;张四\u0026#39;), (7, \u0026#39;女\u0026#39;, 2, \u0026#39;铁锤\u0026#39;), (8, \u0026#39;男\u0026#39;, 2, \u0026#39;李三\u0026#39;), (9, \u0026#39;男\u0026#39;, 2, \u0026#39;李一\u0026#39;), (10, \u0026#39;女\u0026#39;, 2, \u0026#39;李二\u0026#39;), (11, \u0026#39;男\u0026#39;, 2, \u0026#39;李四\u0026#39;), (12, \u0026#39;女\u0026#39;, 3, \u0026#39;如花\u0026#39;), (13, \u0026#39;男\u0026#39;, 3, \u0026#39;刘三\u0026#39;), (14, \u0026#39;男\u0026#39;, 3, \u0026#39;刘一\u0026#39;), (15, \u0026#39;女\u0026#39;, 3, \u0026#39;刘二\u0026#39;), (16, \u0026#39;男\u0026#39;, 3, \u0026#39;刘四\u0026#39;); CREATE TABLE score ( sid int(11) NOT NULL AUTO_INCREMENT, student_id int(11) NOT NULL, course_id int(11) NOT NULL, num int(11) NOT NULL, PRIMARY KEY (sid), FOREIGN KEY (course_id) REFERENCES course (cid), FOREIGN KEY (student_id) REFERENCES student(sid) ) INSERT INTO score VALUES (1, 1, 1, 10), (2, 1, 2, 9), (5, 1, 4, 66), (6, 2, 1, 8), (8, 2, 3, 68), (9, 2, 4, 99), (10, 3, 1, 77), (11, 3, 2, 66), (12, 3, 3, 87), (13, 3, 4, 99), (14, 4, 1, 79), (15, 4, 2, 11), (16, 4, 3, 67), (17, 4, 4, 100), (18, 5, 1, 79), (19, 5, 2, 11), (20, 5, 3, 67), (21, 5, 4, 100), (22, 6, 1, 9), (23, 6, 2, 100), (24, 6, 3, 67), (25, 6, 4, 100), (26, 7, 1, 9), (27, 7, 2, 100), (28, 7, 3, 67), (29, 7, 4, 88), (30, 8, 1, 9), (31, 8, 2, 100), (32, 8, 3, 67), (33, 8, 4, 88), (34, 9, 1, 91), (35, 9, 2, 88), (36, 9, 3, 67), (37, 9, 4, 22), (38, 10, 1, 90), (39, 10, 2, 77), (40, 10, 3, 43), (41, 10, 4, 87), (42, 11, 1, 90), (43, 11, 2, 77), (44, 11, 3, 43), (45, 11, 4, 87), (46, 12, 1, 90), (47, 12, 2, 77), (48, 12, 3, 43), (49, 12, 4, 87), (52, 13, 3, 87); 题目\n1、查询所有的课程的名称以及对应的任课老师姓名 select c.cname,t.tname from course as c inner join teacher as t ON c.teacher_id = t.tid 2、查询学生表中男女生各有多少人 select gender,count(sid) from student GROUP BY gender 3、查询物理成绩等于100的学生的姓名 select t.sname,c.cname,s.num from student as t inner join score as s ON t.sid = s.student_id inner join course as c ON c.cid = s.course_id where c.cname = \u0026#39;物理\u0026#39; and s.num = 100 4、查询平均成绩大于八十分的同学的姓名和平均成绩 #查询平均成绩大于八十分的同学的姓名和平均成绩 #涉及到的字段：成绩，学生名字 #注意：分组条件为一张表的主键ID，则查询字段可以是该表中的任意字段 select t.sid,avg(num),t.sname from student as t inner join score as s on s.student_id = t.sid GROUP BY t.sid having avg(s.num) \u0026gt; 80 5、查询所有学生的学号，姓名，选课数，总成绩 select t.sname,count(course_id) as 科目数,sum(s.num) as 总成绩 from student as t inner join score as s on t.sid = s.student_id GROUP BY t.sid 6、 查询姓李老师的个数 select count(tid) from teacher where tname like \u0026#39;李%\u0026#39; 7、 查询没有报李平老师课的学生姓名 #查询没有报李平老师课的学生姓名 #select sname from student where sname not in (报李平老师学生的名字) #报李平老师学生的名字 #select t1.sname from student as t1 inner join score as s on t1.sid = s.student_id inner join course as c on c.cid = s.course_id inner join teacher as t ON t.tid = c.teacher_id where t.tname = \u0026#39;李平老师\u0026#39; #整合的完成操作 select sname from student where sname not in (select t1.sname from student as t1 inner join score as s on t1.sid = s.student_id inner join course as c on c.cid = s.course_id inner join teacher as t ON t.tid = c.teacher_id where t.tname = \u0026#39;李平老师\u0026#39;) 8、 查询物理课程比生物课程高的学生的学号 #1.求出每个学生的物理分数 select s.student_id,s.num from score as s inner join course as c on s.course_id = c.cid where c.cname = \u0026#39;物理\u0026#39; #2.求出每个学生的生物分数 select s.student_id,s.num from score as s inner join course as c on s.course_id = c.cid where c.cname = \u0026#39;生物\u0026#39; #假设t1就是上面物理对应的表，t2就是上面生物对应的表 select * from t1 inner join t2 on t1.student_id = t2.student_id where t1.num \u0026gt; t2.num #最终的整合 select t2.student_id from (select s.student_id,s.num from score as s inner join course as c on s.course_id = c.cid where c.cname = \u0026#39;物理\u0026#39;) as t1 inner join (select s.student_id,s.num from score as s inner join course as c on s.course_id = c.cid where c.cname = \u0026#39;生物\u0026#39;) as t2 on t1.student_id = t2.student_id where t1.num \u0026gt; t2.num 9、 查询没有同时选修物理课程和体育课程的学生姓名 #1.求出报物理或者报体育学生的记录信息（如果一个学生报物理也报体育了是满足下面条件） select * from student as t inner join score as s on t.sid = s.student_id inner join course as c on c.cid = s.course_id where c.cname = \u0026#39;物理\u0026#39; or c.cname = \u0026#39;体育\u0026#39; #限制只能要求学生报物理或者报体育其中的一门，不能同时报这两门 select t.sid,t.sname from student as t inner join score as s on t.sid = s.student_id inner join course as c on c.cid = s.course_id where c.cname = \u0026#39;物理\u0026#39; or c.cname = \u0026#39;体育\u0026#39; GROUP BY t.sid having count(c.cid) \u0026lt; 2 10、查询挂科超过两门(包括两门)的学生姓名和班级id select t.sname,t.class_id from student as t inner join score as s on t.sid = s.student_id where num \u0026lt; 60 GROUP BY t.sid having count(t.sid) \u0026gt;= 2 11、查询选修了所有课程的学生姓名 #查询选修了所有课程的学生姓名 select t.sname from student as t inner join score as s on t.sid = s.student_id GROUP BY t.sid having count(s.course_id) = 所有科目的数量 #查询所有科目的数量 select count(cid) from course #整合 select t.sname from student as t inner join score as s on t.sid = s.student_id GROUP BY t.sid having count(s.course_id) = (select count(cid) from course ) 12、查询李平老师教的课程的所有学生（id）的成绩记录 select t1.sid,num from student as t1 inner join score as s on t1.sid = s.student_id inner join course as c on c.cid = s.course_id inner join teacher t ON t.tid = c.teacher_id where t.tname = \u0026#39;李平老师\u0026#39; 13、查询全部学生都选修了的课程号和课程名 select c.cid,c.cname from score as s inner join course as c ON s.course_id = c.cid GROUP BY c.cid having count(course_id) = (select count(sid) from student) 14、查询每门课程被选修的次数 select c.cname,count(c.cid) from score as s inner join course as c ON s.course_id = c.cid GROUP BY c.cid 15、查询只选修了一门课程的学生姓名和学号 select t.sname,t.sid from student as t inner join score as s on t.sid = s.student_id GROUP BY student_id HAVING count(s.course_id) = 1 16、查询所有学生考出的成绩并按从高到低排序（成绩去重） #查询所有学生考出的成绩并按从高到低排序（成绩去重） #DISTINCT对某一个查询字段去重 select DISTINCT num from score ORDER BY num desc 17、查询平均成绩大于85的学生姓名和平均成绩 select t.sname,avg(num) from student as t inner join score as s on t.sid = s.student_id group by t.sid having avg(num) \u0026gt; 85 18、查询生物成绩不及格的学生姓名和对应生物分数 select t.sname,num from student as t inner join score as s on t.sid = s.student_id inner join course as c on c.cid = s.course_id where cname = \u0026#39;生物\u0026#39; and num \u0026lt; 60 19、查询在所有选修了李平老师课程的学生中，这些课程(李平老师的课程，不是所有课程)平均成绩最高的学生姓名 select t1.sname,avg(num) from student as t1 inner join score as s on t1.sid = s.student_id inner join course as c on c.cid = s.course_id inner join teacher as t on t.tid = c.teacher_id where t.tname = \u0026#39;李平老师\u0026#39; group by t1.sid order by avg(num) desc limit 1 答案\n1、查询所有的课程的名称以及对应的任课老师姓名 select c.cid,c.cname,t.tname from course c left join teacher t on c.teacher_id = t.tid ; 2、查询学生表中男女生各有多少人 select gender,count(gender) 人数 from student group by gender; 3、查询物理成绩等于100的学生的姓名 select sname,num from student s inner join score s1 on s.sid = s1.student_id left join course c on s1.course_id = c.cid where c.cname = \u0026#34;物理\u0026#34; and s1.num = 100; 4、查询平均成绩大于八十分的同学的姓名和平均成绩 select sname,avg(num) 平均成绩 from student s left join score s1 on s.sid = s1.student_id group by sname having avg(num)\u0026gt;=80; 5、查询所有学生的学号，姓名，选课数，总成绩 select student.sid,student.sname,sum(num) as 总成绩,count(course_id) as 课程数 from student inner join score on student.sid = score.student_id group by student.sid 6、 查询姓李老师的个数 select count(tid) 个数 from teacher where tname like \u0026#34;李%\u0026#34;; 7、 查询没有报李平老师课的学生姓名 select sname from student where sname not in (select sname from student s left join score s1 on s.sid = s1.student_id left join course c on s1.course_id = c.cid left join teacher t on t.tid = c.teacher_id where t.tname = \u0026#34;李平老师\u0026#34;); 8、 查询物理课程比生物课程高的学生的学号 返回每个学生的物理分数表和每个学生生物分数表，将其连接成一张表，然后进行条件查询 select t1.student_id from (select s.student_id,s.num from score as s inner join course as c on s.course_id = c.cid where c.cname = \u0026#39;物理\u0026#39;) as t1 inner join (select s.student_id,s.num from score as s inner join course as c on s.course_id = c.cid where c.cname = \u0026#39;生物\u0026#39;) as t2 on t1.student_id = t2.student_id where t1.num \u0026gt; t2.num 9、 查询没有同时选修物理课程和体育课程的学生姓名 # 第一种写法 select t.sname from student as t inner join score as s on t.sid = s.student_id inner join course as c on c.cid = s.course_id where c.cname = \u0026#39;物理\u0026#39; or c.cname = \u0026#39;体育\u0026#39; GROUP BY t.sid having count(c.cid) \u0026lt; 2 # 第二种写法:将选修物理或体育的学生根据学号分组，然后每组数据的行等于1的学生就是 select * from student where sid in( select student_id from score s left join course c on s.course_id = c.cid where cname = \u0026#34;物理\u0026#34; or cname = \u0026#34;体育\u0026#34; group by student_id having count(student_id) = 1 ); 10、查询挂科超过两门(包括两门)的学生姓名和挂科数量 select s.sname,count(s1.sid) 个数 from student s join score s1 on s.sid = s1.student_id where num \u0026lt; 60 group by sname having count(s1.sid)\u0026gt;=2; 11、查询选修了所有课程的学生姓名 select sname from student s join score s1 on s.sid = s1.student_id group by sname having count(student_id) = (select count(cid) from course); 12、查询李平老师教的课程的所有学生（id）的成绩记录 select s.student_id,c.cname,s.num from score s left join course c on s.course_id = c.cid left join teacher t on t.tid = c.teacher_id where t.tname = \u0026#34;李平老师\u0026#34;; 13、查询全部学生都选修了的课程号和课程名 select course_id,cname from score s left join course c on s.course_id = c.cid group by course_id HAVING count(course_id) = (select count(sid) from student); 14、查询每门课程被选修的次数(每门课有多少学生选择) select cname,count(c.cname) 次数 from score s left join course c on s.course_id = c.cid group by cname; 15、查询只选修了一门课程的学生姓名和学号 select student_id,sname from score s join student s1 on s.student_id = s1.sid group by student_id having count(s.course_id) = 1; 16、查询所有学生考出的成绩并按从高到低排序（成绩去重:在需要去重字段前面加distinct） select distinct num from score order by num desc; 17、查询平均成绩大于85的学生姓名和平均成绩 select sname,avg(num) 平均成绩 from score s join student s1 on s.student_id = s1.sid group by sname having avg(num)\u0026gt;85; 18、查询生物成绩不及格的学生姓名和对应生物分数 select sname,num from score s left join student s1 on s.student_id = s1.sid left join course c on s.course_id = c.cid where cname = \u0026#34;生物\u0026#34; and num \u0026lt; 60; 19、查询在所有选修了李平老师课程的学生中，这些课程(李平老师的课程，不是所有课程)平均成绩最高的学生姓名 select sname,avg(num) 平均成绩 from score s left join student s1 on s.student_id = s1.sid left join course c on s.course_id = c.cid left join teacher t on c.teacher_id = t.tid where tname = \u0026#34;李平老师\u0026#34; group by sname order by avg(num) desc limit 1; # 第二种方法 select sname,avg(num) 平均成绩 from score s left join student s1 on s.student_id = s1.sid left join course c on s.course_id = c.cid left join teacher t on c.teacher_id = t.tid where tname = \u0026#34;李平老师\u0026#34; group by sname having avg(num)= (select max(平均成绩) from (select sname,avg(num) 平均成绩 from score s left join student s1 on s.student_id = s1.sid left join course c on s.course_id = c.cid left join teacher t on c.teacher_id = t.tid where tname = \u0026#34;李平老师\u0026#34; group by sname) t); ","permalink":"https://canw0916.github.io/en/posts/tech/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"数据库概述 为什么要使用数据库？ 那我们在没有学习数据库的时候，数据存放在json或者磁盘文件中不也挺好的嘛，为啥还要学习数据库？ 文件中存储数据","title":"Mysql数据库"},{"content":"简介 selenium 是一种浏览器自动化的工具，所谓的自动化是指，我们可以通过代码的形式制定一系列的行为动作，然后执行代码，这些动作就会同步触发在浏览器中。 环境安装 下载安装selenium：pip install selenium 下载浏览器驱动程序： http://chromedriver.storage.googleapis.com/index.html 查看驱动和浏览器版本的映射关系： http://blog.csdn.net/huilan_same/article/details/51896672 效果展示 from selenium import webdriver from time import sleep # 后面是你的浏览器驱动位置，记得前面加r\u0026#39;\u0026#39;,\u0026#39;r\u0026#39;是防止字符转义的 driver = webdriver.Chrome(r\u0026#39;./chromedriver\u0026#39;) # 用get打开百度页面 driver.get(\u0026#34;http://www.baidu.com\u0026#34;) # 查找页面的“设置”选项，并进行点击 driver.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;s-usersetting-top\u0026#34;]\u0026#39;).click() sleep(2) # # 打开设置后找到“搜索设置”选项，设置为每页显示50条 driver.find_elements_by_link_text(\u0026#39;搜索设置\u0026#39;)[0].click() sleep(2) # 选中每页显示50条 m = driver.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;nr_3\u0026#34;]\u0026#39;).click() sleep(2) # 点击保存设置 driver.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;se-setting-7\u0026#34;]/a[2]\u0026#39;).click() sleep(2) # 处理弹出的警告页面 确定accept() 和 取消dismiss() driver.switch_to_alert().accept() sleep(2) # 找到百度的输入框，并输入 美女 driver.find_element_by_id(\u0026#39;kw\u0026#39;).send_keys(\u0026#39;美女\u0026#39;) sleep(2) # 点击搜索按钮 driver.find_element_by_id(\u0026#39;su\u0026#39;).click() sleep(2) # 在打开的页面中找到“Selenium - 开源中国社区”，并打开这个页面 driver.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;1\u0026#34;]/div/h3/a\u0026#39;).click() sleep(3) # 关闭浏览器 driver.quit() 浏览器创建 Selenium支持非常多的浏览器，如Chrome、Firefox、Edge等.另外，也支持无界面浏览器。\nfrom selenium import webdriver browser = webdriver.Chrome() browser = webdriver.Firefox() browser = webdriver.Edge() browser = webdriver.PhantomJS() browser = webdriver.Safari() 元素定位 webdriver 提供了一系列的元素定位方法，常用的有以下几种：\nfind_element_by_id() find_element_by_name() find_element_by_class_name() find_element_by_tag_name() find_element_by_link_text() find_element_by_xpath() find_element_by_css_selector() 节点交互 Selenium可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用send_keys()方法，清空文字时用clear()方法，点击按钮时用click()方法。 执行js 对于某些操作，Selenium API并没有提供。比如，下拉进度条，它可以直接模拟运行JavaScript，此时使用execute_script()方法即可实现。\nfrom selenium import webdriver from time import sleep #1.创建一个浏览器对象,executable_path指定当前浏览器的驱动程序 #注意：我当前是mac系统，驱动程序也是mac版本的，如果是window系统注意更换驱动 bro = webdriver.Chrome(executable_path=\u0026#39;./chromedriver\u0026#39;) #2.浏览器的请求发送 bro.get(\u0026#39;https://www.jd.com/\u0026#39;) #3.标签定位:调用find系列的函数进行标签定位 search_box = bro.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;key\u0026#34;]\u0026#39;) #4.节点交互 search_box.send_keys(\u0026#39;mac pro m1\u0026#39;)#向指定标签中录入内容 sleep(2) btn = bro.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;search\u0026#34;]/div/div[2]/button\u0026#39;) btn.click() #点击按钮 sleep(2) #js注入 bro.execute_script(\u0026#39;document.documentElement.scrollTo(0,2000)\u0026#39;) sleep(5) #关闭浏览器 bro.quit() 思考：在爬虫中为什么需要使用selenium？selenium和爬虫之间的关联是什么？\n便捷的爬取动态加载数据（可见即可得）\n#获取前5页的企业名称 from selenium import webdriver import time from lxml import etree bro = webdriver.Chrome(executable_path=\u0026#39;./chromedriver\u0026#39;) url = \u0026#39;http://scxk.nmpa.gov.cn:81/xk/\u0026#39; bro.get(url=url) time.sleep(1) #获取页面源码数据(page_source) page_text = bro.page_source #将前5页的页面源码数据存储到该列表中 all_page_text_list = [page_text] for i in range(4): #点击下一页 next_page_btn = bro.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;pageIto_next\u0026#34;]\u0026#39;) next_page_btn.click() time.sleep(1) all_page_text_list.append(bro.page_source) for page_text in all_page_text_list: #解析数据 tree = etree.HTML(page_text) li_list = tree.xpath(\u0026#39;//*[@id=\u0026#34;gzlist\u0026#34;]/li\u0026#39;) for li in li_list: title = li.xpath(\u0026#39;./dl/@title\u0026#39;)[0] print(title) time.sleep(2) bro.quit() 便捷实现模拟登录\n后面在说 获取页面源码数据 通过page_source属性可以获取网页的源代码，接着就可以使用解析库（如正则表达式、Beautiful Soup、pyquery等）来提取信息了。\n前进和后退 #模拟浏览器的前进后退 from selenium import webdriver import time browser = webdriver.Chrome(r\u0026#39;./chromedriver\u0026#39;) browser.get(\u0026#39;https://www.baidu.com\u0026#39;) browser.get(\u0026#39;https://www.taobao.com\u0026#39;) browser.back() time.sleep(2) browser.forward() time.sleep(2) browser.close() 获取动态加载数据 实现可见即可得 动作链 在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，我们就调用它的输入文字和清空文字方法；对于按钮，就调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是动作链。\nfrom selenium.webdriver import ActionChains from selenium import webdriver from time import sleep bro = webdriver.Chrome(executable_path=\u0026#39;./chromedriver\u0026#39;) bro.get(\u0026#39;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable\u0026#39;) sleep(1) #注意：如果定位的标签是存在于iframe表示的子页面中，则常规的标签定位报错 #处理：使用如下指定操作 bro.switch_to.frame(\u0026#39;iframeResult\u0026#39;) div_tag = bro.find_element_by_id(\u0026#39;draggable\u0026#39;) #实例化一个动作链对象且将该对象绑定到指定的浏览器中 action = ActionChains(bro) action.click_and_hold(div_tag) #对指定标签实现点击且长按操作 for i in range(5): action.move_by_offset(10,10).perform() #perform让动作链立即执行 sleep(0.5) sleep(3) bro.quit() 带验证码的模拟登录 登录bilibili\nhttps://passport.bilibili.com/login?from_spm_id=333.851.top_bar.login_window 识别验证码模块封装：\nimport base64 import json import requests # 一、图片文字类型(默认 3 数英混合)： # 1 : 纯数字 # 1001：纯数字2 # 2 : 纯英文 # 1002：纯英文2 # 3 : 数英混合 # 1003：数英混合2 # 4 : 闪动GIF # 7 : 无感学习(独家) # 11 : 计算题 # 1005: 快速计算题 # 16 : 汉字 # 32 : 通用文字识别(证件、单据) # 66: 问答题 # 49 :recaptcha图片识别 # 二、图片旋转角度类型： # 29 : 旋转类型 # # 三、图片坐标点选类型： # 19 : 1个坐标 # 20 : 3个坐标 # 21 : 3 ~ 5个坐标 # 22 : 5 ~ 8个坐标 # 27 : 1 ~ 4个坐标 # 48 : 轨迹类型 # # 四、缺口识别 # 18 : 缺口识别（需要2张图 一张目标图一张缺口图） # 33 : 单缺口识别（返回X轴坐标 只需要1张图） # 五、拼图识别 # 53：拼图识别 #函数实现忽略 def base64_api(uname, pwd, img, typeid): with open(img, \u0026#39;rb\u0026#39;) as f: base64_data = base64.b64encode(f.read()) b64 = base64_data.decode() data = {\u0026#34;username\u0026#34;: uname, \u0026#34;password\u0026#34;: pwd, \u0026#34;typeid\u0026#34;: typeid, \u0026#34;image\u0026#34;: b64} result = json.loads(requests.post(\u0026#34;http://api.ttshitu.com/predict\u0026#34;, json=data).text) if result[\u0026#39;success\u0026#39;]: return result[\u0026#34;data\u0026#34;][\u0026#34;result\u0026#34;] else: return result[\u0026#34;message\u0026#34;] return \u0026#34;\u0026#34; def getImgCodeText(imgPath,imgType):#直接返回验证码内容 #imgPath：验证码图片地址 #imgType：验证码图片类型 result = base64_api(uname=\u0026#39;图鉴的账号\u0026#39;, pwd=\u0026#39;图鉴的密码\u0026#39;, img=imgPath, typeid=imgType) return result from selenium import webdriver from selenium.webdriver import ActionChains from time import sleep import tujian #1.创建浏览器对象 bro = webdriver.Chrome(executable_path=\u0026#39;./chromedriver\u0026#39;) #2.发起请求 login_url = \u0026#39;https://passport.bilibili.com/login?from_spm_id=333.851.top_bar.login_window\u0026#39; bro.get(login_url) sleep(1) #3.定位到指定标签填充用户名和密码 user_box = bro.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;login-username\u0026#34;]\u0026#39;) user_box.send_keys(\u0026#39;15027900535\u0026#39;) sleep(1) pwd_box = bro.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;login-passwd\u0026#34;]\u0026#39;) pwd_box.send_keys(\u0026#39;1234567890\u0026#39;) sleep(1) login_btn = bro.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;geetest-wrap\u0026#34;]/div/div[5]/a[1]\u0026#39;) login_btn.click() sleep(1) #4.定位完整的验证码对话框 #注意：在开发者工具中是可以定位到多个div表示验证码对话框的，因此将这几个div都定位到，以此去尝试 code_tag = bro.find_element_by_xpath(\u0026#39;/html/body/div[2]/div[2]/div[6]/div/div\u0026#39;) sleep(1) #5.识别验证码（使用打码平台进行验证码识别） code_tag.screenshot(\u0026#39;./code.png\u0026#39;)#将验证码对话框截图保存 sleep(1) #使用图鉴接口识别 result = tujian.getImgCodeText(\u0026#39;./code.png\u0026#39;,27)#获取了识别的结果 # result = \u0026#39;154,251|145,167\u0026#39; # print(result) result_list = result.split(\u0026#39;|\u0026#39;) #result_list == [\u0026#39;154,251\u0026#39;,\u0026#39;145,167\u0026#39;] #6.根据识别出验证码的结果进行处理 for pos in result_list: x = int(pos.split(\u0026#39;,\u0026#39;)[0]) y = int(pos.split(\u0026#39;,\u0026#39;)[1]) ActionChains(bro).move_to_element_with_offset(code_tag,x,y).click().perform() sleep(0.5) confirm_btn = bro.find_element_by_xpath(\u0026#39;/html/body/div[2]/div[2]/div[6]/div/div/div[3]/a/div\u0026#39;) confirm_btn.click() sleep(3) bro.quit()1 Cookie 使用Selenium，还可以方便地对Cookies进行操作，例如常见的获取Cookies，示例如下：\nget_cookies()返回值是由字典组成的列表，叫做jsonCookies。 需要将jsonCookies解析成浏览器携带的cookie形式 #获取jsonCookies from selenium import webdriver import time browser = webdriver.Chrome(r\u0026#39;./chromedriver\u0026#39;) browser.get(\u0026#39;https://www.zhihu.com/explore\u0026#39;) print(browser.get_cookies()) browser.close() 解析jsonCookies成浏览器的cookie形式\nfrom selenium import webdriver import time browser = webdriver.Chrome(r\u0026#39;./chromedriver\u0026#39;) browser.get(\u0026#39;https://www.zhihu.com/explore\u0026#39;) #获取cookie cookies = browser.get_cookies() #解析cookie dic = {} for cookie in cookies: key = cookie[\u0026#39;name\u0026#39;] value = cookie[\u0026#39;value\u0026#39;] dic[key] = value print(dic) #在爬虫中可以使用的cookie browser.close() 基于selenium获取cookie后，绕过模拟登录\nfrom selenium.webdriver import Chrome import time import json web = Chrome(\u0026#39;./chromedriver\u0026#39;) web.get(\u0026#39;https://www.17k.com/\u0026#39;) time.sleep(3) # 登录 web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;header_login_user\u0026#34;]/a[1]\u0026#39;).click() # 切换iframe iframe = web.find_element_by_xpath(\u0026#39;/html/body/div[20]/div/div[1]/iframe\u0026#39;) web.switch_to.frame(iframe) web.find_element_by_xpath(\u0026#39;/html/body/form/dl/dd[2]/input\u0026#39;).send_keys(\u0026#34;15027900535\u0026#34;) web.find_element_by_xpath(\u0026#39;/html/body/form/dl/dd[3]/input\u0026#39;).send_keys(\u0026#34;bobo328410948\u0026#34;) web.find_element_by_xpath(\u0026#39;/html/body/form/dl/dd[5]/input\u0026#39;).click() time.sleep(3) cookies = web.get_cookies() # 存文件里 with open(\u0026#34;cookies.txt\u0026#34;, mode=\u0026#34;w\u0026#34;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(json.dumps(cookies)) # 组装cookie字典, 直接给requests用 dic = {} for cook in cookies: dic[cook[\u0026#39;name\u0026#39;]] = cook[\u0026#39;value\u0026#39;] # 衔接. 把cookie直接怼进去 import requests #访问的书架（获取书架内容） url = \u0026#34;https://user.17k.com/ck/author/shelf?page=1\u0026amp;appKey=2406394919\u0026#34; headers = { \u0026#39;cookie\u0026#39;:dic } resp = requests.get(url,cookies=dic) print(resp.text) web.close() 无头浏览器 无头浏览器就是没有可视化界面的浏览器\nfrom selenium import webdriver from selenium.webdriver.chrome.options import Options import time # 创建一个参数对象，用来控制chrome以无界面模式打开 chrome_options = Options() chrome_options.add_argument(\u0026#39;--headless\u0026#39;) chrome_options.add_argument(\u0026#39;--disable-gpu\u0026#39;) # 驱动路径 path = \u0026#39;./chromedriver\u0026#39; # 创建浏览器对象 browser = webdriver.Chrome(executable_path=path,options=chrome_options) # 上网 url = \u0026#39;http://www.baidu.com/\u0026#39; browser.get(url) time.sleep(3) browser.save_screenshot(\u0026#39;baidu.png\u0026#39;) browser.quit() 规避检测（重要） 现在不少大网站有对selenium采取了监测机制。比如正常情况下我们用浏览器访问淘宝等网站的 window.navigator.webdriver的值为 undefined或者为false。而使用selenium访问则该值为true。那么如何解决这个问题呢？\n实现js注入，绕过检测 from selenium.webdriver import ActionChains from selenium.webdriver import Chrome from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument(\u0026#34;--disable-blink-features=AutomationControlled\u0026#34;) chrome_options.add_argument(\u0026#39;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36\u0026#39;) driver = Chrome(\u0026#39;./chromedriver\u0026#39;,options=chrome_options) #Selenium在打开任何页面之前，先运行这个Js文件。 with open(\u0026#39;./stealth.min.js\u0026#39;) as f: js = f.read() #进行js注入，绕过检测 #execute_cdp_cmd执行cdp命令（在浏览器开发者工具中执行相关指令，完成相关操作） #Page.addScriptToEvaluateOnNewDocument执行脚本 driver.execute_cdp_cmd(\u0026#34;Page.addScriptToEvaluateOnNewDocument\u0026#34;, { \u0026#34;source\u0026#34;: js }) driver.get(\u0026#39;https://www.taobao.com\u0026#39;) 12306再次测试\n没有实现规避检测代码时的登录：\nfrom selenium.webdriver import Chrome from selenium.webdriver import ActionChains from time import sleep web = Chrome(executable_path=\u0026#39;./chromedriver\u0026#39;) web.get(\u0026#34;https://kyfw.12306.cn/otn/resources/login.html\u0026#34;) sleep(2) web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;toolbar_Div\u0026#34;]/div[2]/div[2]/ul/li[1]/a\u0026#39;).click() web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;J-userName\u0026#34;]\u0026#39;).send_keys(\u0026#34;hehehe@126.com\u0026#34;) sleep(1) web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;J-password\u0026#34;]\u0026#39;).send_keys(\u0026#34;111111\u0026#34;) sleep(1) web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;J-login\u0026#34;]\u0026#39;).click() sleep(3) action = ActionChains(web) # 找到滑块 btn = web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;nc_1_n1z\u0026#34;]\u0026#39;) action.click_and_hold(btn) for i in range(5): action.move_by_offset(50,0).perform() sleep(0.5) sleep(3) web.close() 实现规避检测后：\nfrom selenium.webdriver import Chrome from selenium.webdriver import ActionChains from time import sleep from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument(\u0026#34;--disable-blink-features=AutomationControlled\u0026#34;) chrome_options.add_argument(\u0026#39;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36\u0026#39;) web = Chrome(executable_path=\u0026#39;./chromedriver\u0026#39;,options=chrome_options) #Selenium在打开任何页面之前，先运行这个Js文件。 with open(\u0026#39;./stealth.min.js\u0026#39;) as f: js = f.read() #进行js注入，绕过检测 web.execute_cdp_cmd(\u0026#34;Page.addScriptToEvaluateOnNewDocument\u0026#34;, { \u0026#34;source\u0026#34;: js }) web.get(\u0026#34;https://kyfw.12306.cn/otn/resources/login.html\u0026#34;) sleep(2) web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;toolbar_Div\u0026#34;]/div[2]/div[2]/ul/li[1]/a\u0026#39;).click() web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;J-userName\u0026#34;]\u0026#39;).send_keys(\u0026#34;hehehe@126.com\u0026#34;) sleep(1) web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;J-password\u0026#34;]\u0026#39;).send_keys(\u0026#34;111111\u0026#34;) sleep(1) web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;J-login\u0026#34;]\u0026#39;).click() sleep(3) action = ActionChains(web) # 找到滑块 btn = web.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;nc_1_n1z\u0026#34;]\u0026#39;) action.click_and_hold(btn) for i in range(5): action.move_by_offset(50,0).perform() sleep(0.5) sleep(3) web.close() ","permalink":"https://canw0916.github.io/en/posts/tech/selenium/","summary":"简介 selenium 是一种浏览器自动化的工具，所谓的自动化是指，我们可以通过代码的形式制定一系列的行为动作，然后执行代码，这些动作就会同步触发在浏览器中。","title":"Selenium"},{"content":"M3U8流视频数据爬虫 HLS技术介绍 现在大部分视频客户端都采用HTTP Live Streaming，而不是直接播放MP4等视频文件（HLS，Apple为了提高流播效率开发的技术）。HLS技术的特点是将流媒体切分为若干【TS片段】（比如几秒一段），然后通过一个【M3U8列表文件】将这些TS片段批量下载供客户端播放器实现实时流式播放。因此，在爬取HLS的流媒体文件的思路一般是先【下载M3U8文件】并分析其中内容，然后在批量下载文件中定义的【TS片段】，最后将其【组合】成mp4文件或者直接保存TS片段。\n说说简单，其实在实际操作中，会遇到很多复杂的问题，例如m3u8文件下载不下来，ts片段文件被加密了，甚至加密ts片段的密钥也被加密了。\nHLS的作用 HLS技术目前在主流的应用产品中被应用的比较广。主要的原因在于，HLS技术比传统的流媒体技术的好处在于，视频一旦切分完成，之后的分发过程完全不需要额外使用任何专门软件，仅仅普通的Web服务器即可，这样就降低了对服务器的技术要求。\n另外，用TS做流媒体封装还有一个好处，就是不需要加载完整视频后播放，大大减少了首次载人的延迟，提升了用户体验。\n此外，HTTP Live Streaming的最大优势为自适应码率流播。客户端会根据网络状况自动选择不同码率的视频流，条件允许的情况下使用高码率，网络繁忙时使用低码率，并且自动在二者间随意切换。这对移动设备网络状况不稳定的情况下保障流畅播放非常有帮助。\nM3U8文件详解 如果想要爬取HLS技术下的资源数据，首先要对M3U8的数据结构和字段定义非常了解。M3U8是一个扩展文件格式，由M3U扩展而来。那么什么事M3U呢？\nM3U文件 M3U这种文件格式，本质上说不是音频视频文件，它是音频视频文件的列表文件，是纯文本文件。\nM3U这种文件被获取后，播放软件并不是播放它，而是根据它的记录找到媒体的网络地址进行在线播放。也就是说，M3U格式的文件只是存储多媒体播放列表，并提供了一个指向其他位置的音频视频文件的索引，播放的是那些被指向的文件。\n为了能够更好的理解M3U的概念，我们先简单做一个M3U文件（myTest.m3u）。在电脑中随便找几个MP3，MP4文件依次输入这些文件的路径，myTest.m3u文件内容如下\nE:\\Users\\m3u8\\刘德华 - 无间道.mp4 E:\\Users\\m3u8\\那英 - 默.mp3 E:\\Users\\m3u8\\周杰伦 - 不能说的秘密.mp4 E:\\Users\\m3u8\\花粥 - 二十岁的某一天.mp3 E:\\Users\\m3u8\\周深 - 大鱼.mp4 M3U8文件 M3U8也是一种M3U的扩展格式（高级的M3U，所以也属于M3U）。下面我们将了解一下M3U8中定义的几个非常重要的关键字：\n#EXTM3U:每个M3U文件第一行必须是这个tag标识。(简单了解) #EXT-X-VERSION:版本，此属性可用可不用。(简单了解) #EXT-X-TARGETDURATION:目标持续时间，是用来定义每个TS的【最大】duration（持续时间）。(简单了解) #EXT-X-ALLOW-CACHE是否允许允许高速缓存。(简单了解) #EXT-X-MEDIA-SEQUENCE定义当前M3U8文件中第一个文件的序列号，每个ts文件在M3U8文件中都有固定唯一的序列号。(简单了解) #EXT-X-DISCONTINUITY:播放器重新初始化(简单了解) #EXT-X-KEY定义加密方式，用来加密的密钥文件key的URL，加密方法（例如AES-128），以及IV加密向量。（记住） #EXTINF:指定每个媒体段(ts文件)的持续时间，这个仅对其后面的TS链接有效，每两个媒体段(ts文件)间被这个tag分隔开。(简单了解) #EXT-X-ENDLIST表明M3U8文件的结束。(简单了解) **M3U8示例：**大家会看到在该文件中有大量的ts文件的链接地址，这个就是我们之前描述的真正的视频文件。其中任何一个ts文件都是一小段视频，可以单独播放。我们做视频爬虫的目标就是把这些ts文件都爬取下来。\n#EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:19 #EXT-X-ALLOW-CACHE:YES #EXT-X-MEDIA-SEQUENCE:0 #EXT-X-KEY:METHOD=AES-128,URI=\u0026#34;https://edu.aliyun.com/hls/1109/clef/YnBGq7zAJf1Is7xIB5v8vI7AIORwwG9W\u0026#34;,IV=0x0fe82567a6be41afda68d82d3724976a #EXTINF:8.583, https://xuecdn2.aliyunedu.net/headLeader-0/20170519032524-ggauw1x00qo0okgk-conv/e_20170519032524-ggauw1x00qo0okgk-conv_hd_seg_0.ts #EXT-X-DISCONTINUITY #EXT-X-KEY:METHOD=AES-128,URI=\u0026#34;https://edu.aliyun.com/hls/2452/clef/0VqtrHq9IkTfOsLqy0iC1FP9342VZm1s\u0026#34;,IV=0xdebe4353e61b56e4ecfe0240ca3f89f5 #EXTINF:10.080, https://xuecdn2.aliyunedu.net/courselesson-50224/20170630095028-3xsfwyxw20cgwws8-conv/e_20170630095028-3xsfwyxw20cgwws8-conv_hd_seg_0.ts #EXT-X-KEY:METHOD=AES-128,URI=\u0026#34;https://edu.aliyun.com/hls/2452/clef/0VqtrHq9IkTfOsLqy0iC1FP9342VZm1s\u0026#34;,IV=0x8a3ce90cf18587963953b948487c1729 #EXT-X-KEY:METHOD=AES-128,URI=\u0026#34;https://edu.aliyun.com/hls/2452/clef/0VqtrHq9IkTfOsLqy0iC1FP9342VZm1s\u0026#34;,IV=0x3f1c20b9dd4459d0adf972eaba85e0a2 #EXTINF:10.000, https://xuecdn2.aliyunedu.net/courselesson-50224/20170630095028-3xsfwyxw20cgwws8-conv/e_20170630095028-3xsfwyxw20cgwws8-conv_hd_seg_104.ts #EXT-X-ENDLIST EXT-X-KEY中的密钥文件 对于大多数的M3U8视频，一般是不加密的。对于一些重要的视频服务商，他们会对其视频做加密处理。M3U8视频目前的标准加密方式是使用AES-128进行加密处理。如果视频是加密的，就会在M3U8文件中出现以下信息：\n#EXT-X-KEY:METHOD=AES-128,URI=\u0026#34;https://edu.aliyun.com/hls/2452/clef/0VqtrHq9IkTfOsLqy0iC1FP9342VZm1s\u0026#34;,IV=0x3f1c20b9dd4459d0adf972eaba85e0a2 其中METHOD为加密方法，标准是AES-128。\nKey是密钥文件的下载地址（密钥为16字节大小的文件，需要下载）。\nIV是加密向量（16个字节大小的16进制数），如果没有IV值则使用b\u0026quot;0000000000000000\u0026quot;填充即可。\n注意：Key和IV是AES加密解密的必要信息，这里我们就不用深入讲解。大家只需要知道Key和IV的值会作为解密函数的参数直接调用就可以了。如果文件中没有包含#EXT-X-KEY，则媒体文件将不会被加密。\n实战 需求 爬取美剧网视频：https://www.meijuw.com/vodplay/3985-1-1/\n具体操作 打开开发者工具，定位到Sources选项卡。在“Sources”选项卡（顶端）中，点击“XHR/fetch Breakpoints”的加号，在编辑框中输入“m3u8”，本操作的意思是：当网页中有任何URL中包含m3u8字段的网络访问就暂停执行。\n完成以上操作后重新刷新页面，此时Chrome开发者工具就会暂停在访问M3U8的代码位置。暂停后，我们可以点击左下方的{}图标提高暂停部分代码的可读性。\n然后点击”单步“执行按钮，单步执行js代码，执行几部后，会看到一级m3u8的文件地址使用requests进行请求发送，获取一级m3u8文件内容。\n完整代码\nimport requests from urllib.parse import urljoin import re import os # 需要安装. pip install pycryptodome from Crypto.Cipher import AES dirName = \u0026#39;tsLib\u0026#39; if not os.path.exists(dirName): os.mkdir(dirName) headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36\u0026#39; } #一级m3u8地址 m1_url = \u0026#34;https://vod11.bdzybf.com/20220127/5iTXjEev/index.m3u8\u0026#34; m1_page_text = requests.get(url=m1_url,headers=headers).text # print(m1_page_text) #从一级m3u8文件中解析出二级m3u8地址 m1_page_text = m1_page_text.strip()#取出收尾的回车 #二级m3u8地址 m2_url = \u0026#39;\u0026#39; for line in m1_page_text.split(\u0026#39;\\n\u0026#39;): if not line.startswith(\u0026#39;#\u0026#39;): m2_url = line #将m1_url和m2_url不同之处补充到m2_url中 m2_url = urljoin(m1_url,m2_url) #至此就获取到了完整的二级文件地址 #请求二级文件地址内容 m2_page_text = requests.get(url=m2_url,headers=headers).text m2_page_text = m2_page_text.strip() # print(m2_page_text) #解析出解密秘钥key的地址 key_url = re.findall(\u0026#39;URI=\u0026#34;(.*?)\u0026#34;\u0026#39;,m2_page_text,re.S)[0] key_url = urljoin(m1_url,key_url) # print(key_url) #请求key的地址，获取秘钥 #注意：key和iv需要为bytes类型 key = requests.get(url=key_url,headers=headers).content iv = b\u0026#34;0000000000000000\u0026#34; #解析出每一个ts切片的地址 ts_url_list = [] for line in m2_page_text.split(\u0026#39;\\n\u0026#39;): if not line.startswith(\u0026#39;#\u0026#39;): ts_url = line ts_url = urljoin(m1_url,ts_url) ts_url_list.append(ts_url) # print(ts_url_list) #请求到每一个ts切片的数据 for url in ts_url_list: #获取ts片段的数据 ts_data = requests.get(url=url,headers=headers).content #需要对ts片段数据进行解密（需要用到key和iv） aes = AES.new(key=key,mode=AES.MODE_CBC,iv=iv) desc_data = aes.decrypt(ts_data)#获取了解密后的数据 ts_name = url.split(\u0026#39;/\u0026#39;)[-1] ts_path = dirName+\u0026#39;/\u0026#39;+ts_name with open(ts_path,\u0026#39;wb\u0026#39;) as fp: #需要将解密后的数据写入文件进行保存 fp.write(desc_data) print(ts_name,\u0026#39;下载保存成功！\u0026#39;) #ts文件的合并，最好网上找专业的工具进行合并，自己手动合并会经常出问题 协程异步下载\nimport requests from urllib.parse import urljoin import re import os # 需要安装. pip install pycryptodome from Crypto.Cipher import AES import asyncio import aiohttp dirName = \u0026#39;tsLib\u0026#39; if not os.path.exists(dirName): os.mkdir(dirName) headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36\u0026#39; } #一级m3u8地址 m1_url = \u0026#34;https://vod11.bdzybf.com/20220127/5iTXjEev/index.m3u8\u0026#34; m1_page_text = requests.get(url=m1_url,headers=headers).text # print(m1_page_text) #从一级m3u8文件中解析出二级m3u8地址 m1_page_text = m1_page_text.strip()#取出收尾的回车 #二级m3u8地址 m2_url = \u0026#39;\u0026#39; for line in m1_page_text.split(\u0026#39;\\n\u0026#39;): if not line.startswith(\u0026#39;#\u0026#39;): m2_url = line #将m1_url和m2_url不同之处补充到m2_url中 m2_url = urljoin(m1_url,m2_url) #至此就获取到了完整的二级文件地址 #请求二级文件地址内容 m2_page_text = requests.get(url=m2_url,headers=headers).text m2_page_text = m2_page_text.strip() # print(m2_page_text) #解析出解密秘钥key的地址 key_url = re.findall(\u0026#39;URI=\u0026#34;(.*?)\u0026#34;\u0026#39;,m2_page_text,re.S)[0] key_url = urljoin(m1_url,key_url) # print(key_url) #请求key的地址，获取秘钥 #注意：key和iv需要为bytes类型 key = requests.get(url=key_url,headers=headers).content iv = b\u0026#34;0000000000000000\u0026#34; #解析出每一个ts切片的地址 ts_url_list = [] for line in m2_page_text.split(\u0026#39;\\n\u0026#39;): if not line.startswith(\u0026#39;#\u0026#39;): ts_url = line ts_url = urljoin(m1_url,ts_url) ts_url_list.append(ts_url) # print(ts_url_list) #异步请求到每一个ts切片的数据 async def get_ts(url): async with aiohttp.ClientSession() as sess: async with await sess.get(url=url,headers=headers) as response: ts_data = await response.read() #获取byte形式的响应数据 # 需要对ts片段数据进行解密（需要用到key和iv） aes = AES.new(key=key, mode=AES.MODE_CBC, iv=iv) desc_data = aes.decrypt(ts_data) # 获取了解密后的数据 return [desc_data,url] def download(t): r_list = t.result() data = r_list[0] url = r_list[1] #ts文件的地址 ts_name = url.split(\u0026#39;/\u0026#39;)[-1] ts_path = dirName + \u0026#39;/\u0026#39; + ts_name with open(ts_path, \u0026#39;wb\u0026#39;) as fp: # 需要将解密后的数据写入文件进行保存 fp.write(data) print(ts_name, \u0026#39;下载保存成功！\u0026#39;) tasks = [] for url in ts_url_list: c = get_ts(url) task = asyncio.ensure_future(c) task.add_done_callback(download) tasks.append(task) loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) ","permalink":"https://canw0916.github.io/en/posts/tech/m3u8%E6%B5%81%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB/","summary":"M3U8流视频数据爬虫 HLS技术介绍 现在大部分视频客户端都采用HTTP Live Streaming，而不是直接播放MP4等视频文件（HLS，Appl","title":"M3U8流视频数据爬虫"},{"content":"高性能异步爬虫 引入 很多同学对于异步这个概念只是停留在了“听说很NB”的认知层面上，很少有人能够在项目中真正的使用异步实现高性能的相关操作。接下来，咱们就一起来学习一下，爬虫中如何使用异步实现高性能的数据爬取操作。\n背景 其实爬虫的本质就是client发请求批量获取server的响应数据，如果我们有多个url待爬取，只用一个线程且采用串行的方式执行，那只能等待爬取一个结束后才能继续下一个，效率会非常低。\n所以单线程下串行多个爬虫任务是比较低效的，是因为爬虫任务是明显的IO密集型（阻塞）程序。那么该如何提高爬取性能呢？查看下述的分析测试！\n分析处理 实验环境创建：\n由于网络请求会受到个人电脑或者服务器响应时长不同等因素，我们可以自己创建一个专门用于测试的实验环境，搭建一个flask服务器，爬取本机自己服务器中的数据，避免其他因素的干扰，以便非常明显的观测出异步的效果。\n#安装flask模块:pip install flask from flask import Flask,render_template from time import sleep #1.实例化app对象 app = Flask(__name__) #装饰器中的参数就是路由地址 @app.route(\u0026#39;/main\u0026#39;) def main():#视图函数 sleep(2) return \u0026#39;i am main\u0026#39; #一旦启动了服务器后，在浏览器中访问路由地址，在服务器端就会执行视图函数 @app.route(\u0026#39;/bobo\u0026#39;) def index1(): sleep(2) return render_template(\u0026#39;test.html\u0026#39;) @app.route(\u0026#39;/jay\u0026#39;) def index2(): sleep(2) return render_template(\u0026#39;test.html\u0026#39;) @app.route(\u0026#39;/tom\u0026#39;) def index3(): sleep(2) return render_template(\u0026#39;test.html\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: app.run() 同步调用：即提交一个任务后就在原地等待任务结束，等到拿到任务的结果后再继续下一行代码，效率低下\nimport requests import time start = time.time()#程序执行开始的时间 urls = [\u0026#39;http://127.0.0.1:5000/bobo\u0026#39;, \u0026#39;http://127.0.0.1:5000/tom\u0026#39;, \u0026#39;http://127.0.0.1:5000/jay\u0026#39;] def get_request(url): page_text = requests.get(url=url).text print(len(page_text)) for url in urls: #发起了三次请求 get_request(url) print(\u0026#39;总耗时：\u0026#39;,time.time()-start) #程序运行的总耗时 上述性能问题如何解决呢？ 查看如下方式! a. 解决同步调用方案之多线程/多进程\n好处：使用多线程（或多进程）。多线程（或多进程）的目的是让每个爬取任务都拥有独立的线程（或进程），这样任何一个爬取任务的阻塞都不会影响其他的爬取任务。\n弊端：开启多进程或都线程的方式，我们是无法无限制地开启多进程或多线程的：在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率。\n测试代码：\nimport requests import time from threading import Thread #线程模块 start = time.time()#程序执行开始的时间 urls = [\u0026#39;http://127.0.0.1:5000/bobo\u0026#39;, \u0026#39;http://127.0.0.1:5000/tom\u0026#39;, \u0026#39;http://127.0.0.1:5000/jay\u0026#39;] def get_request(url): page_text = requests.get(url=url).text print(len(page_text)) ts = [] for url in urls: t = Thread(target=get_request,args=(url,)) ts.append(t) t.start() for t in ts:#让主线程等在所有的子线程结束后再结束 t.join() print(\u0026#39;总耗时：\u0026#39;,time.time()-start) #程序运行的总耗时 b. 解决同步调用方案之线程/进程池\n好处：很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。可以很好的降低系统开销。\n弊端：“线程池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。\n通常使用multiprocessing.dummy线程池的方案。\nimport requests import time from multiprocessing.dummy import Pool #线程池模块 start = time.time()#程序执行开始的时间 urls = [\u0026#39;http://127.0.0.1:5000/bobo\u0026#39;, \u0026#39;http://127.0.0.1:5000/tom\u0026#39;, \u0026#39;http://127.0.0.1:5000/jay\u0026#39;] def get_request(url): page_text = requests.get(url=url).text print(len(page_text)) pool = Pool(3) pool.map(get_request,urls) print(\u0026#39;总耗时：\u0026#39;,time.time()-start) #程序运行的总耗时 总结：\n对应需求中可能出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈。 终极处理方案 上述无论哪种解决方案其实没有解决一个性能相关的问题：\nIO阻塞，无论是多进程还是多线程，在遇到IO阻塞时都会被操作系统强行剥夺走CPU的执行权限(使得cup执行其他操作，其他操作可能是我们程序的其他部分，也可能是其他的应用程序)，我们自己程序的执行效率因此就降低了下来。 解决这一问题的关键在于：\n我们自己从自己的应用程序级别检测到IO阻塞，然后使得cpu切换到我们自己程序的其他部分/任务执行（这里的任务指的是当前我们自己程序表示的进程或线程中的某一组操作/子程序），这样可以把我们程序的IO阻塞降到最低，我们的程序处于就绪态就会增多，以此来迷惑操作系统，操作系统便以为我们的程序是IO阻塞比较少的程序，从而会尽可能多的分配CPU给我们，这样也就达到了提升程序执行效率的目的。 通俗理解： 一个线程/进程可以表示一组指定行为的操作，这个操作可以由多个执行步骤组成，这些执行步骤有的是阻塞操作有的非阻塞操作，那么，当cpu执行当前进程/线程的时候遇到了阻塞的执行步骤的时候，如果不对其处理，则包含当前执行步骤的进程/线程就会被挂起进入到阻塞状态，且交出cpu的使用权（cpu就被别人抢走了）。那么如果遇到阻塞的执行步骤，我们的程序可以检测出它是阻塞的，且可以将cpu切换到我们自己程序其他非阻塞的执行步骤时，则包含这些执行步骤的进程/线程就不会进入到阻塞状态，从而减少进程/线程的阻塞状态，增加就绪状态（牢牢抢占cup）极大幅度提升程序执行的效率。 因此，有了协程后，在单进程或者单线程的模式下，就可以大幅度提升程序的运行效率了！ 在python3.5之后新增了asyncio模块，可以帮我们检测IO（只能是网络IO【HTTP连接就是网络IO操作】），实现应用程序级别的切换（异步IO）。\n接下来让我们来了解下协程的实现，从 Python 3.4 开始，Python 中加入了协程的概念，但这个版本的协程还是以生成器对象为基础的，在 Python 3.5 则增加了 asyncio，使得协程的实现更加方便。首先我们需要了解下面几个概念：\n特殊函数：\n在函数定义前添加一个async关键字，则该函数就变为了一个特殊的函数！ 特殊函数的特殊之处是什么？ 1.特殊函数被调用后，函数内部的程序语句（函数体）没有被立即执行 2.特殊函数被调用后，会返回一个协程对象 协程：\n协程对象，特殊函数调用后就可以返回/创建了一个协程对象。 协程对象 == 特殊的函数 == 一组指定形式的操作 协程对象 == 一组指定形式的操作 任务：\n任务对象就是一个高级的协程对象。高级之处，后面讲，不着急！ 任务对象 == 协程对象 == 一组指定形式的操作 任务对象 == 一组指定形式的操作 事件循环：\n事件循环对象（Event Loop）,可以将其当做是一个容器，该容器是用来装载任务对象的。所以说，让创建好了一个或多个任务对象后，下一步就需要将任务对象全部装载在事件循环对象中。 思考：为什么需要将任务对象装载在事件循环对象？ 当将任务对象装载在事件循环中后，启动事件循环对象，则其内部装载的任务对象对应的相关操作就会被立即执行。 import asyncio import time #特殊的函数 async def get_request(url): print(\u0026#39;正在请求的网址是:\u0026#39;,url) time.sleep(2) print(\u0026#39;请求网址结束！\u0026#39;) return 123 #创建了一个协程对象 c = get_request(\u0026#39;www.1.com\u0026#39;) #创建任务对象 task = asyncio.ensure_future(c) #创建事件循环对象 loop = asyncio.get_event_loop() #将任务对象装载在loop对象中且启动事件循环对象 loop.run_until_complete(task) 任务对象对比协程对象的高级之处重点在于：\n可以给任务对象绑定一个回调函数！\n回调函数有什么作用？\n回调函数就是回头调用的函数，因此要这么理解，当任务对象被执行结束后，会立即调用给任务对象绑定的这个回调函数！ import asyncio import time #特殊的函数 async def get_request(url): print(\u0026#39;正在请求的网址是:\u0026#39;,url) time.sleep(2) print(\u0026#39;请求网址结束！\u0026#39;) return 123 #回调函数的封装:必须有一个参数 def t_callback(t): #参数t就是任务对象 # print(\u0026#39;回调函数的参数t是：\u0026#39;,t) # print(\u0026#39;我是任务对象的回调函数！\u0026#39;) data = t.result()#result()函数就可以返回特殊函数内部的返回值 print(\u0026#39;我是任务对象的回调函数！,获取到特殊函数的返回值为:\u0026#39;,data) #创建协程对象 c = get_request(\u0026#39;www.1.com\u0026#39;) #创建任务对象 task = asyncio.ensure_future(c) #给任务对象绑定回调函数:add_done_callback的参数就是回调函数的名字 task.add_done_callback(t_callback) #创建事件循环对象 loop = asyncio.get_event_loop() loop.run_until_complete(task) 多任务的协程\nimport asyncio import time start = time.time() urls = [ \u0026#39;www.1.com\u0026#39;,\u0026#39;www.2.com\u0026#39;,\u0026#39;www.3.com\u0026#39; ] async def get_request(url): print(\u0026#39;正在请求：\u0026#39;,url) time.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) #有了三个任务对象和一个事件循环对象 if __name__ == \u0026#39;__main__\u0026#39;: tasks = [] for url in urls: c = get_request(url) task = asyncio.ensure_future(c) tasks.append(task) #将三个任务对象，添加到一个事件循环对象中 loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) print(\u0026#39;总耗时:\u0026#39;,time.time()-start) 出现两个问题： 1.没有实现异步效果 2.wait()是什么意思？ wait()函数：\n给任务列表中的每一个任务对象赋予一个可被挂起的权限！当cpu执行的任务对象遇到阻塞操作的时候，当前任务对象就会被挂起，则cup就可以执行其他任务对象，提高整体程序运行的效率！ 挂起任务对象：让当前正在被执行的任务对象交出cpu的使用权，cup就可以被其他任务对象抢占和使用，从而可以执行其他任务对象。 注意：特殊函数内部，不可以出现不支持异步模块的代码，否则会中断整个异步效果！ await关键字：挂起发生阻塞操作的任务对象。在任务对象表示的操作中，凡是阻塞操作的前面都必须加上await关键字进行修饰！\n完整的实现了，多任务的异步协程操作\nimport asyncio import time start = time.time() urls = [ \u0026#39;www.1.com\u0026#39;,\u0026#39;www.2.com\u0026#39;,\u0026#39;www.3.com\u0026#39; ] async def get_request(url): print(\u0026#39;正在请求：\u0026#39;,url) # time.sleep(2) #time模块不支持异步 await asyncio.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) #有了三个任务对象和一个事件循环对象 if __name__ == \u0026#39;__main__\u0026#39;: tasks = [] for url in urls: c = get_request(url) task = asyncio.ensure_future(c) tasks.append(task) #将三个任务对象，添加到一个事件循环对象中 loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) print(\u0026#39;总耗时:\u0026#39;,time.time()-start) 真正的将多任务的异步协程作用在爬虫中\n需求：爬取自己服务器中的页面数据，并将其进行数据解析操作\naiohttp:是一个基于网络请求的模块，功能和requests相似，但是，requests是不支持异步的，而aiohttp是支持异步的模块。\n环境安装：pip install aiohttp\n具体用法：\n1.先写大致加购\nwith aiohttp.ClientSession() as sess: #基于请求对象发起请求 #此处的get是发起get请求，常用参数：url,headers,params,proxy #post方法发起post请求，常用参数：url,headers,data,proxy #发现处理代理的参数和requests不一样（注意），此处处理代理使用proxy=\u0026#39;http://ip:port\u0026#39; with sess.get(url=url) as response: page_text = response.text() #text():获取字符串形式的响应数据 #read()：获取二进制形式的响应数据 return page_text 2.在第一步的基础上补充细节\n在每一个with前加上async关键字\n在阻塞操作前加上await关键字\n完整代码：\nasync def get_request(url): #requests是不支持异步的模块 # response = await requests.get(url=url) # page_text = response.text #创建请求对象（sess） async with aiohttp.ClientSession() as sess: #基于请求对象发起请求 #此处的get是发起get请求，常用参数：url,headers,params,proxy #post方法发起post请求，常用参数：url,headers,data,proxy #发现处理代理的参数和requests不一样（注意），此处处理代理使用proxy=\u0026#39;http://ip:port\u0026#39; async with await sess.get(url=url) as response: page_text = await response.text() #text():获取字符串形式的响应数据 #read()：获取二进制形式的响应数据 return page_text 多任务异步爬虫的完整代码实现：\nimport requests import asyncio import time from lxml import etree import aiohttp start = time.time() urls = [ \u0026#39;http://127.0.0.1:5000/bobo\u0026#39;, \u0026#39;http://127.0.0.1:5000/jay\u0026#39;, \u0026#39;http://127.0.0.1:5000/tom\u0026#39; ] #该任务是用来对指定url发起请求，获取响应数据 async def get_request(url): #requests是不支持异步的模块 # response = await requests.get(url=url) # page_text = response.text #创建请求对象（sess） async with aiohttp.ClientSession() as sess: #基于请求对象发起请求 #此处的get是发起get请求，常用参数：url,headers,params,proxy #post方法发起post请求，常用参数：url,headers,data,proxy #发现处理代理的参数和requests不一样（注意），此处处理代理使用proxy=\u0026#39;http://ip:port\u0026#39; async with await sess.get(url=url) as response: page_text = await response.text() #text():获取字符串形式的响应数据 #read()：获取二进制形式的响应数据 return page_text def parse(t):#回调函数专门用于数据解析 #获取任务对象请求到的页面源码数据 page_text = t.result() tree = etree.HTML(page_text) a = tree.xpath(\u0026#39;//a[@id=\u0026#34;feng\u0026#34;]/@href\u0026#39;)[0] print(a) tasks = [] for url in urls: c = get_request(url) task = asyncio.ensure_future(c) task.add_done_callback(parse) tasks.append(task) loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) print(\u0026#39;总耗时:\u0026#39;,time.time()-start) 使用uvloop加速(了解)\n环境安装：pip install uvloop uvloop基于libuv，libuv是一个使用C语言实现的高性能异步I/O库，uvloop用来代替asyncio默认事件循环，可以进一步加快异步I/O操作的速度。 uvloop的使用非常简单，只要在run_until_complete前，调用如下方法，将asyncio的事件循环策略设置为uvloop的事件循环策略。 asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) import uvloop loop = asyncio.get_event_loop() asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) loop.run_until_complete(asyncio.wait(tasks)) ","permalink":"https://canw0916.github.io/en/posts/tech/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/","summary":"高性能异步爬虫 引入 很多同学对于异步这个概念只是停留在了“听说很NB”的认知层面上，很少有人能够在项目中真正的使用异步实现高性能的相关操作。接","title":"异步爬虫"},{"content":" 简历模板下载拓展\nimport requests from lxml import etree import os headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36\u0026#39;, } #创建一个新的文件夹 dirName = \u0026#39;jianli\u0026#39; if not os.path.exists(dirName): os.mkdir(dirName) #通用的url模板 url = \u0026#39;https://sc.chinaz.com/jianli/free_%d.html\u0026#39; for page in range(1,11): if page == 1: new_url = \u0026#39;https://sc.chinaz.com/jianli/free.html\u0026#39; else: new_url = format(url%page) response = requests.get(url=new_url,headers=headers) response.encoding = \u0026#39;utf-8\u0026#39; page_text = response.text #数据解析：详情页url和简历名称 tree = etree.HTML(page_text) div_list = tree.xpath(\u0026#39;//*[@id=\u0026#34;container\u0026#34;]/div\u0026#39;) #局部解析 for div in div_list: detail_url = \u0026#39;https:\u0026#39;+div.xpath(\u0026#39;./a/@href\u0026#39;)[0] title = div.xpath(\u0026#39;./p/a/text()\u0026#39;)[0]+\u0026#39;.rar\u0026#39; # print(title,detail_url) #对详情页的url发起请求，解析出简历的下载地址 detail_page_text = requests.get(url=detail_url,headers=headers).text #数据解析：解析下载地址 detail_tree = etree.HTML(detail_page_text) li_list = detail_tree.xpath(\u0026#39;//*[@id=\u0026#34;down\u0026#34;]/div[2]/ul/li\u0026#39;) down_list = [] #存储不同的12个下载地址 for li in li_list: download_link = li.xpath(\u0026#39;./a/@href\u0026#39;)[0] down_list.append(download_link) #随机选择一个下载地址进行简历模板的下载 import random #从列表中随机选出一个下载地址 link = random.choice(down_list) #对下载地址进行请求发送，下载简历模板的压缩包 data = requests.get(url=link,headers=headers).content filePath = dirName+\u0026#39;/\u0026#39;+title with open(filePath,\u0026#39;wb\u0026#39;) as fp: fp.write(data) print(title,\u0026#39;下载保存成功！\u0026#39;) Cookie 什么是cookie？\ncookie的本质就是一组数据（键值对的形式存在） 是由服务器创建，返回给客户端，最终会保存在客户端浏览器中。 如果客户端保存了cookie，则下次再次访问该服务器，就会携带cookie进行网络访问。 典型的案例：网站的免密登录 爬取雪球网中的咨询数据\nurl：https://xueqiu.com/，需求就是爬取热帖内容\n经过分析发现帖子的内容是通过ajax动态加载出来的，因此通过抓包工具，定位到ajax请求的数据包，从数据包中提取：\nurl：https://xueqiu.com/statuses/hot/listV2.json?since_id=-1\u0026amp;max_id=311519\u0026amp;size=15 请求方式：get 请求参数：拼接在了url后面 import requests import os headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36\u0026#39;, } url = \u0026#39;https://xueqiu.com/statuses/hot/listV2.json\u0026#39; param = { \u0026#34;since_id\u0026#34;: \u0026#34;-1\u0026#34;, \u0026#34;max_id\u0026#34;: \u0026#34;311519\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;15\u0026#34;, } response = requests.get(url=url,headers=headers,params=param) data = response.json() print(data) #发现没有拿到我们想要的数据 分析why？\n切记：只要爬虫拿不到你想要的数据，唯一的原因是爬虫程序模拟浏览器的力度不够！一般来讲，模拟的力度重点放置在请求头中！ 上述案例，只需要在请求头headers中添加cookie即可！ 爬虫中cookie的处理方式（两种方式）：\n手动处理：将抓包工具中的cookie赋值到headers中即可\n缺点： 编写麻烦 cookie通常都会存在有效时长 cookie中可能会存在实时变化的局部数据 自动处理\n基于session对象实现自动处理cookie。\n1.创建一个空白的session对象。 2.需要使用session对象发起请求，请求的目的是为了捕获cookie 注意：如果session对象在发请求的过程中，服务器端产生了cookie，则cookie会自动存储在session对象中。 3.使用携带cookie的session对象，对目的网址发起请求，就可以实现携带cookie的请求发送，从而获取想要的数据。 注意：session对象至少需要发起两次请求\n第一次请求的目的是为了捕获存储cookie到session对象 后次的请求，就是携带cookie发起的请求了 import requests #1.创建一个空白的session对象 session = requests.Session() headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36\u0026#39;, } main_url = \u0026#39;https://xueqiu.com/\u0026#39; #2.使用session发起的请求，目的是为了捕获到cookie，且将其存储到session对象中 session.get(url=main_url,headers=headers) url = \u0026#39;https://xueqiu.com/statuses/hot/listV2.json\u0026#39; param = { \u0026#34;since_id\u0026#34;: \u0026#34;-1\u0026#34;, \u0026#34;max_id\u0026#34;: \u0026#34;311519\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;15\u0026#34;, } #3.就是使用携带了cookie的session对象发起的请求（就是携带者cookie发起的请求） response = session.get(url=url,headers=headers,params=param) data = response.json() print(data) 代理 什么是代理 代理服务器 代理服务器的作用 就是用来转发请求和响应 在爬虫中为何需要使用代理？\n有些时候，需要对网站服务器发起高频的请求，网站的服务器会检测到这样的异常现象，则会讲请求对应机器的ip地址加入黑名单，则该ip再次发起的请求，网站服务器就不在受理，则我们就无法再次爬取该网站的数据。 使用代理后，网站服务器接收到的请求，最终是由代理服务器发起，网站服务器通过请求获取的ip就是代理服务器的ip，并不是我们客户端本身的ip。 代理的匿名度\n透明：网站的服务器知道你使用了代理，也知道你的真实ip 匿名：网站服务器知道你使用了代理，但是无法获知你真实的ip 高匿：网站服务器不知道你使用了代理，也不知道你的真实ip（推荐） 代理的类型（重要）\nhttp：该类型的代理服务器只可以转发http协议的请求 https：可以转发https协议的请求 如何获取代理?\n代理精灵：http://http.zhiliandaili.cn/ 芝麻代理：https://jahttp.zhimaruanjian.com/（推荐，有新人福利） 如何使用代理？\n测试：访问如下网址，返回自己本机ip\nimport requests from lxml import etree headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36\u0026#39;, } url = \u0026#39;https://www.sogou.com/web?query=ip\u0026#39; page_text = requests.get(url=url,headers=headers).text tree = etree.HTML(page_text) data = tree.xpath(\u0026#39;//*[@id=\u0026#34;ipsearchresult\u0026#34;]/strong/text()\u0026#39;)[0] print(data) 使用代理发起请求，查看是否可以返回代理服务器的ip\nimport requests from lxml import etree headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36\u0026#39;, } url = \u0026#39;https://www.sogou.com/web?query=ip\u0026#39; #使用代理服务器发起请求 #proxies={\u0026#39;代理类型\u0026#39;:\u0026#39;ip:port\u0026#39;} page_text = requests.get(url=url,headers=headers,proxies={\u0026#39;https\u0026#39;:\u0026#39;42.57.150.150:4278\u0026#39;}).text tree = etree.HTML(page_text) data = tree.xpath(\u0026#39;//*[@id=\u0026#34;ipsearchresult\u0026#34;]/strong/text()\u0026#39;)[0] print(data) 深度测试：\n对快代理进行n次请求，直到本机无法访问快代理为止（证明本机ip被快代理封掉了）\n构建一个代理池（封装了很多代理ip和端口的容器），用于数据的批量爬取\nfrom bs4 import BeautifulSoup from lxml import etree import requests import time import random headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #构建一个代理池 proxy_url = \u0026#39;http://webapi.http.zhimacangku.com/getip?num=15\u0026amp;type=2\u0026amp;pro=\u0026amp;city=0\u0026amp;yys=0\u0026amp;port=1\u0026amp;pack=213751\u0026amp;ts=0\u0026amp;ys=0\u0026amp;cs=0\u0026amp;lb=6\u0026amp;sb=-\u0026amp;pb=4\u0026amp;mr=1\u0026amp;regions=\u0026#39; json_data = requests.get(url=proxy_url,headers=headers).json() json_list = json_data[\u0026#39;data\u0026#39;] proxy_list = [] #代理池,每次请求，可以随机从代理池中选择一个代理来用 for dic in json_list: ip = dic[\u0026#39;ip\u0026#39;] port = dic[\u0026#39;port\u0026#39;] n_dic = { \u0026#39;https\u0026#39;:ip+\u0026#39;:\u0026#39;+str(port) # {\u0026#39;https\u0026#39;:\u0026#39;111.1.1.1:1234\u0026#39;} } proxy_list.append(n_dic) #爬取多页 #1.创建一个通用的url(可以变换成任意页码的url) url = \u0026#39;https://www.kuaidaili.com/free/inha/%d/\u0026#39; #2.通过循环以此生成不同页码的url for page in range(1,4): print(\u0026#39;----------正在爬取第%d页的数据！-----------\u0026#39;%page) #format用来格式化字符串的（不可以修改url这个字符串本身） new_url = format(url%page) #循环发送每一页的请求 #注意：get方法是一个阻塞方法！ page_text = requests.get(url=new_url,headers=headers,proxies=random.choice(proxy_list)).text time.sleep(1) soup = BeautifulSoup(page_text,\u0026#39;lxml\u0026#39;) trs = soup.select(\u0026#39;tbody \u0026gt; tr\u0026#39;) for tr in trs: t1 = tr.findAll(\u0026#39;td\u0026#39;)[0] t2 = tr.findAll(\u0026#39;td\u0026#39;)[1] ip = t1.string port = t2.string print(ip,port) 验证码 图鉴平台：http://www.ttshitu.com/ （推荐）\n超级鹰：https://www.chaojiying.com/about.html\n使用图鉴识别古诗文网登录中的验证码\n古诗文网：https://so.gushiwen.cn/user/login.aspx?from=http://so.gushiwen.cn/user/collect.aspx\n使用流程：\n注册登录图鉴平台\n登录后，点击开发文档，提取识别的源代码\n模块(tujian.py)的封装：\nimport base64 import json import requests # 一、图片文字类型(默认 3 数英混合)： # 1 : 纯数字 # 1001：纯数字2 # 2 : 纯英文 # 1002：纯英文2 # 3 : 数英混合 # 1003：数英混合2 # 4 : 闪动GIF # 7 : 无感学习(独家) # 11 : 计算题 # 1005: 快速计算题 # 16 : 汉字 # 32 : 通用文字识别(证件、单据) # 66: 问答题 # 49 :recaptcha图片识别 # 二、图片旋转角度类型： # 29 : 旋转类型 # # 三、图片坐标点选类型： # 19 : 1个坐标 # 20 : 3个坐标 # 21 : 3 ~ 5个坐标 # 22 : 5 ~ 8个坐标 # 27 : 1 ~ 4个坐标 # 48 : 轨迹类型 # # 四、缺口识别 # 18 : 缺口识别（需要2张图 一张目标图一张缺口图） # 33 : 单缺口识别（返回X轴坐标 只需要1张图） # 五、拼图识别 # 53：拼图识别 #函数实现忽略 def base64_api(uname, pwd, img, typeid): with open(img, \u0026#39;rb\u0026#39;) as f: base64_data = base64.b64encode(f.read()) b64 = base64_data.decode() data = {\u0026#34;username\u0026#34;: uname, \u0026#34;password\u0026#34;: pwd, \u0026#34;typeid\u0026#34;: typeid, \u0026#34;image\u0026#34;: b64} result = json.loads(requests.post(\u0026#34;http://api.ttshitu.com/predict\u0026#34;, json=data).text) if result[\u0026#39;success\u0026#39;]: return result[\u0026#34;data\u0026#34;][\u0026#34;result\u0026#34;] else: return result[\u0026#34;message\u0026#34;] return \u0026#34;\u0026#34; def getImgCodeText(imgPath,imgType):#直接返回验证码内容 #imgPath：验证码图片地址 #imgType：验证码图片类型 result = base64_api(uname=\u0026#39;bb328410948\u0026#39;, pwd=\u0026#39;bb328410948\u0026#39;, img=imgPath, typeid=imgType) return result 验证码图片识别操作\nfrom lxml import etree import requests import tujian headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #将验证码图片请求后保存到本地 login_url = \u0026#39;https://so.gushiwen.cn/user/login.aspx?from=http://so.gushiwen.cn/user/collect.aspx\u0026#39; page_text = requests.get(url=login_url,headers=headers).text tree = etree.HTML(page_text) img_src = \u0026#39;https://so.gushiwen.cn\u0026#39;+tree.xpath(\u0026#39;//*[@id=\u0026#34;imgCode\u0026#34;]/@src\u0026#39;)[0] code_data = requests.get(url=img_src,headers=headers).content with open(\u0026#39;./code.jpg\u0026#39;,\u0026#39;wb\u0026#39;) as fp: fp.write(code_data) #识别验证码图片内容 result = tujian.getImgCodeText(\u0026#39;./code.jpg\u0026#39;,3) print(result) 模拟登录 古诗文网\n在抓包工具里定位点击登录按钮后对应的数据包：\n只要数据包的请求参数中包含用户名，密码和验证码则该数据包就是我们要定位的\n首次模拟登录操作：\nfrom lxml import etree import requests import tujian headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #将验证码图片请求后保存到本地 login_url = \u0026#39;https://so.gushiwen.cn/user/login.aspx?from=http://so.gushiwen.cn/user/collect.aspx\u0026#39; page_text = requests.get(url=login_url,headers=headers).text tree = etree.HTML(page_text) img_src = \u0026#39;https://so.gushiwen.cn\u0026#39;+tree.xpath(\u0026#39;//*[@id=\u0026#34;imgCode\u0026#34;]/@src\u0026#39;)[0] code_data = requests.get(url=img_src,headers=headers).content with open(\u0026#39;./code.jpg\u0026#39;,\u0026#39;wb\u0026#39;) as fp: fp.write(code_data) #识别验证码图片内容 result = tujian.getImgCodeText(\u0026#39;./code.jpg\u0026#39;,3) print(result) #模拟登录 url = \u0026#39;https://so.gushiwen.cn/user/login.aspx?from=http%3a%2f%2fso.gushiwen.cn%2fuser%2fcollect.aspx\u0026#39; data = { \u0026#34;__VIEWSTATE\u0026#34;: \u0026#34;opfVI7oolwkr7MLRVzsNSMASqLRUuO1dg5ZP5EIRa4FyM+mOYKEs6KWEKQKaba2ulLoZQIaLFiKK4mr5K3ci1v8ua28wtcRtabKWjOtJtU/i2etH+zSduegTMcg=\u0026#34;, \u0026#34;__VIEWSTATEGENERATOR\u0026#34;: \u0026#34;C93BE1AE\u0026#34;, \u0026#34;from\u0026#34;: \u0026#34;http://so.gushiwen.cn/user/collect.aspx\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;15027900535\u0026#34;, \u0026#34;pwd\u0026#34;: \u0026#34;bobo@15027900535\u0026#34;, \u0026#34;code\u0026#34;:result , \u0026#34;denglu\u0026#34;: \u0026#34;登录\u0026#34; } #获取了登录成功后的页面源码数据 login_page_text = requests.post(url=url,headers=headers,data=data).text with open(\u0026#39;wushiwen.html\u0026#39;,\u0026#39;w\u0026#39;) as fp: fp.write(login_page_text) 查看gushiwen.html发现，没有登录成功，原因：\n验证码不对（否定）\n没有携带cookie\n出现了动态变化的请求参数\n如何获取动态变化的请求参数 基于抓包工具进行全局搜索，发现该参数值被隐藏在了登录页面的页面源码中 from lxml import etree import requests import tujian headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #创建session对象 session = requests.Session() #将验证码图片请求后保存到本地 login_url = \u0026#39;https://so.gushiwen.cn/user/login.aspx?from=http://so.gushiwen.cn/user/collect.aspx\u0026#39; page_text = session.get(url=login_url,headers=headers).text tree = etree.HTML(page_text) img_src = \u0026#39;https://so.gushiwen.cn\u0026#39;+tree.xpath(\u0026#39;//*[@id=\u0026#34;imgCode\u0026#34;]/@src\u0026#39;)[0] code_data = session.get(url=img_src,headers=headers).content with open(\u0026#39;./code.jpg\u0026#39;,\u0026#39;wb\u0026#39;) as fp: fp.write(code_data) #解析出动态变化的请求参数 __VIEWSTATE = tree.xpath(\u0026#39;//*[@id=\u0026#34;__VIEWSTATE\u0026#34;]/@value\u0026#39;)[0] #识别验证码图片内容 result = tujian.getImgCodeText(\u0026#39;./code.jpg\u0026#39;,3) print(result) #模拟登录 url = \u0026#39;https://so.gushiwen.cn/user/login.aspx?from=http%3a%2f%2fso.gushiwen.cn%2fuser%2fcollect.aspx\u0026#39; data = { \u0026#34;__VIEWSTATE\u0026#34;: __VIEWSTATE, \u0026#34;__VIEWSTATEGENERATOR\u0026#34;: \u0026#34;C93BE1AE\u0026#34;, \u0026#34;from\u0026#34;: \u0026#34;http://so.gushiwen.cn/user/collect.aspx\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;15027900535\u0026#34;, \u0026#34;pwd\u0026#34;: \u0026#34;bobo@15027900535\u0026#34;, \u0026#34;code\u0026#34;:result , \u0026#34;denglu\u0026#34;: \u0026#34;登录\u0026#34; } #获取了登录成功后的页面源码数据 login_page_text = session.post(url=url,headers=headers,data=data).text with open(\u0026#39;wushiwen.html\u0026#39;,\u0026#39;w\u0026#39;) as fp: fp.write(login_page_text) 防盗链 现在很多网站启用了防盗链反爬，防止服务器上的资源被人恶意盗取。什么是防盗链呢？\n以图片为例，访问图片要从他的网站访问才可以，否则直接访问图片地址得不到图片 练习：抓取微博图片，url：http://blog.sina.com.cn/lm/pic/，将页面中某一组系列详情页的图片进行抓取保存，比如三里屯时尚女郎：http://blog.sina.com.cn/s/blog_01ebcb8a0102zi2o.html?tj=1\n注意：\n1.在解析图片地址的时候，定位src的属性值，返回的内容和开发工具Element中看到的不一样，通过network查看网页源码发现需要解析real_src的值。\n2.直接请求real_src请求到的图片不显示，加上Refere请求头即可\n哪里找Refere：抓包工具定位到某一张图片数据包，在其requests headers中获取 import requests from lxml import etree headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39;, \u0026#34;Referer\u0026#34;: \u0026#34;http://blog.sina.com.cn/\u0026#34;, } url = \u0026#39;http://blog.sina.com.cn/s/blog_01ebcb8a0102zi2o.html?tj=1\u0026#39; page_text = requests.get(url,headers=headers).text tree = etree.HTML(page_text) img_src = tree.xpath(\u0026#39;//*[@id=\u0026#34;sina_keyword_ad_area2\u0026#34;]/div/a/img/@real_src\u0026#39;) for src in img_src: data = requests.get(src,headers=headers).content with open(\u0026#39;./123.jpg\u0026#39;,\u0026#39;wb\u0026#39;) as fp: fp.write(data) # break 图片懒加载(作业) url：https://sc.chinaz.com/tupian/meinvtupian.html 爬取上述链接中所有的图片数据 图片懒加载： 主要是应用在展示图片的网页中的一种技术，该技术是指当网页刷新后，先加载局部的几张图片数据即可，随着用户滑动滚轮，当图片被显示在浏览器的可视化区域范围的话，在动态将其图片请求加载出来即可。（图片数据是动态加载出来）。 如何实现图片懒加载/动态加载？ 使用img标签的伪属性（指的是自定义的一种属性）。在网页中，为了防止图片马上加载出来，则在img标签中可以使用一种伪属性来存储图片的链接，而不是使用真正的src属性值来存储图片链接。（图片链接一旦给了src属性，则图片会被立即加载出来）。只有当图片被滑动到浏览器可视化区域范围的时候，在通过js将img的伪属性修改为真正的src属性，则图片就会被加载出来。 如何爬取图片懒加载的图片数据？ 只需要在解析图片的时候，定位伪属性（src2）的属性值即可。 ","permalink":"https://canw0916.github.io/en/posts/tech/requests%E9%AB%98%E7%BA%A7/","summary":"简历模板下载拓展 import requests from lxml import etree import os headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36\u0026#39;, } #创建一个新的文件夹 dirName = \u0026#39;jianli\u0026#39; if not os.path.exists(dirName): os.mkdir(dirName) #通用的url模板 url = \u0026#39;https://sc.chinaz.com/jianli/free_%d.html\u0026#39; for page in range(1,11): if page == 1:","title":"Requests高级"},{"content":"数据解析 何为数据解析 概念：就是将爬取到数据中局部的指定的数据进行提取 作用：实现聚焦爬虫 数据解析通用原理： html是用来展示数据，html中展示的数据正是我们要爬取或者采集的数据 html所展示的数据/想要爬取的数据只会存在于标签之间或者标签的属性中 数据解析的通用原理： 标签定位 提取标签中存储的数据 聚焦爬虫编码流程 指定url 发起请求 获取响应数据 数据解析 持久化存储 数据解析的主流策略 如何爬取多媒体资源（图片，音频，视频，动图）\n方式1：编写麻烦，但是可以实现UA伪装\nimport requests headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36X-Requested-With: XMLHttpRequest\u0026#39; } #获取图片地址：通常为img标签的src属性值 img_src = \u0026#39;http://img.itlun.cn/uploads/allimg/180506/1-1P5061TS6-lp.jpg\u0026#39; #对图片发起请求 response = requests.get(url=img_src,headers=headers) #获取图片数据:content返回的是二进制形式的响应数据 img_data = response.content #持久化存储 with open(\u0026#39;./123.jpg\u0026#39;,\u0026#39;wb\u0026#39;) as fp: fp.write(img_data) 方式2：编写简单，但是无法实现UA伪装\nfrom urllib import request img_src = \u0026#39;http://img.itlun.cn/uploads/allimg/180506/1-1P5061TS6-lp.jpg\u0026#39; #urlretrieve可以直接对图片发起请求，且将请求到的图片数据进行持久化存储 request.urlretrieve(img_src,\u0026#39;./456.jpg\u0026#39;) 正则（基本掌握）\n案例应用：批量爬取图片\nurl：http://md.itlun.cn/a/nhtp/\n大致思路：\n将页面中每一张图片的图片地址解析出来 对图片地址发起请求获取图片数据，然后进行持久化存储 注意：\n开发者工具中Elements选项卡中显示的页面源码数据（会包含动态加载数据）： 是通过所有数据包请求到的数据渲染完毕后的完整数据 抓包工具Network中response显示的页面源码数据：（不包含动态加载数据） 其实就是通过requests模块对该数据包的url发起请求获取的响应数据 单独该数据包请求到的响应数据 from urllib import request import requests import re main_url = \u0026#39;http://md.itlun.cn/a/nhtp/\u0026#39; response = requests.get(url=main_url) #处理页面中的中文乱码 response.encoding = \u0026#39;gbk\u0026#39; #获取了页面源码数据 page_text = response.text #数据解析：解析图片的地址 # ex = \u0026#39;\u0026lt;li\u0026gt;.*?\u0026lt;img.*?src=\u0026#34;(.*?)\u0026#34; style.*?\u0026lt;/li\u0026gt;\u0026#39; #re.S用来处理回车 # img_src_list = re.findall(ex,page_text,re.S) #注意：如果确认正则没有写错，则取关注下正则作用到的页面源码是否出现问题 #极有可能页面源码数据出现了动态加载的情况 #在抓包工具中，查看了数据包的响应数据，发现img，li标签都是大写，而我们写的正则匹配的是小写标签，因此匹配失败 # ex = \u0026#39;\u0026lt;LI\u0026gt;.*?\u0026lt;IMG.*?src=\u0026#34;(.*?)\u0026#34; style.*?\u0026lt;/LI\u0026gt;\u0026#39; # img_src_list = re.findall(ex,page_text,re.S) #问题：提取到的图片地址都是一样的。如何解决？继续查看抓包工具的源码 #发现：真正的图片地址是有js动态加载出来的 ex = \u0026#39;\u0026lt;script.*?src = \u0026#34;(.*?)\u0026#34;; \u0026lt;/script\u0026gt;\u0026#39; img_src_list = re.findall(ex,page_text,re.S) #发现解析出的图片地址，是不完整的，缺少http: for img_src in img_src_list: img_src = \u0026#39;http:\u0026#39;+img_src # print(img_src) img_name = img_src.split(\u0026#39;/\u0026#39;)[-1] request.urlretrieve(img_src,img_name) print(img_name,\u0026#39;下载成功！\u0026#39;) bs4（重点）\n环境安装：pip install bs4\nbs4数据解析的流程\n1.实例化一个BeautifulSoup的对象，然后把即将被解析的页面源码数据加载到该对象中 BeautifulSoup(fp,\u0026rsquo;lxml\u0026rsquo;):fp表示本地的一个文件，该种方式是将本地存储的html文件进行数据解析 BeautifulSoup(page_text,\u0026rsquo;lxml\u0026rsquo;):page_text是网络请求到的页面源码数据，该种方式是直接将网络请求到的页面源码数据进行数据解析 2.调用BeautifulSoup对象中相关的属性和方法实现标签定位和数据提取 具体解析的操作：\n在当前目录下新建一个test.html文件，然后将下述内容拷贝到该文件中\n\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;测试bs4\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;百里守约\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;song\u0026#34;\u0026gt; \u0026lt;p\u0026gt;李清照\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;王安石\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;苏轼\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;柳宗元\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;http://www.song.com/\u0026#34; title=\u0026#34;赵匡胤\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt; \u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt; 宋朝是最强大的王朝，不是军队的强大，而是经济很强大，国民都很有钱\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;du\u0026#34;\u0026gt;总为浮云能蔽日,长安不见使人愁\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;http://www.baidu.com/meinv.jpg\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tang\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; title=\u0026#34;qing\u0026#34;\u0026gt;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.163.com\u0026#34; title=\u0026#34;qin\u0026#34;\u0026gt;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.126.com\u0026#34; alt=\u0026#34;qi\u0026#34;\u0026gt;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.sina.com\u0026#34; class=\u0026#34;du\u0026#34;\u0026gt;杜甫\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.dudu.com\u0026#34; class=\u0026#34;du\u0026#34;\u0026gt;杜牧\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;b\u0026gt;杜小月\u0026lt;/b\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i\u0026gt;度蜜月\u0026lt;/i\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.haha.com\u0026#34; id=\u0026#34;feng\u0026#34;\u0026gt;凤凰台上凤凰游,凤去台空江自流,吴宫花草埋幽径,晋代衣冠成古丘\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 有了test.html文件后，在练习如下操作\nfrom bs4 import BeautifulSoup #fp就表示本地存储的一个html文件 fp = open(\u0026#39;./test.html\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) #解析本地存储的html文件中的内容 #实例化BeautifulSoup对象，然后把即将被解析的页面源码数据加载到了该对象中 soup = BeautifulSoup(fp,\u0026#39;lxml\u0026#39;) #参数2，lxml是固定形式，表示指定的解析器 #标签定位 #方式1：soup.tagName,只会定位到符合条件的第一个标签 tag1 = soup.title #定位到了title标签 tag2 = soup.div #方式2：属性定位，find函数，findall函数 #find(\u0026#39;tagName\u0026#39;,attrName=\u0026#39;attrValue\u0026#39;)：find只会定位到满足要的第一个标签 tag3 = soup.find(\u0026#39;div\u0026#39;,class_=\u0026#39;song\u0026#39;)#定位class属性值为song的div标签 tag4 = soup.find(\u0026#39;a\u0026#39;,id=\u0026#39;feng\u0026#39;)#定位id属性值为feng的a标签 #findAll(\u0026#39;tagName\u0026#39;,attrName=\u0026#39;attrValue\u0026#39;)：可以定位到满足要求的所有标签 tag5 = soup.findAll(\u0026#39;div\u0026#39;,class_=\u0026#39;song\u0026#39;) #方式3：选择器定位：soup.select(\u0026#39;选择器\u0026#39;) #id选择器：#feng ----id为feng #class选择器：.song ----class为song #层级选择器：大于号表示一个层级，空格表示多个层级 tag6 = soup.select(\u0026#39;#feng\u0026#39;) #定位到所有id属性值为feng的标签 tag7 = soup.select(\u0026#39;.song\u0026#39;)#定位到所有class属性值为song的标签 tag8 = soup.select(\u0026#39;.tang \u0026gt; ul \u0026gt; li\u0026#39;) #定位到了class为tang下面的ul下面所有的li标签 tag9 = soup.select(\u0026#39;.tang li\u0026#39;) #提取标签中的内容 #1.提取标签中间的内容： #tag.string:只可以提取到标签中直系的文本内容 #tag.text:可以提取到标签中所有的文本内容 # p_tag = soup.p # print(p_tag.string) # print(p_tag.text) # div_tag = soup.find(\u0026#39;div\u0026#39;,class_=\u0026#39;song\u0026#39;) # print(div_tag.text) #2.提取标签的属性值 #tag[\u0026#39;attrName\u0026#39;] img_tag = soup.img print(img_tag[\u0026#39;src\u0026#39;]) #提取img标签的src的属性值 案例应用：小说批量爬取\nurl：https://www.shicimingju.com/book/sanguoyanyi.html\n需求：将每一个章节的标题和内容进行爬取然后存储到一个文件中\n步骤： 1.请求主页的页面源码数据 2.数据解析： 章节标题 章节详情页的链接 3.解析章节详细内容 4.将解析的章节标题和内容进行存储 from bs4 import BeautifulSoup import requests headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #首页地址 main_url = \u0026#39;https://www.shicimingju.com/book/sanguoyanyi.html\u0026#39; #发起请求，获取了主页页面源码 response = requests.get(url=main_url,headers=headers) response.encoding = \u0026#39;utf-8\u0026#39; page_text = response.text #数据解析：章节标题+详情页链接 soup = BeautifulSoup(page_text,\u0026#39;lxml\u0026#39;) a_list = soup.select(\u0026#39;.book-mulu \u0026gt; ul \u0026gt; li \u0026gt; a\u0026#39;) fp = open(\u0026#39;./sanguo.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for a in a_list: title = a.string #章节标题 detail_url = \u0026#39;https://www.shicimingju.com\u0026#39;+a[\u0026#39;href\u0026#39;] #详情页地址 #请求详情页的页面源码数据 response = requests.get(url=detail_url,headers=headers) response.encoding = \u0026#39;utf-8\u0026#39; detail_page_text = response.text #解析：解析章节内容 d_soup = BeautifulSoup(detail_page_text,\u0026#39;lxml\u0026#39;) div_tag = d_soup.find(\u0026#39;div\u0026#39;,class_=\u0026#39;chapter_content\u0026#39;) content = div_tag.text #章节内容 fp.write(title+\u0026#39;:\u0026#39;+content+\u0026#39;\\n\u0026#39;) print(title,\u0026#39;爬取保存成功！\u0026#39;) fp.close() 案例应用：代理批量爬取\nurl：https://www.kuaidaili.com/free\n需求：将前5页的所有id和port解析且存储到文件中\n#只爬取了第一页的内容 from bs4 import BeautifulSoup import requests headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } url = \u0026#39;https://www.kuaidaili.com/free\u0026#39; page_text = requests.get(url=url,headers=headers).text soup = BeautifulSoup(page_text,\u0026#39;lxml\u0026#39;) trs = soup.select(\u0026#39;tbody \u0026gt; tr\u0026#39;) for tr in trs: t1 = tr.findAll(\u0026#39;td\u0026#39;)[0] t2 = tr.findAll(\u0026#39;td\u0026#39;)[1] ip = t1.string port = t2.string print(ip,port) #爬取多页内容 from bs4 import BeautifulSoup import requests import time headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #爬取多页 #1.创建一个通用的url(可以变换成任意页码的url) url = \u0026#39;https://www.kuaidaili.com/free/inha/%d/\u0026#39; #2.通过循环以此生成不同页码的url for page in range(1,11): print(\u0026#39;----------正在爬取第%d页的数据！-----------\u0026#39;%page) #format用来格式化字符串的（不可以修改url这个字符串本身） new_url = format(url%page) #循环发送每一页的请求 #注意：get方法是一个阻塞方法！ page_text = requests.get(url=new_url,headers=headers).text time.sleep(1) soup = BeautifulSoup(page_text,\u0026#39;lxml\u0026#39;) trs = soup.select(\u0026#39;tbody \u0026gt; tr\u0026#39;) for tr in trs: t1 = tr.findAll(\u0026#39;td\u0026#39;)[0] t2 = tr.findAll(\u0026#39;td\u0026#39;)[1] ip = t1.string port = t2.string print(ip,port) xpath（重点）\n环境安装：pip install lxml\nxpath解析的编码流程\n1.创建一个etree类型的对象，然后把即将被解析的页面源码数据加载到该对象中 2.调用etree对象的xpath方法结合着不同形式的xpath表达式，进行标签定位和数据提取 xpath表达式如何理解？\nhtml中的标签是遵从树状结构的。\n切记:xpath表达式中不可以出现tbody标签，如果有直接将其删除跨过即可！\nfrom lxml import etree #如果这种方式报错，使用下面方式导入etree # from lxml.html import etree fp = open(\u0026#39;test.html\u0026#39;,\u0026#39;r\u0026#39;) #1.将本地存储好的文件中的数据加载到etree对象中进行数据解析 tree = etree.parse(fp) #2.调用etree对象的xpath方法结合不同形式的xpath表达式进行标签定位和数据提取 #xpath返回的一定是列表，列表中存储的是定位到的标签对象 # title_tag = tree.xpath(\u0026#39;/html/head/title\u0026#39;) # title_tag = tree.xpath(\u0026#39;/html//title\u0026#39;) # title_tag = tree.xpath(\u0026#39;//head/title\u0026#39;) # title_tag = tree.xpath(\u0026#39;//title\u0026#39;) #推荐 #最左侧为/:表示必须从树的根标签（html标签）开始进行定位 #最左侧为//:可以从任意位置进行标签的相对位置定位 #非最左侧的/:表示一个层级 #非最左侧的//:表示多个层级 # tag = tree.xpath(\u0026#39;//div\u0026#39;) #定位所有的div标签 #属性定位：根据标签的属性定位标签 #//tagName[@attrName=\u0026#34;attrValue\u0026#34;] # tag = tree.xpath(\u0026#39;//div[@class=\u0026#34;song\u0026#34;]\u0026#39;)#定位class属性值为song的div标签 # tag = tree.xpath(\u0026#39;//a[@id=\u0026#34;feng\u0026#34;]\u0026#39;) # tag = tree.xpath(\u0026#39;//div[@class=\u0026#34;tang\u0026#34;]/ul/li/a[@id=\u0026#34;feng\u0026#34;]\u0026#39;) #索引定位：索引是从1开始的 # tag = tree.xpath(\u0026#39;//div[@class=\u0026#34;tang\u0026#34;]/ul/li[3]\u0026#39;)#定位到第三个li标签 #获取定位到标签中的文本内容 # /text()获取标签中直系的文本内容：返回的列表中只会有一个列表元素 # //text()获取标签中所有的文本内容：通常返回列表中存在多个元素 # tag = tree.xpath(\u0026#39;//div[@class=\u0026#34;song\u0026#34;]/p[3]/text()\u0026#39;) # tag = tree.xpath(\u0026#39;//div[@class=\u0026#34;song\u0026#34;]//text()\u0026#39;) #获取定位到标签中的属性值://tag/@attrName tag = tree.xpath(\u0026#39;//img/@src\u0026#39;) print(tag) 案例应用：\nhttp://pic.netbian.com/4kmeinv/\n将爬取到的图片存储到指定的文件夹中\n爬取第一页\nfrom lxml import etree import requests import os #新建一个文件夹 dirName = \u0026#39;girls\u0026#39; if not os.path.exists(dirName):#如果文件夹不存在，则新建，否则不新建 os.mkdir(dirName) headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } url = \u0026#39;https://pic.netbian.com/4kmeinv/index.html\u0026#39; response = requests.get(url=url,headers=headers) response.encoding = \u0026#39;gbk\u0026#39; page_text = response.text #数据解析：图片地址+图片名称 tree = etree.HTML(page_text)#HTML()专门用来解析网络请求到的页面源码数据 #该列表中存储的是每一个li标签 li_list = tree.xpath(\u0026#39;//div[@class=\u0026#34;slist\u0026#34;]/ul/li\u0026#39;) for li in li_list: #局部解析：将li标签中指定的内容解析出来 img_title = li.xpath(\u0026#39;./a/b/text()\u0026#39;)[0]+\u0026#39;.jpg\u0026#39;# 左侧./表示xpath的调用者对应的标签 img_src = \u0026#39;https://pic.netbian.com\u0026#39;+li.xpath(\u0026#39;./a/img/@src\u0026#39;)[0] #对图片发起请求，存储图片数据 img_data = requests.get(url=img_src,headers=headers).content # girls/123.jpg img_path = dirName + \u0026#39;/\u0026#39; + img_title with open(img_path,\u0026#39;wb\u0026#39;) as fp: fp.write(img_data) print(img_title,\u0026#39;下载保存成功！\u0026#39;) 爬取多页\nfrom lxml import etree import requests import os #新建一个文件夹 dirName = \u0026#39;girls\u0026#39; if not os.path.exists(dirName):#如果文件夹不存在，则新建，否则不新建 os.mkdir(dirName) headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #创建一个通用的url:除了第一页其他页码的通用url url = \u0026#39;https://pic.netbian.com/4kmeinv/index_%d.html\u0026#39; for page in range(1,6): if page == 1: new_url = \u0026#39;https://pic.netbian.com/4kmeinv/index.html\u0026#39; else: new_url = format(url%page) print(\u0026#39;----------正在请求下载第%d页的图片数据----------\u0026#39;%page) response = requests.get(url=new_url,headers=headers) response.encoding = \u0026#39;gbk\u0026#39; page_text = response.text #数据解析：图片地址+图片名称 tree = etree.HTML(page_text)#HTML()专门用来解析网络请求到的页面源码数据 #该列表中存储的是每一个li标签 li_list = tree.xpath(\u0026#39;//div[@class=\u0026#34;slist\u0026#34;]/ul/li\u0026#39;) for li in li_list: #局部解析：将li标签中指定的内容解析出来 img_title = li.xpath(\u0026#39;./a/b/text()\u0026#39;)[0]+\u0026#39;.jpg\u0026#39;# 左侧./表示xpath的调用者对应的标签 img_src = \u0026#39;https://pic.netbian.com\u0026#39;+li.xpath(\u0026#39;./a/img/@src\u0026#39;)[0] #对图片发起请求，存储图片数据 img_data = requests.get(url=img_src,headers=headers).content # girls/123.jpg img_path = dirName + \u0026#39;/\u0026#39; + img_title with open(img_path,\u0026#39;wb\u0026#39;) as fp: fp.write(img_data) print(img_title,\u0026#39;下载保存成功！\u0026#39;) https://www.aqistudy.cn/historydata/\n爬取热门城市和全部城市的名称\n#第一种写法 from lxml import etree import requests headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } url = \u0026#39;https://www.aqistudy.cn/historydata/\u0026#39; page_text = requests.get(url=url,headers=headers).text tree = etree.HTML(page_text) #解析热门城市 hot_li_list = tree.xpath(\u0026#39;//div[@class=\u0026#34;bottom\u0026#34;]/ul/li\u0026#39;) for li in hot_li_list: city_name = li.xpath(\u0026#39;./a/text()\u0026#39;)[0] print(city_name) #解析全部城市 all_li_list = tree.xpath(\u0026#39;//div[@class=\u0026#34;bottom\u0026#34;]/ul/div[2]/li\u0026#39;) for li in all_li_list: city_name = li.xpath(\u0026#39;./a/text()\u0026#39;)[0] print(city_name) #第二种写法 from lxml import etree import requests headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } url = \u0026#39;https://www.aqistudy.cn/historydata/\u0026#39; page_text = requests.get(url=url,headers=headers).text tree = etree.HTML(page_text) #解析热门城市+所有城市 #此处xpath表达式的管道符（|）可以是的xpath表达式更加具有通用性 li_list = tree.xpath(\u0026#39;//div[@class=\u0026#34;bottom\u0026#34;]/ul/li | //div[@class=\u0026#34;bottom\u0026#34;]/ul/div[2]/li\u0026#39;) for li in li_list: city_name = li.xpath(\u0026#39;./a/text()\u0026#39;)[0] print(city_name) https://sc.chinaz.com/jianli/free.html\n下载当前页所有的建立模板\nfrom lxml import etree import requests headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } url = \u0026#39;https://sc.chinaz.com/jianli/free.html\u0026#39; response = requests.get(url=url,headers=headers) response.encoding = \u0026#39;utf-8\u0026#39; page_text = response.text #数据解析:简历名称+详情页的url tree = etree.HTML(page_text) div_list = tree.xpath(\u0026#39;//*[@id=\u0026#34;container\u0026#34;]/div\u0026#39;) for div in div_list: title = div.xpath(\u0026#39;./p/a/text()\u0026#39;)[0]+\u0026#39;.rar\u0026#39; detail_url = \u0026#39;https:\u0026#39;+div.xpath(\u0026#39;./p/a/@href\u0026#39;)[0] # print(title,detail_url) #对详情页的url发起请求 detail_page_text = requests.get(url=detail_url,headers=headers).text #数据解析：下载地址 tree = etree.HTML(detail_page_text) download_url = tree.xpath(\u0026#39;//*[@id=\u0026#34;down\u0026#34;]/div[2]/ul/li[1]/a/@href\u0026#39;)[0] #在下载请求建立模板 data = requests.get(url=download_url,headers=headers).content with open(title,\u0026#39;wb\u0026#39;) as fp: fp.write(data) print(title,\u0026#39;保存下载成功！\u0026#39;) http://blog.sina.com.cn/lm/pic/\n爬取精选图片的缩略图和标题\nfrom lxml import etree import requests headers = { \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } url = \u0026#39;http://blog.sina.com.cn/lm/pic/\u0026#39; response = requests.get(url=url,headers=headers) response.encoding = \u0026#39;utf-8\u0026#39; page_text = response.text #数据解析：图片地址+标题 tree = etree.HTML(page_text) #直接删除被隐藏的div，将其在xpath表达式中跨过即可 li_list = tree.xpath(\u0026#39;//*[@id=\u0026#34;pic_wrap0\u0026#34;]//ul[1]/li\u0026#39;) for li in li_list: img_src = li.xpath(\u0026#39;./a/div/img/@src\u0026#39;)[0] title = li.xpath(\u0026#39;./a/div/img/@title\u0026#39;)[0] print(img_src,title) ","permalink":"https://canw0916.github.io/en/posts/tech/%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/","summary":"数据解析 何为数据解析 概念：就是将爬取到数据中局部的指定的数据进行提取 作用：实现聚焦爬虫 数据解析通用原理： html是用来展示数据，html中展","title":"爬虫数据解析"},{"content":"爬虫初始 为什么要学习爬虫 之前在授课过程中，好多同学都问过我这样的一个问题：为什么要学习爬虫，学习爬虫能够为我们以后的发展带来那些好处？其实学习爬虫的原因和为我们以后发展带来的好处都是显而易见的，无论是从实际的应用还是从就业上。\n我们都知道，当前我们所处的时代是大数据的时代，在大数据时代，要进行数据分析，首先要有数据源，而学习爬虫，可以让我们获取更多的数据源，并且这些数据源可以按我们的目的进行采集。\n优酷推出的火星情报局就是基于网络爬虫和数据分析制作完成的。其中每期的节目话题都是从相关热门的互动平台中进行相关数据的爬取，然后对爬取到的数据进行数据分析而得来的。另一方面，优酷根据用户实时观看视频时的前进，后退等行为数据，能够推测计算出观众的兴趣点和爱好点，这样有助于节目的剪辑和后期的节目方案的编写。\n今日头条作为一个新闻推荐类的应用，其内部的新闻数据都是通过爬虫程序在各个新闻网站进行新闻数据的爬取，然后通过相应的处理和运算将用户感兴趣的新闻话题推送到用户的手机上。\n从就业的角度来说，爬虫工程师目前来说属于紧缺人才，并且薪资待遇普遍较高所以，深层次地掌握这门技术，对于就业来说，是非常有利的。有些人学习爬虫可能为了就业或者跳槽。从这个角度来说，爬虫工程师是不错的选择之一。随着大数据时代的来临，爬虫技术的应用将越来越广泛，在未来会拥有更好的发展空间。\n爬虫相关介绍 什么是爬虫 就是编写程序，模拟浏览器上网，让其去互联网中抓取数据的过程 模拟： 浏览器本身就是一个纯天然的爬虫工具，爬虫相关的模块都是基于浏览器为基础开发出来的。 注意：日后只要是你的爬虫程序没有爬取到你想要的数据，只有一个原因： 就是你的爬虫程序模拟的力度不够！ 抓取： 抓取网页数据分两种情况： 将一个页面所有的数据抓取到 将页面中局部的数据抓取到 爬虫在应用场景的分类 通用爬虫： 将一个页面中所有的数据获取。 大部分的搜索引擎中应用比较多。 聚焦爬虫 将页面中局部的指定的数据进行提取/抓取 注意：聚焦爬虫一定是建立在通用爬虫的基础之上实现。 功能爬虫 通过浏览器或者app自动化的操作，实现相关的网页或者app自动化的操作。代替人工在网页或者手机软件中自动执行相关的行为动作。 批量点赞，批量评论，刷单,秒杀\u0026hellip;.. 增量式爬虫 用来监测网站数据更新的情况。以便爬取网站最新更新出来的数据！ 分布式爬虫 可以对网站所有的资源使用分布式机群进行分布和联合的数据爬取 爬虫的矛与盾 反爬机制：对应门户网站，网站可以指定相关的机制阻止爬虫对其网站数据的采集 反反爬策略：对应爬虫程序，爬虫可以制定相关的策略将网站的反爬机制破解，从而爬取到指定的数据 盗亦有道的君子协议robots Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots ExclusionProtocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取. 注意，这个协议的存在更多的是需要网络爬虫去遵守，而起不到防止爬虫的功能。 爬虫合法性探究 **爬虫作为一种计算机技术就决定了它的中立性，因此爬虫本身在法律上并不被禁止，但是利用爬虫技术获取数据这一行为是具有违法甚至是犯罪的风险的。**所谓具体问题具体分析，正如水果刀本身在法律上并不被禁止使用，但是用来捅人，就不被法律所容忍了。 或者我们可以这么理解：爬虫是用来批量获得网页上的公开信息的，也就是前端显示的数据信息。因此，既然本身就是公开信息，其实就像浏览器一样，浏览器解析并显示了页面内容，爬虫也是一样，只不过爬虫会批量下载而已，所以是合法的。不合法的情况就是配合爬虫，利用黑客技术攻击网站后台，窃取后台数据（比如用户数据等）。 举个例子：像谷歌这样的搜索引擎爬虫，每隔几天对全网的网页扫一遍，供大家查阅，各个被扫的网站大都很开心。这种就被定义为“善意爬虫”。但是像抢票软件这样的爬虫，对着 12306 每秒钟恨不得撸几万次，铁总并不觉得很开心，这种就被定义为“恶意爬虫”。 爬虫所带来风险主要体现在以下3个方面： 1、违反网站意愿，例如网站采取反爬措施后，强行突破其反爬措施； 2、爬虫干扰了被访问网站的正常运营； 3、爬虫抓取了受到法律保护的特定类型的数据或信息。 那么作为爬虫开发者，如何在使用爬虫时避免进局子的厄运呢？ 1、严格遵守网站设置的robots协议； 2、在规避反爬虫措施的同时，需要优化自己的代码，避免干扰被访问网站的正常运行； 3、在使用、传播抓取到的信息时，应审查所抓取的内容，如发现属于用户的个人信息、隐私或者他人的商业秘密的，应及时停止并删除。 总结： 可以说在我们身边的网络上已经密密麻麻爬满了各种网络爬虫，它们善恶不同，各怀心思。而越是每个人切身利益所在的地方，就越是爬满了爬虫。**所以爬虫是趋利的，它们永远会向有利益的地方爬行。**技术本身是无罪的，问题往往出在人无限的欲望上。因此爬虫开发者的道德自持和企业经营者的良知才是避免触碰法律底线的根本所在。 requests基础操作 基本介绍\nrequests就是爬虫中一个基于网络请求的模块。 作用：模拟浏览器上网的。 urllib模块就是一个老版的requests模块，现在没人用urllib 环境安装\npip install requests 编码流程\n指定url（好比打开浏览器输入网址） 发起请求（好比是按下回车） 获取响应数据（从指定url中爬取到的数据） 持久化存储 案例应用\n搜狗首页数据采集\nhttps://www.sogou.com/\nimport requests #1,指定url url = \u0026#39;https://www.sogou.com/\u0026#39; #2,发起请求（只要在浏览器地址栏输入网址按下回车，发起的一定get请求） #url为get方法的第一个参数，表示根据指定的url发起get请求 #get方法会返回一个响应对象 response = requests.get(url=url) #get使用来使用requests模块发起get请求 #3.获取响应数据/爬取到的数据 page_text = response.text #text属性使用来返回字符串形式的响应数据 # print(page_text) #4.持久化存储 with open(\u0026#39;./sogou.html\u0026#39;,\u0026#39;w\u0026#39;) as fp: fp.write(page_text) print(\u0026#39;数据爬取存储成功！\u0026#39;) 简易的网页采集器\n注意：在浏览器的地址栏中网址，网址？后面的内容就是请求的参数（请求参数）\nhttps://www.sogou.com/web?query=jay query=jay就是请求的参数 请求参数就是客户端发送给服务端的数据 https://www.sogou.com/\nimport requests #请求参数动态化 keyword = input(\u0026#39;请输入关键字:\u0026#39;) #稍后想要把该字典作为请求参数 pram = { \u0026#39;query\u0026#39;:keyword, #只存在一个键值对（存在一组请求参数） } #1.指定url url = \u0026#39;https://www.sogou.com/web\u0026#39; #需要将请求参数去除 #2.发起请求 #params参数就是用来在请求时携带指定的请求参数 response = requests.get(url=url,params=pram) #3.获取响应数据 page_text = response.text #4.持久化存储 fileName = keyword + \u0026#39;.html\u0026#39; with open(fileName,\u0026#39;w\u0026#39;) as fp: fp.write(page_text) #出问题：没有爬取到我们想要的数据？原因是因为遇到反爬机制 分析该网站的反爬机制：\n从爬取到的内容中提取到了一个关键信息：网站检测到了异常的访问请求 异常的访问请求：通过程序发起的请求 正常访问请求：通过浏览器发起的请求 网站如何可以监测请求是不是通过浏览器发起的呢？ 是通过请求的一个头信息：user-agent user-agent：请求载体的身份标识 破解方式（UA伪装）：伪装请求载体的身份标识 该反爬机制是一种最常见最通用的，也就是说绝大数网站都会携带该反爬机制，因此日后写爬虫程序，默认带上UA伪装操作。 import requests #请求参数动态化 keyword = input(\u0026#39;请输入关键字:\u0026#39;) #稍后想要把该字典作为请求参数 pram = { \u0026#39;query\u0026#39;:keyword, #只存在一个键值对（存在一组请求参数） } #1.指定url url = \u0026#39;https://www.sogou.com/web\u0026#39; #需要将请求参数去除 #2.发起请求 head = { #存放需要伪装的头信息 \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #通过headers参数进行了头信息的伪装 response = requests.get(url=url,params=pram,headers=head) #3.获取响应数据 page_text = response.text #4.持久化存储 fileName = keyword + \u0026#39;.html\u0026#39; with open(fileName,\u0026#39;w\u0026#39;) as fp: fp.write(page_text) 豆瓣电影\nhttps://movie.douban.com/typerank?type_name=%E7%88%B1%E6%83%85\u0026amp;type=13\u0026amp;interval_id=100:90\u0026amp;action=\n爬取电影的详情数据\n对网站进行分析：\n1.在抓包工具中先定位到和浏览器地址栏的网址一样的数据包\n2.查看开发者工具中，定位到的数据包中的response这一项，该项中存放的就是对定位到数据包的url发起请求，请求到的数据。\n3.在response选项卡中查看是否存在我们想要爬取的数据：\n如何检测是否存在我们想要爬取的数据呢？\n局部搜索：将你想要爬取的局部数据，在response进行搜索，查看是否可以搜索到。\n搜索到了：\n可以直接对该数据包的url发起请求获取你想要的数据即可 搜索不到：\n说明你想要的数据是【动态加载数据】 什么是动态加载数据？ 特指，不是通过浏览器地址栏的请求请求到的数据，就是动态加载数据。同理，动态加载数据一定是通过其他的请求请求到的。 如何获取动态加载数据？ 基于抓包工具进行全局搜索 鼠标点击任意的数据包，然后按下cotrl+f打开全局搜索框，搜索局部你想要的数据，即可定位到包含搜索数据的指定数据包。 从指定数据包中就可以提取出： url：https://movie.douban.com/j/chart/top_list 请求方式：get 请求参数：type=13\u0026amp;interval_id=100%3A90\u0026amp;action=\u0026amp;start=0\u0026amp;limit=1 import requests head = { #存放需要伪装的头信息 \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } pram = { \u0026#34;type\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;interval_id\u0026#34;: \u0026#34;100:90\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;limit\u0026#34;: \u0026#34;20\u0026#34;, } url = \u0026#39;https://movie.douban.com/j/chart/top_list\u0026#39; response = requests.get(url=url,headers=head,params=pram) #获取响应数据 #json()可以将获取到的json格式的字符串进行反序列化 page_text = response.json() fp = open(\u0026#39;./douban.txt\u0026#39;,\u0026#39;w\u0026#39;) for dic in page_text: title = dic[\u0026#39;title\u0026#39;] score = dic[\u0026#39;score\u0026#39;] fp.write(title+\u0026#39;:\u0026#39;+score+\u0026#39;\\n\u0026#39;) print(title,\u0026#39;爬虫保存成功！\u0026#39;) 肯德基\nhttp://www.kfc.com.cn/kfccda/index.aspx\n将餐厅的位置信息进行数据爬取\nimport requests head = { #存放需要伪装的头信息 \u0026#39;User-Agent\u0026#39;:\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39; } #post请求的请求参数 data = { \u0026#34;cname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;keyword\u0026#34;: \u0026#34;天津\u0026#34;, \u0026#34;pageIndex\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;pageSize\u0026#34;: \u0026#34;10\u0026#34;, } #在抓包工具中：Form Data存放的是post请求的请求参数，而Query String中存放的是get请求的请求参数 url = \u0026#39;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword\u0026#39; #在post请求中，处理请求参数的是data这个参数不是params response = requests.post(url=url,headers=head,data=data) #将响应数据进行反序列化 page_text = response.json() for dic in page_text[\u0026#39;Table1\u0026#39;]: name = dic[\u0026#39;storeName\u0026#39;] addr = dic[\u0026#39;addressDetail\u0026#39;] print(name,addr) 药监总局(作业)\nhttp://scxk.nmpa.gov.cn:81/xk/\n要求：抓取每一家企业的企业详情数据\n下次课程学习：数据解析（正则，xpath，bs4）\n","permalink":"https://canw0916.github.io/en/posts/tech/requests%E5%9F%BA%E7%A1%80/","summary":"爬虫初始 为什么要学习爬虫 之前在授课过程中，好多同学都问过我这样的一个问题：为什么要学习爬虫，学习爬虫能够为我们以后的发展带来那些好处？其实学","title":"Requests基础"},{"content":"强调：前端所有的内容是作为了解，不需要自己能够写出来！\n目的：大致看懂网页的页面源码\n第1章 、Web的基本概念 软件开发的架构 目前我们了解常见应用程序/软件大致可以分为两种： 第一种是应用类：qq、微信、网盘、优酷这一类是属于需要安装的桌面应用 第二种是web类：比如百度、知乎、博客园等使用浏览器访问就可以直接使用的应用 这些应用的本质其实都是两个程序之间的通讯。而这两个分类又对应了两个软件开发的架构： C/S架构 B/S架构 C/S架构 C/S即：Client与Server ，中文意思：客户端与服务器端架构。 我们把提供数据的一方称之为服务器(Server),把访问数据的一方称为客户端(Client) 比如：电脑上要看视频就需要装看视频的程序.例如腾讯视频,它就是客户端程序,腾讯公司的机房里运行着腾讯视频的服务器程序,所以它也是C/S构架的程序 B/S架构 B/S即：Browser与Server,中文意思：浏览器端与服务器端架构。\nBrowser浏览器，其实也是一种Client客户端，只是这个客户端不需要大家去安装什么应用程序，只需在浏览器上通过HTTP请求服务器端相关的资源（网页资源）即可。\n1.1、HTTP协议(大致了解) 1.1.1 、http协议简介 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于万维网（WWW:World Wide Web ）服务器与本地浏览器之间传输超文本的传送协议。\n超文本：超文本就是指“含有指向其他资源链接”内容的文本。大概就是，不仅仅是文字，还有多媒体：视频、图片、动画等。\n协议：HTTP协议就是服务器（Server）和客户端（Client）之间进行数据交互（相互传输数据）的一种协议。我们可以将Server和Client进行拟人化，那么该协议就是Server和Client这两兄弟间指定的一种交互沟通方式。大家都看过智取威虎山中杨子荣和土匪们之间说的黑话吧：\n- 土匪：蘑菇，你哪路？什么价？（什么人？到哪里去？） - 杨子荣：哈！想啥来啥，想吃奶来了妈妈，想娘家的人，孩子他舅舅来了。（找同行） - 杨子荣：拜见三爷！ - 土匪：天王盖地虎！（你好大的胆！敢来气你的祖宗？） - 杨子荣：宝塔镇河妖！（要是那样，叫我从山上摔死，掉河里淹死。） - 土匪：野鸡闷头钻，哪能上天王山！（你不是正牌的。） - 杨子荣：地上有的是米，喂呀，有根底！（老子是正牌的，老牌的。） - 土匪：拜见过阿妈啦？（你从小拜谁为师？） - 杨子荣：他房上没瓦，非否非，否非否！（不到正堂不能说。） - 土匪：嘛哈嘛哈？（以前独干吗？） - 杨子荣：正晌午说话，谁还没有家？（许大马棒山上。） - 土匪：好叭哒！（内行，是把老手） - 杨子荣：天下大耷拉！（不吹牛，闯过大队头。） - 座山雕：脸红什么？ - 杨子荣：精神焕发！ - 座山雕：怎么又黄了？ - 杨子荣：防冷，涂的蜡！ - 座山雕：晒哒晒哒。（谁指点你来的？） - 杨子荣：一座玲珑塔，面向青寨背靠沙！（是个道人。） 是不是看到这里，有得童鞋终于知道了传说中的‘天王盖地虎’是真正含义了吧。此黑话其实就是杨子荣和土匪之间进行交互沟通的方式（协议）。 HTTP于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。HTTP协议工作于客户端-服务端（B/S）架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n1.1.2、 http协议特性 基于请求－响应模式 HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有接收到请求之前不会发送响应\n无连接 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。请思考：双11淘宝平台，一个小时的网站访问量就达到了2亿次，如果一个客户的请求连接耗时1s，那么淘宝是如何实现在一个小时内可以有2亿次的连接访问呢？\n无状态 HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应的相关信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成如此简单的。\n状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。如果会话中产生的数据是我们需要保存的，也就是说要“保持状态”。\n可是,随着Web的不断发展,因无状态而导致业务处理变得棘手的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的其他页面后,也需要能继续保持登录状态。网站为了能够掌握是谁送出的请求,需要保存用户的状态。\nHTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了。有关Cookie的详细内容稍后讲解。\n1.1.3、http请求协议与响应协议 http协议包含由浏览器发送数据到服务器需要遵循的请求协议与服务器发送数据到浏览器需要遵循的响应协议。\n用于HTTP协议交互的信息被称为HTTP报文。请求端(客户端)的HTTP报文叫做请求报文,响应端(服务器端)的叫做响应报文。HTTP报文本身是由多行数据构成的字文本。\n(1) 请求协议 请求头：\n请求头中存储的是该请求的一些主要说明（自我介绍）。服务器据此获取客户端的信息。\naccept:浏览器通过这个头告诉服务器，它所支持的数据类型 Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集 Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式 Accept-Language：浏览器通过这个头告诉服务器，它的语言环境 Host：浏览器通过这个头告诉服务器，想访问哪台主机 If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间 Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的 防盗链 X-Requested-With: XMLHttpRequest 代表通过ajax方式进行访问 User-Agent：请求载体的身份标识 报文体：\n常被叫做请求体，请求体中存储的是将要传输/发送给服务器的数据信息。 请求方式: get与post请求\nGET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以\u0026amp;相连，如EditBook?name=test1\u0026amp;id=123456. POST方法是把提交的数据放在HTTP包的请求体中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有大小限制，且携带的请求数据不可以明文方式连接在url中。 (2) 响应协议 响应头：\n响应头中存储的是该响应的一些主要说明（自我介绍）。客户端据此获取服务器的相关信息。 Location: 服务器通过这个头，来告诉浏览器跳到哪里 Server：服务器通过这个头，告诉浏览器服务器的型号 Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式 Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度 Content-Language: 服务器通过这个头，告诉浏览器语言环境 Content-Type：服务器通过这个头，告诉浏览器回送数据的类型 Refresh：服务器通过这个头，告诉浏览器定时刷新 Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据 Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的 Expires: -1 控制浏览器不要缓存 Cache-Control: no-cache Pragma: no-cache 响应体：\n根据客户端指定的请求信息，发送给客户端的指定数据 响应状态码：\n状态码指的是是当客户端向服务器端发送请求时, 返回的请求结果。借助状态码,用户可以知道服务器端是正常受理了请求,还是出现了什么问题错误 。 1.2、Cookie概述（基本了解） 1.2.1 COOKIE的由来 大家都知道HTTP协议是无状态的。 状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应的相关信息。 一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的，及时同一个客户端发起的多个请求间。随着Web的不断发展,因无状态而导致业务处理变得棘手的情况增多，因此我们需要解决这个问题，也就是说要让http可以“保持状态”，那么Cookie就是在这样一个场景下诞生。 1.2.2 什么是cookie 首先来讲，cookie是浏览器的技术，Cookie具体指的是一段小信息，它是服务器发送出来存储在浏览器上的一组组键值对，可以理解为服务端给客户端的一个小甜点，下次访问服务器时浏览器会自动携带这些键值对，以便服务器提取有用信息。 记住：cookie表示的键值对数据是由服务器创建，且存储在客户端浏览器中。\n1.2.3 cookie的原理 cookie的工作原理是： 浏览器访问服务端，带着一个空的cookie，然后由服务器产生内容，浏览器收到相应后保存在本地； 当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。 cookie的内容是有服务器自主设计的，客户端无法干涉！ 1.2.4 cookie的规范 Cookie大小上限为4KB；\n一个服务器最多在客户端浏览器上保存20个Cookie；\n一个浏览器最多保存300个Cookie，因为一个浏览器可以访问多个服务器。\n上面的数据只是HTTP的Cookie规范，但在浏览器大战的今天，一些浏览器为了打败对手，为了展现自己的能力起见，可能对Cookie规范“扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现把你硬盘占满的可能！\n注意，不同浏览器之间是不共享Cookie的。也就是说在你使用IE访问服务器时，服务器会把Cookie发给IE，然后由IE保存起来，当你在使用FireFox访问服务器时，不可能把IE保存的Cookie发送给服务器。\n第2章 、HTML（大致对标签进行了解即可） 了解了web相关基本概念以后，我们开始正式接触网页开发，网页开发的基础是HTML，所以，本章内容主要是学会如何新建一个 HTML 页面和熟记HTML文档的基本结构和主要标签。\n2.1、 HTML概述 HTML，即超文本标记语言（HyperText Markup Language ]），也可叫做web页面。扩展名是 .html 或是 .htm 。\nHTML，是一种用来制作网页的标准标记语言。超文本，指的就是超出普通文本范畴的文档，可以包含文本、图片、视频、音频、链接等元素。\nHTML 不是一种编程语言，而是一种写给网页浏览器、具有描述性的标记语言。\n也就是说：使用HTML语言描述的文件，需要通过网页浏览器显示出效果。用户在访问网页时，是把服务器的HTML文档下载 到本地客户设备中，然后通过本地客户设备的浏览器将文档按顺序解释渲染成对应的网页效果。\n网页本身是一种文本文件，通过在文本文件中添加各种各样的标记标签，可以告诉浏览器如何显示标记中的代表的内容，如：HTML中有的标签可以告诉浏览器要把字体放大，就像word一样，也有的标签可以告诉浏览器显示指定的图片，还有的标签可以告诉浏览器把内容居中或者倾斜等等。\n每一个HTML标签代表的意义都不一样。同样，他们在浏览器中表现出来的外观也是不一样的。\n2.2、 HTML结构和标签格式 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;123\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1、\u0026lt;!DOCTYPE html\u0026gt; 告诉浏览器使用什么样的解析器来解析html文档\n2、\u0026lt;html\u0026gt;\u0026lt;/html\u0026gt;是文档的开始标记和结束标记。此元素告诉浏览器其自身是一个 HTML 文档，在它们之间是文档的头部\u0026lt;head\u0026gt;和主体\u0026lt;body\u0026gt;。\n3、元素出现在文档的开头部分。与之间的内容不会在浏览器的文档窗口显示，但是其间的元素有特殊重要的意义。\n4、\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;定义网页标题，在浏览器标题栏显示。\n5、\u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;之间的文本是可见的网页主体内容\n6、\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; 声明编码方式用utf8\n2.3、标签的语法 \u0026lt;标签名 属性1=“属性值1” 属性2=“属性值2”……\u0026gt;内容部分\u0026lt;/标签名\u0026gt; \u0026lt;标签名 属性1=“属性值1” 属性2=“属性值2”…… /\u0026gt; 1、HTML标签是由尖括号包围的特定关键词\n2、标签分为闭合和自闭合两种标签\n3、HTML不区分大小写\n4、标签可以有若干个属性,也可以不带属性,比如就不带任何属性\n注意：网页中显示的我们可以看到的数据/内容都只可以存储或者写在标签之间或者属性中！ 2.4、基本标签 标题标签 \u0026lt;h1\u0026gt;标题1\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;标题2\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;标题3\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;标题4\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;标题5\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;标题6\u0026lt;/h6\u0026gt; 段落标签 \u0026lt;p\u0026gt;大家好，我是段落1。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;大家好，我是段落2。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;大家好，我是段落3。\u0026lt;/p\u0026gt; 换行标签 \u0026lt;p\u0026gt;大家好，我是段落标签p。我按了enter一下 换行了\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;大家好，我是段落标签p。我按了enter一下\u0026lt;br/\u0026gt; 换行了\u0026lt;/p\u0026gt; 文本格式化标签 HTML提供了一系列的用于格式化文本的标签，可以让我们输出不同外观的元素，比如粗体和斜体字。如果需要在网页中，需要让某些文本内容展示的效果丰富点，可以使用以下的标签来进行格式化。\n\u0026lt;b\u0026gt;定义粗体文本\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;strong\u0026gt;定义粗体文本方式2\u0026lt;/strong\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;em\u0026gt;定义斜体字\u0026lt;/em\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;i\u0026gt;定义斜体字方式2\u0026lt;/i\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;del\u0026gt;定义删除文本\u0026lt;/del\u0026gt;\u0026lt;br /\u0026gt; 特殊符号 \u0026amp;nbsp; 标签大致可分为两类\n块级标签(block) \u0026ndash; 独占一行 内联标签(inline) \u0026ndash; 按文本内容占位 div和span标签 \u0026lt;div\u0026gt;只是一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现. \u0026lt;span\u0026gt;表示了内联行(行内元素),并无实际的意义,主要通过CSS样式为其赋予不同的表现 块级元素与行内元素的区别：所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。\n2.5、超链接标签 2.5.1、超链接基本使用 超链接是浏览者和服务器的交互的主要手段，也叫超级链接或a链接，是网页中指向一个目标的连接关系，这个目标可以是网页、网页中的具体位置、图片、邮件地址、文件、应用程序等。\n超链接是网页中最重要的元素之一。一个网站的各个网页就是通过超链接关联起来的，用户通过点击超链接可以从一个网页跳转到另一个网页。\n几乎可以在所有的网页中找到链接。点击链接可以从一张页面跳转到另一张页面。例如,在阅读某个网站时，遇到一个不认识的英文，你只要在这个单词上单击一下，即可跳转到它的翻译页面中，看完单词的解释后点一下返回按钮，又可继续阅读，这就是超链接的常见用途。还有经常到购物网站中去，我们都是在百度搜索，然后点击对应的搜索项进入到对应的购物网站的，这也是超链接的作用。超链接的属性：\n属性 值 描述 href 网络链接 [ 例如: http://www.baidu.com ] 本地链接 [ 例如：F:\\html\\index.html ] 规定链接的跳转目标 title 百度 链接的提示信息 target _blank [ 在新建窗口中打开网页 ] _self [ 默认值，覆盖自身窗口打开网页 ] 与前面四项固定值不同，framename是泛指，并不是这个值，这点将在后面框架部分内容中详细介绍，这里可以暂时先略过 1、href是超链接最重要的属性，规定了用户点击链接以后的跳转目标，这个目标可以是 网络连接，也可以是本地连接。\n2、网络链接指的是依靠网络来进行关联的地址，一般在地址前面是以 http://或者https://这样开头的，如果没有网络，则用户点击了超链接也无法访问对应的目标。\n3、本地链接指的是本地计算机的地址，一般在地址前面是以 file:///开头或直接以 C:/、D:/、E:/开头的，不需要经过网络。\n4、如果href的值留空，则默认是跳转到当前页面，也就是刷新当前页面。\n2.6、img标签 在HTML中，图像由标签定义的，它可以用来加载图片到html网页中显示。网页开发过程中，有三种图片格式被广泛应用到web里，分别是 jpg、png、gif。\nimg标签的属性：\n/* src属性： 指定图像的URL地址，是英文source的简写，表示引入资源。 src的值可以是本地计算机存储的图片的地址，也可以是网络上外部网站的图片的地址。 如果src的值不正确，那么浏览器就无法正确的图片，而是显示一张裂图。 alt属性：指定图像无法显示时的替换文本。当图像显示错误时，在图像位置上显示alt的值。如上所示，就是谷歌浏览器中，引入图像失败后，显示了替换文本。 width属性： 指定引入图片的显示宽度。 height属性：指定引入图片的显示高度。 border属性：指定引入图片的边框宽度，默认为0。 title属性：悬浮图片上的提示文字 */ 点击图片跳转可以配合a标签使用\n\u0026lt;a\u0026gt;\u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; 2.7、列表标签 \u0026lt;ul type=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;li\u0026gt;item1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;item2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;item3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol start=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;li\u0026gt;item1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;item2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;item3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 2.8、表格标签 在HTML中使用table来定义表格。网页的表格和办公软件里面的xls一样，都是有行有列的。HTML使用tr标签定义行，使用td标签定义列。\n语法：\n\u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;单元格的内容\u0026lt;/td\u0026gt; …… \u0026lt;/tr\u0026gt; …… \u0026lt;/table\u0026gt; 1、\u0026lt;table\u0026gt;和\u0026lt;/table\u0026gt;表示一个表格的开始和结束。一组\u0026lt;table\u0026gt;...\u0026lt;/table\u0026gt;表示一个表格。\n2、border用于设置整个表格的边框宽度，默认为0，表示不显示边框。\n3、\u0026lt;tr\u0026gt;和\u0026lt;/tr\u0026gt;表示表格中的一行的开始和结束。一组\u0026lt;tr\u0026gt;...\u0026lt;/tr\u0026gt;，一个表格可以有多行。通过计算table标签中包含多少对tr子标签即可知道一个表格有多少行。\n4、\u0026lt;td\u0026gt;和\u0026lt;/td\u0026gt;表示表格中的一个单元格的开始和结束。通过计算一个tr里面包含了多少对td自标签即可知道一个表格有多少列，多少的单元格了。\ntable属性\n属性 值 描述 width px、% 规定表格的宽度。 height px、% 规定表格的高度。 align left、center、right 规定表格相对周围元素的对齐方式。 bgcolor rgb(x,x,x)、#xxxxxx、colorname 规定表格的背景颜色。 background url 规定表格的背景图片。 border px 规定表格边框的宽度。 cellpadding px、% 规定单元格边框与其内容之间的空白。 cellspacing px、% 规定单元格之间的空隙。 td属性\n表格中除了行元素以外，还有单元格，单元格的属性和行的属性类似。td和th都是单元格。\n属性 值 描述 height px、% 规定单元格的高度。 width px、% 规定单元格的宽度。 align left、center、right 规定单元格内容的对齐方式。 valign top、middle、bottom 规定单元格内容的垂直对齐方式。 bgcolor rgb(x,x,x)、#xxxxxx、colorname 规定单元格的背景颜色。 background url 规定单元格的背景图片。 rowspan number 规定单元格合并的行数 colspan number 规定单元格合并的列数 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;i am title\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=1px width=\u0026#34;700\u0026#34; height=\u0026#34;500\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;4\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;5\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;6\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.9、表单标签 表单主要是用来收集客户端提供的相关信息，提供了用户数据录入的方式，有多选、单选、单行文本、下拉列表等输入框，便于网站管理员收集用户的数据，是Web浏览器和Web服务器之间实现信息交流和数据传递的桥梁.\n表单被form标签包含，内部使用不同的表单元素来呈现不同的方式来供用户输入或选择。当用户输入好数据后，就可以把表单数据提交到服务器端。\n一个表单元素有三个基本组成部分：\n表单标签，包含了表单处理程序所在的URL以及数据提交到服务器的方法等表单信息。\n表单域，包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等表单控件。\n表单按钮，包括提交按钮、复位按钮和一般按钮，用于将数据传送到服务器上。\n在HTML中创建表单用form标签。每个表单都可以包含一到多个表单域或按钮。form标签属性：\n属性 值 描述 action 访问服务器地址 服务器端表单处理程序的URL地址 method post、get[默认值] 表单数据的提交方法 target 参考超链接的target属性 表单数据提交时URL的打开方式 enctype application/x-www-form-urlencoded[默认值] multipart/form-data [用于文件上传] text/plain [用于纯文本数据发送] 表单提交数据时的编码方式 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;#\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;label\u0026gt;密码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;label\u0026gt;爱好：\u0026lt;/label\u0026gt; \u0026lt;!-- value属性就是提交给服务器的内容，服务器根据该内容就是到用户选择的是哪一项--\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;lanqiu\u0026#34;\u0026gt;篮球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;zuqiu\u0026#34;\u0026gt;足球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;qumao\u0026#34;\u0026gt;羽毛球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;gaoer\u0026#34;\u0026gt;高尔夫 \u0026lt;br/\u0026gt; \u0026lt;label\u0026gt;性别：\u0026lt;/label\u0026gt; \u0026lt;!-- 单选框的name属性值必须一样，否则无法实现单选--\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;male\u0026#34;\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;female\u0026#34;\u0026gt;女 \u0026lt;br/\u0026gt; \u0026lt;label\u0026gt;生日：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; name=\u0026#34;birthday\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;label\u0026gt;籍贯：\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;jiguan\u0026#34;\u0026gt; \u0026lt;option\u0026gt;请选择籍贯\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;hebei\u0026#34;\u0026gt;河北\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;anhui\u0026#34;\u0026gt;安徽\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;liaoning\u0026#34;\u0026gt;辽宁\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br\u0026gt; \u0026lt;label\u0026gt;自我介绍：\u0026lt;/label\u0026gt; \u0026lt;textarea cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34; placeholder=\u0026#34;请描述\u0026#34; name=\u0026#34;self\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; value=\u0026#34;重置\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 文件上传:必须将文件的二进制形式的数据提交给服务器\n\u0026lt;form action=\u0026#34;#\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传文件\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 2.10、多媒体标签 视频标签：\n\u0026lt;video src=\u0026#34;路径\u0026#34; controls autoplay width=\u0026#34;300px\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; 标签属性： autoplay属性控制是否网页加载自动播放　controls 是否显示播放控件，默认不显示 loop 属性用于控制循环次数，如果值为正整数，则播放指定的次数，如果是 loop 或者是 loop = -1，则无线循环播放。 width 属性设置播放窗口宽度 height 属性设置播放窗口高度 由于版权等原因，不同的浏览器可支持播放的格式是不一样的 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;video src=\u0026#34;https://video.pearvideo.com/mp4/adshort/20211029/cont-1744852-15789500_adpkg-ad_hd.mp4\u0026#34; controls autoplay width=\u0026#34;600px\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 音频标签：\n\u0026lt;audio src=\u0026#34;路径\u0026#34; autoplay=\u0026#34;autoplay\u0026#34; controls=\u0026#34;true\u0026#34; loop=2\u0026gt;\u0026lt;/audio\u0026gt; 标签属性： autoplay属性控制是否网页加载自动播放 controls 是否显示播放控件，默认不显示 loop 属性用于控制循环次数，如果值为正整数，则播放指定的次数，如果是 loop 或者是 loop = -1，则无线循环播放。 由于版权等原因，不同的浏览器可支持播放的格式是不一样的 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;audio src=\u0026#34;https://video.pearvideo.com/mp4/adshort/20211029/cont-1744852-15789500_adpkg-ad_hd.mp4\u0026#34; controls autoplay width=\u0026#34;600px\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第3章 、CSS(大致了解) CSS中文译作“层叠样式表”或者是“级联样式表”，是用于控制网页外观处理并允许将网页的表现与内容分离的一种标记性语言，CSS不需要编译,可以直接由浏览器执行(属于浏览器解释型语言)，是Web网页开发技术的重要组成部分。\n那么接下来，继续看下，使用CSS有什么好处吧。\n使用CSS样式可以有效地对页面进行布局，更加灵活多样。\n使用CSS样式可以对页面字体、颜色、背景和其他效果实现精确控制，同时对它们的修改和控制变得更加快捷，更加强大。\n站点中所有的网页风格都使用一个CSS文件进行统一控制，达到一改全改。还可以快速切换主题，我们可以把HTML比作是骨架，CSS是衣服。同一个HTML骨架结构，不同CSS样式，所得到的美化布局效果不同。\nCSS可以支持多种设备,比如手机,PDA,打印机,电视机,游戏机等。\nCSS可以将网页的表现与结构分离，使页面载入得更快,更利于维护，这也是我们的最终目的。\nCSS基本语法:\nCSS的基本语法由选择器、属性、属性的值组成，如果选择器有多个属性，由分号隔开。\n注意，这里的代码都是英文格式，例如花括号、冒号和分号。\n3.1、CSS的引入方式 嵌入式 嵌入式，是把CSS样式写在HTML文档内部head标签中的style标签里。浏览器加载HTML的同时就已经加载了CSS样式了。当单个文档需要特殊，单独的样式时，可以使用该模式。\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en-US\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;锚点的使用\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf8\u0026#34;\u0026gt; \u0026lt;style\u0026gt; div{ color: white; background-color: #369; text-align: center } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; 嵌入式\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 链接式 链接式，就是把CSS样式写在HTML文档的外部，一个后缀为 .css 的外部样式表中，然后使用时在head标签中，使用link标签的href属性引入文件即可。当CSS样式需要应用在很多页面时，外部样式表是最理想的选择。在使用外部样式表的情况下，我们可以通过改变一个文件来改变这所有页面的外观。\ncommon.css\ndiv{ color: white; background-color: #369; text-align: center } html文件\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en-US\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;锚点的使用\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;common.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;链接式\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3.2、CSS的选择器 3.2.1、基本选择器 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #i1{ color: red; } .c1{ color: red; } .c2{ font-size: 32px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;i1\u0026#34;\u0026gt;item1\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;i2\u0026#34;\u0026gt;item2\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;i3\u0026#34;\u0026gt;item3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;c1 c2\u0026#34;\u0026gt;item4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34;\u0026gt;item5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34;\u0026gt;item6\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3.3、CSS的属性操作 3.3.1、文本属性 font-style（字体样式风格） /* 属性值： normal：设置字体样式为正体。默认值。 italic：设置字体样式为斜体。这是选择字体库中的斜体字。 oblique：设置字体样式为斜体。人为的使文字倾斜，而不是去使用字体库的斜体字。 */ font-weight（字体粗细） /* 属性值： normal：设置字体为正常字体。相当于数字值400 bold：设置字体为粗体。相当于数字值700。 bolder：设置字体为比父级元素字体更粗的字体。 lighter：设置字体为比父级元素字体更细的字体。 number：用数字表示字体粗细。从小到大，越来约粗，取值范围：100、200、300、400、500、600、700、800、900。 注意： font-weight的常用值有两个normal和bold，其他的值在浏览器中的支持并不好。 */ font-size（字体大小） /* font-size的值有很多，有xx-small、x-small、small、medium、large、x-large、xx-large、smaller和larger，也可以设置值为具体的数值加上对应的计算单位来表示字体的大小。字体单位有像素（ px ）、字符（ em，默认1em等于16px，2em等于32px，根据不同浏览器的默认字体大小而决定 ）。 字体不指定大小时，主流浏览器默认是15像素到16像素。旧版本的谷歌浏览器，字体最小只能设置成12像素，新版已经修复。*/ color（字体颜色） // 可以使用color来表示字体的颜色，颜色值最常用的有三种形式，英文单词，十六进制，RGB十进制。 \u0026lt;style\u0026gt; .c1{ color: red; } .c1{ color: #369; } .c1{ color: RGB(0,0,255); } \u0026lt;/style\u0026gt; text-align（文本对齐方式） /* text-align属性可以设置文本内容的水平对齐方式。属性值常用的有 左对齐left、居中对齐center、右对齐right。justify 实现两端对齐文本效果。 */ vertical-align\nvertical-align 属性设置元素的垂直对齐方式。\n3.3.2、背景属性 background-color（背景颜色） 页面的背景颜色有四种属性值表示，分别是transparent（透明），RGB十进制颜色表示，十六进制颜色表示和颜色单词表示。\n属性使用：\n/* background-color: transparent; // 透明 background-color: rgb(255,0,0); // 红色背景 background-color: #ff0000; // 红色背景 background-color: red; // 红色背景 */ background-image（背景图片） background-image可以引入一张图片作为元素的背景图像。默认情况下，background-image放置在元素的左上角，并在垂直和水平方向重复平铺。\n语法：\n// background-image: url(\u0026#39;图片地址\u0026#39;) 当同时定义了背景颜色和背景图像时，背景图像覆盖在背景颜色之上。 所以当背景图片没有被加载到，或者不能完全铺满元素时，就会显示背景颜色。\nbackground-repeat（背景平铺方式） CSS中，当使用图像作为背景了以后，都是默认把整个页面平铺满的，但是有时候在很多场合下面，页面并不需要这种默认的效果，而可能需要背景图像只显示一次，或者只按照指定方式进行平铺的时候，可以使用background-repeat来进行设置。\nbackground-repeat专门用于设置背景图像的平铺方式，一般有四个值，默认是repeat（平铺），no-repeat（不平铺），repeat-x（X轴平铺），repeat-y（Y轴平铺）。\nbackground（背景样式缩写） 多个不同背景样式属性也是可以同时缩写的，背景样式的缩写属性的顺序是不固定的，可以任意编排。\n语法：\n// background: 背景颜色 背景图片 背景平铺方式 背景定位; 3.3.3、边框属性 border-style（边框风格） 定义边框的风格，值可以有\n/* none：没有边框，当border的值为none的时候，系统将会忽略[border-color] hidden：隐藏边框，低版本浏览器不支持。 dotted：点状边框。 dashed：虚线边框。 solid：实线边框。 double：双实线边框，两条单线与其间隔的和等于border-width值。 */ border-style的值可以缩写的：\n/* 只有一个值的时候表示同时控制上下左右的边框风格。 只有两个值的时候表示分别控制上下、左右的边框风格。 有三个值的时候表示分别控制上、左右、下的边框风格。 有四个只的时候表示分别控制上、右、下、左的边框风格。 */ border-style还可以单独指定不同方向：\n/* border-top-style\t设置上边的边框风格 border-bottom-style\t设置下边的边框风格 border-left-style\t设置左边的边框风格 border-right-style\t设置右边的边框风格 */ border-width（边框宽度） 使用border-width可以定义边框的厚度，值可以是medium中等，thin薄，thick厚和指定数值的宽度。 同时，border-width也可以进行缩写：\n/* 只有一个值的时候表示同时控制上下左右的边框宽度。 只有两个值的时候表示分别控制上下、左右的边框宽度。 有三个值的时候表示分别控制上、左右、下的边框宽度。 有四个只的时候表示分别控制上、右、下、左的边框宽度。 */ border-width也可以单独指定不同方向：\n/* border-top-width\t设置上边的边框宽度 border-bottom-width\t设置下边的边框宽度 border-left-width\t设置左边的边框宽度 border-right-width\t设置右边的边框宽度 */ border-color（边框颜色） 定义边框的颜色，值表示的方式可以是十六进制，RGB十进制和单词表示法。\n同上，border-color的缩写：\n/* 只有一个值的时候表示同时控制上下左右的边框颜色。 只有两个值的时候表示分别控制上下、左右的边框颜色。 有三个值的时候表示分别控制上、左右、下的边框颜色。 有四个只的时候表示分别控制上、右、下、左的边框颜色。 */ border-color也可以单独指定不同方向：\n/* border-top-color\t设置上边的边框颜色 border-bottom-color\t设置下边的边框颜色 border-left-color\t设置左边的边框颜色 border-right-color\t设置右边的边框颜色 */ 边框样式缩写 还可以把边框风格，边框宽度，边框颜色进行组合在一起，进行缩写：语法：\n// border: 边框宽度 边框样式 边框颜色; 注意，border的缩写值可以不按照顺序来进行书写。这样的缩写可以同时控制4个方向的边框样式。\n第4章 、JavaScript 4.1、JavaScript 的历史 4.1.1、JavaScript 的历史 1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。但是该浏览器还没有面向大众的普通用户。\n1994年10月，NCSA的一个主要程序员Jim Clark，成立了一家Netscape通信公司。这家公司的方向，就是在Mosaic的基础上，开发面向普通用户的新一代的浏览器Netscape Navigator。\n1994年12月，Navigator发布了1.0版，市场份额一举超过90%。\nNetscape 公司很快发现，Navigator浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为，因为当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。\n管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习。\n1995年5月，Netscape 公司只用了10天，就设计完成了这种语言的第一版。\nNetscape 公司的这种浏览器脚本语言，最初名字叫做 Mocha，1995年9月改为LiveScript。12月，Netscape公司与Sun公司（Java语言的发明者和所有者）达成协议，后者允许将这种语言叫做JavaScript。这样一来，Netscape公司可以借助Java语言的声势，而Sun公司则将自己的影响力扩展到了浏览器，索引并不是因为JavaScript本身与Java语言有多么深的关系才叫做javaScript。\n1996年3月，Navigator 2.0 浏览器正式内置了 JavaScript 脚本语言，也就是可以直接在浏览器中运行JavaScript 脚本语言。\nJS的作用：简单来说可以处理前端的一些简单的业务逻辑和用户行为、网页事件的触发和监听。\n4.2、JS的引入方式 1 直接编写 \u0026lt;script\u0026gt; console.log(\u0026#39;hello yuan\u0026#39;) \u0026lt;/script\u0026gt; 2 导入文件 \u0026lt;script src=\u0026#34;hello.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4.3、JS基本语法 js是一门弱类型的编程语言,属于基于对象和基于原型的脚本语言.\n变量 格式: // 方式1 先声明再赋值 var 变量名; // 声明的变量如果没有进行赋值,或者没有被定义的变量,值默认是undefined 变量名 = 变量值; // 方式2 声明并赋值 var 变量名 = 变量值; // 方式3 一行可以声明多个变量.并且可以是不同类型 var name=\u0026#34;yuan\u0026#34;, age=20, job=\u0026#34;lecturer\u0026#34;; 1、声明变量时 可以不用var. 如果不用var 那么它是全局变量\n2、变量命名,首字符只能是字母,下划线,$美元符 三选一，余下的字符可以是下划线、美元符号或任何字母或数字字符且区分大小写\n注释 // 单行注释 /* 多行注释 */ 语句分隔符 var a = 1; // 分号和换行符作为语句分隔符号 var b = 2; console.log(a,b); 4.4、JS 基本数据类型 4.4.1、数字类型 JavaScript 没有整型和浮点型，只有一种数字类型，即number类型。\nvar x = 10; var y = 3.14; console.log(x,typeof x); // 10 \u0026#34;number\u0026#34; console.log(y,typeof y); // 3.14 \u0026#34;number\u0026#34; 4.4.2、字符串 字符串创建(两种方式)\n变量 = “字符串” 字串对象名称 = new String (字符串) var str1=\u0026#34;hello world\u0026#34;; //推荐 var str1= new String(\u0026#34;hello word\u0026#34;); // 字符串对象的操作 var str = \u0026#34;hello\u0026#34;; // 这就是字符串对象 console.log(str); // 字符串对象内置属性 // length 计算字符串的长度 console.log( str.length ); // 字符串对象内置方法 // toUpperCase(); 字母大写转换 // toLowerCase(); 字母小写转换 console.log( str.toUpperCase() ); console.log( str.toLowerCase() ); // indexOf 获取指定字符在字符串中第一次出现的索引位置 // 字符串也有下标,也可以使用中括号来提取字符串的指定字符 console.log(str[1]); // e console.log( str.indexOf(\u0026#34;e\u0026#34;) ); // 1 // match 正则匹配 // js中也存在正则,正则的使用符号和python里面是一样的 //语法：/正则表达式主体/修饰符(可选) //修饰符： //i:执行对大小写不敏感的匹配。 //g:执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 var str = \u0026#34;我的电话是: 13312345678,你的电话: 13512345678\u0026#34;; var ret = str.match(/\\d{11}/g); // 匹配,提取数据 console.log(ret); // replace 正则替换 var str = \u0026#34;我的电话是: 13512345678\u0026#34;; var ret = str.replace(/(\\d{3})\\d{4}(\\d{4})/,\u0026#34;$1****$2\u0026#34;); // 正则 的 捕获模式 $1$2表示的正则中第一个和第二个小括号捕获的内容 console.log(ret); // search 正则查找,如果查找不到,则返回-1 var str = \u0026#34;hello\u0026#34;; var ret = str.search(/l/); console.log(ret); // 切片,当前方法支持使用负数代表倒数下标 // slice(开始下标) 从开始位置切到最后 // slice(开始下标,结束下标) 从开始下标切到指定位置之前 var str = \u0026#34;helloworld\u0026#34;; var ret = str.slice(3,6); // 开区间,不包含结束下标的内容 console.log(ret); // low var ret = str.slice(5); console.log(ret); // world var ret = str.slice(2,-1); console.log(ret); // lloworl // split 正则分割,经常用于把字符串转换成数组 var str = \u0026#34;广东-深圳-南山\u0026#34;; var ret = str.split(\u0026#34;-\u0026#34;); console.log( ret ); // substr 截取 var str = \u0026#34;hello world\u0026#34;; var ret = str.substr(0,3); console.log(ret); // hel // trim 移除字符串首尾空白 var password = \u0026#34; ge llo \u0026#34;; var ret = password.trim(); console.log(password.length); // 13 console.log(ret.length); // 6 4.4.3、布尔值 1、Boolean类型仅有两个值：true和false，也代表1和0，实际运算中true=1,false=0 2、Boolean值主要用于JavaScript的控制语句\nconsole.log(true); console.log(false); console.log(typeof true); console.log(true == 1); console.log(true + 1); console.log(false + 1); 4.4.4、空值（Undefined和Null） undefined类型 undefined类型只有一个值，即 undefined。\n(1) 当声明的变量未初始化时，该变量的默认值是 undefined。\n(2)当函数无明确返回值时，返回的也是值 undefined;\nnull类型 另一种只有一个值的类型是 null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 js 把它们定义为相等的。\n尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。\n4.4.5、类型转换 js中,类型转换有2种.一种就是强制转换,一种就是自动转换.\n因为js是一门弱类型的脚本语言,所以变量会在运算符的运行要求,有时候根据运算符的要求,进行自动转换的.\n强制转换 // 1. 转换数据为数值类型 // parseInt 把数据转换成整数 // parseFloat 把数据转换成小数 var box1 = \u0026#34;100\u0026#34;; // 转换会成功 var ret = parseInt(box1); console.log(box1); console.log(ret); // var box2 = \u0026#34;3.14\u0026#34;; console.log( parseFloat(box2) ); // 3.14 // 对于转换数值,如果转换失败的话,则结果为 NaN ,是 Not a Number ,但是NaN的类型也是number类型 // 2. 转换数据为字符串 // 变量.toString() // String(数据) var box4 = 3.14; var ret = box4.toString(); console.log(ret); 自动转换 // 所谓的自动转换,其实弱类型中的变量会根据当前代码的需要,进行类型的自动隐式转化 var box1 = 1 + true; // true 转换成数值,是1, false转换成数值,是0 console.log(box1); // 2 var box2 = 1 + \u0026#34;200\u0026#34;; console.log(box2); // ‘1200’ 原因是,程序中+的含义有2种,第一: 两边数值相加, 第二: 两边字符串拼接.但是在js中运算符的优先级中, 字符串拼接的优先级要高于正数 // 值的加减乘除,所以解析器优先使用了+号作为了字符串的拼接符号了,因为程序就需要+号两边都是字符串才能完成运算操作,因此1变成字符串了。最终的结果就是 \u0026#34;1\u0026#34; +\u0026#34;200\u0026#34; var box3 = 1 - \u0026#34;200\u0026#34;; console.log(box3); // -199;因为-号中表示的就是左边的数值减去右边的数值,因此程序就会要求\u0026#34;200\u0026#34;是数值,因此内部偷偷的转换了一下 4.4.6、原始值和引用值 // 初始值类型 var a = \u0026#34;yuan\u0026#34;; var b = a; a = \u0026#34;alvin\u0026#34;; console.log(a);//alvin console.log(b);//yuan // 对象类型 var arr1=[1,2]; arr2 = arr1; arr1.push(3); console.log(arr1)// [1,2,3] console.log(arr2);//[1,2,3] arr1=[4,5]; console.log(arr1);//[4,5] console.log(arr2);//[1,2,3] 4.5、运算符 运算符 /* //算术运算符 + 数值相加 - 数值相减 * 数值相乘 / 数值相除 % 数值求余 ** 数值求幂 a++ 变量被使用后自增1 var a = 10 print(a++) 输出结果为10 print(a) 就是11 ++a 变量被使用前自增1 var b = 10 print(++b) 输出的就是11 b-- 变量被使用后自减1 --b 变量被使用前自减1 //赋值运算符 = += -= *= /= %= **= //比较运算符,比较的结果要么是true, 要么是false \u0026gt; 大于 \u0026lt; 小于 \u0026gt;= 大于或者等于 \u0026lt;= 小于或者等于 != 不等于[计算数值] == 等于[计算] !== 不全等[不仅判断数值,还会判断类型是否一致] === 全等[不仅判断数值,还会判断类型是否一致] //逻辑运算符 \u0026amp;\u0026amp; 并且 and 两边的运算结果为true,最终结果才是true || 或者 or 两边的运算结果为false,最终结果才是false ! 非 not 运算符的结果如果是true,则最终结果是false ,反之亦然. //条件运算符[三目运算符] 条件?true:false 例如: var age = 12; var ret = age\u0026gt;=18?\u0026#34;成年\u0026#34;:\u0026#34;未成年\u0026#34;; console.log(ret); */ 4.6、流程控制语句 编程语言的流程控制分为三种：\n顺序结构(从上向下顺序执行) 分支结构 循环结构 之前我们学习的方式就是顺序执行，即代码的执行从上到下，一行行分别执行。\n例如：\nconsole.log(\u0026#34;星期一\u0026#34;); console.log(\u0026#34;星期二\u0026#34;); console.log(\u0026#34;星期三\u0026#34;); 4.6.1、分支结构 if 分支语句 if(条件){ // 条件为true时,执行的代码 } if(条件){ // 条件为true时,执行的代码 }else{ // 条件为false时,执行的代码 } if(条件1){ // 条件1为true时,执行的代码 }else if(条件2){ // 条件2为true时,执行的代码 }.... }else{ // 上述条件都不成立的时候,执行的代码 } switch语句 switch(条件){ case 结果1: 满足条件执行的结果是结果1时,执行这里的代码.. break; case 结果2: 满足条件执行的结果是结果2时,执行这里的代码.. break; ..... default: 条件和上述所有结果都不相等时,则执行这里的代码 } switch(\u0026#39;a\u0026#39;): case 1: //只会会执行case 1下面的xxx代码 xxx break; case 2: xxx break; default: xxx break 1、switch比if else更为简洁\n2、执行效率更高。switch…case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch…case不用像if…else那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。\n3、到底使用哪一个选择语句，代码环境有关，如果是范围取值，则使用if else语句更为快捷；如果是确定取值，则使用switch是更优方案。\n4.6.2、循环语句 while循环 while(循环的条件){ // 循环条件为true的时候,会执行这里的代码 } 循环案例：\nvar count = 0 while (count\u0026lt;10){ console.log(count); count++; } for循环 // 循环三要素 for(1.声明循环的开始; 2.条件; 4. 循环的计数){ // 3. 循环条件为true的时候,会执行这里的代码 } for(循环的成员下标 in 被循环的数据){ // 当被循环的数据一直没有执行到最后下标,都会不断执行这里的代码 } 循环案例：\n// 方式1 for (var i = 0;i\u0026lt;10;i++){ console.log(i) } // 方式2 var arr = [111,222,333] for (var i in arr){ console.log(i,arr[i]) } 退出循环（break和continue） for (var i = 0;i\u0026lt;100;i++){ if (i===88){ continue // 退出当次循环 // break // 退出当前整个循环 } console.log(i) } 作业：\n（1）计算1+2+3+\u0026hellip;+100=？\n（2）求20的阶乘值\n4.7、数组对象 创建数组 创建方式1: var arrname = [元素0,元素1,….]; // var arr=[1,2,3]; 创建方式2: var arrname = new Array(元素0,元素1,….); // var test=new Array(100,\u0026#34;a\u0026#34;,true); 数组方法 var arr = [\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;]; // 内置属性 console.log( arr.length ); // 获取指定下标的成员 console.log( arr[3] ); // D console.log( arr[arr.length-1] ); // 最后一个成员 // (1) pop() 出栈,删除最后一个成员作为返回值 var arr = [1,2,3,4,5]; var ret = arr.pop(); console.log(arr); // [1, 2, 3, 4] console.log(ret); // 5 // (2) push() 入栈,给数组后面追加成员 var arr = [1,2,3,4,5]; arr.push(\u0026#34;a\u0026#34;); console.log(arr); // [1, 2, 3, 4, 5, \u0026#34;a\u0026#34;] // (3) shift是将数组的第一个元素删除 var arr = [1,2,3,4,5]; arr.shift() console.log(arr); // [2, 3, 4, 5] // (4) unshift是将value值插入到数组的开始 var arr = [1,2,3,4,5]; arr.unshift(\u0026#34;yuan\u0026#34;) console.log(arr); // [\u0026#34;yuan\u0026#34;,1,2, 3, 4, 5] // (5) reverse() 反转排列 var arr = [1,2,3,4,5]; arr.reverse(); console.log(arr); // [5, 4, 3, 2, 1] // (6) slice(开始下标,结束下标) 切片,开区间 var arr = [1,2,3,4,5]; console.log(arr.slice(1,3)); // (7) concat() 把2个或者多个数组合并 var arr1 = [1,2,3]; var arr2 = [4,5,7]; var ret = arr1.concat(arr2); console.log( ret ); // (8) join() 把数组的每一个成员按照指定的符号进行拼接成字符串 var str = \u0026#34;广东-深圳-南山\u0026#34;; var arr = str.split(\u0026#34;-\u0026#34;); console.log( arr ); // [\u0026#34;广东\u0026#34;, \u0026#34;深圳\u0026#34;, \u0026#34;南山\u0026#34;]; var arr1 = [\u0026#34;广东\u0026#34;, \u0026#34;深圳\u0026#34;, \u0026#34;南山\u0026#34;]; var str1 = arr1.join(\u0026#34;-\u0026#34;); console.log( str1 ); // 广东-深圳-南山 遍历数组 var arr = [12,23,34] for (var i in arr){ console.log(i,arr[i]) } 4.8、Object对象 8.1、object对象的基本操作 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。 创建 Object 实例的方式有两种。\nvar person = new Object(); person.name = \u0026#34;alvin\u0026#34;; person.age = 18; 另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的person 对象：\nvar person = { name : \u0026#34;alvin\u0026#34;, age : 18, say: function(){ alert(123); } }; object可以通过. 和 []来访问。 console.log(person[\u0026#34;age\u0026#34;]); console.log(person.age) object可以通过for循环遍历 for (var attr in person){ console.log(attr,person[attr]); } 或者：\nfunction People(name, age){ this.name = name; this.age = age; this.chi = function(){ console.log(this.name, \u0026#34;在吃东西\u0026#34;) } } p1 = new People(\u0026#34;alex\u0026#34;, 18); p2 = new People(\u0026#34;wusir\u0026#34;, 20); p1.chi(); p2.chi(); 8.2、json序列化和反序列化 JSON：JavaScript 对象表示法，是一种轻量级的数据交换格式。易于人阅读和编写。\n// json是一种数据格式, 语法一般是{}或者[]包含起来 // 内部成员以英文逗号隔开,最后一个成员不能使用逗号! // 可以是键值对,也可以是列表成员 // json中的成员如果是键值对,则键名必须是字符串.而json中的字符串必须使用双引号圈起来 // json数据也可以保存到文件中,一般以\u0026#34;.json\u0026#34;结尾. { \u0026#34;name\u0026#34;: \u0026#34;xiaoming\u0026#34;, \u0026#34;age\u0026#34;:12 } [1,2,3,4] { \u0026#34;name\u0026#34;: \u0026#34;xiaoming\u0026#34;, \u0026#34;age\u0026#34;:22, \u0026#34;sex\u0026#34;: true, \u0026#34;son\u0026#34;: { \u0026#34;name\u0026#34;:\u0026#34;xiaohuihui\u0026#34;, \u0026#34;age\u0026#34;: 2 }, \u0026#34;lve\u0026#34;: [\u0026#34;篮球\u0026#34;,\u0026#34;唱\u0026#34;,\u0026#34;跳\u0026#34;] } js中也支持序列化和反序列化的方法：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // js对象,因为这种声明的对象格式很像json,所以也叫json对象 var data = { name: \u0026#34;xiaoming\u0026#34;, age: 22, say: function(){ alert(123); } }; // 把对象转换成json字符串 var ret = JSON.stringify(data); console.log(ret ); // {\u0026#34;name\u0026#34;:\u0026#34;xiaoming\u0026#34;,\u0026#34;age\u0026#34;:22} // 把json字符串转换成json对象 var str = `{\u0026#34;name\u0026#34;:\u0026#34;xiaoming\u0026#34;,\u0026#34;age\u0026#34;:22}`; var ret = JSON.parse(str); console.log(ret); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.9、Date对象 创建Date对象 //方法1：不指定参数 var nowd1=new Date(); //获取当前时间 console.log(nowd1); console.log(nowd1.toLocaleString( )); //方法2：参数为日期字符串 var d2=new Date(\u0026#34;2004/3/20 11:12\u0026#34;); console.log(d2.toLocaleString( )); var d3=new Date(\u0026#34;04/03/20 11:12\u0026#34;); console.log(d3.toLocaleString( )); 获取时间信息 获取日期和时间 getDate() 获取日 getDay () 获取星期 getMonth () 获取月（0-11） getFullYear () 获取完整年份 getHours () 获取小时 getMinutes () 获取分钟 getSeconds () 获取秒 getMilliseconds () 获取毫秒 4.10、Math对象 // Math对象的内置方法 // abs(x) 返回数值的绝对值 var num = -10; console.log( Math.abs(num) ); // 10 // ceil(x) 向上取整 var num = 10.3; console.log( Math.ceil(num) ); // 11 // floor(x) 向下取整 var num = 10.3; console.log( Math.floor(num) ); // 10 // max(x,y,z,...,n) console.log( Math.max(3,56,3) ); // 56 // min(x,y,z,...,n) // random() 生成0-1随机数 console.log( Math.random() ); // 生成0-10之间的数值 console.log( Math.random() * 10 ); // round(x) 四舍五入 // 生成0-10之间的整数 console.log( Math.round( Math.random() * 10 ) ); 4.11、Function 对象 函数在程序中代表的就是一段具有功能性的代码，可以让我们的程序编程更加具有结构性和提升程序的复用性,也能让代码变得更加灵活强大\n4.11.1、声明函数 /* // 函数的定义方式1 function 函数名 (参数){ 函数体; return 返回值; } 功能说明： 可以使用变量、常量或表达式作为函数调用的参数 函数由关键字function定义 函数名的定义规则与标识符一致，大小写是敏感的 返回值必须使用return // 函数的定义方式2 用 Function 类直接创建函数的语法如下： var 函数名 = new Function(\u0026#34;参数1\u0026#34;,\u0026#34;参数n\u0026#34;,\u0026#34;function_body\u0026#34;); 虽然由于字符串的关系，第二种形式写起来有些困难，但有助于理解函数只不过是一种引用类型*/ 4.11.2、函数调用 //f(); ---\u0026gt;OK function f(){ console.log(\u0026#34;hello\u0026#34;) } f() //-----\u0026gt;OK 不同于python，js代码在运行时，会分为两大部分———检查装载 和 执行阶段。\n检查装载阶段：会先检测代码的语法错误，进行变量、函数的声明 执行阶段：变量的赋值、函数的调用等，都属于执行阶段。 4.11.3、函数参数 （1） 参数基本使用\n// 位置参数 function add(a,b){ console.log(a); console.log(b); } add(1,2) add(1,2,3) add(1) // 默认参数 function stu_info(name,gender=\u0026#34;male\u0026#34;){ console.log(\u0026#34;姓名：\u0026#34;+name+\u0026#34; 性别：\u0026#34;+gender) } stu_info(\u0026#34;yuan\u0026#34;) 4.11.4、函数返回值 在函数体内，使用 return 语句可以设置函数的返回值。一旦执行 return 语句，将停止函数的运行，并运算和返回 return 后面的表达式的值。如果函数不包含 return 语句，则执行完函数体内每条语句后，返回 undefined 值。\nfunction add(x,y) { return x,y } var ret = add(2,5); console.log(ret) 1、在函数体内可以包含多条 return 语句，但是仅能执行一条 return 语句\n2、函数的参数没有限制，但是返回值只能是一个；如果要输出多个值，可以通过数组或对象进行设计。\n4.11.5、函数作用域 作用域是JavaScript最重要的概念之一。\nJavaScript中，变量的作用域有全局作用域和局部作用域两种。\n// 局部变量,是在函数内部声明,它的生命周期在当前函数被调用的时候, 当函数调用完毕以后,则内存中自动销毁当前变量 // 全局变量,是在函数外部声明,它的生命周期在当前文件中被声明以后就保存在内存中,直到当前文件执行完毕以后,才会被内存销毁掉 首先熟悉下var\nvar name = \u0026#34;yuan\u0026#34;; // 声明一个全局变量 name并赋值”yuan“ name = \u0026#34;张三\u0026#34;; // 对已经存在的变量name重新赋值 ”张三“ console.log(name); var gender = \u0026#34;male\u0026#34; var gender = \u0026#34;female\u0026#34; // 原内存释放与新内存开辟，指针指向新开辟的内存 console.log(gender) 作用域案例：\nvar num = 10; // 在函数外部声明的变量, 全局变量 function func(){ //千万不要再函数内部存在和全局变量同名的变量 num = 20; // 函数内部直接使用变量,则默认调用了全局的变量, } func(); console.log(\u0026#34;全局num：\u0026#34;,num); 4.11.6、匿名函数 匿名函数，即没有变量名的函数。在实际开发中使用的频率非常高！也是学好JS的重点。\n// 匿名函数赋值变量 var foo = function () { console.log(\u0026#34;这是一个匿名函数！\u0026#34;) }; foo() //调用匿名函数 // 匿名函数的自执行 (function (x,y) { console.log(x+y); })(2,3) // 匿名函数作为一个高阶函数使用 function bar() { return function () { console.log(\u0026#34;inner函数！\u0026#34;) } } bar()() 4.12、BOM对象（了解） BOM:Broswer object model,即浏览器提供我们开发者在javascript用于操作浏览器的对象。\n4.12.1、window对象 窗口方法 // BOM Browser object model 浏览器对象模型 // window是js中最大的一个对象.整个浏览器窗口出现的所有东西都是window对象的内容. console.log( window ); // alert() 弹出一个警告框 window.alert(\u0026#34;hello\u0026#34;); //confirm 弹出一个确认框,点击确认,返回true, 点击取消,返回false var ret = confirm(\u0026#34;您确认要删除当前文件么?\u0026#34;); console.log( ret ); // 弹出一个消息输入框,当点击确认以后,则返回可以接收到用户在输入框填写的内容.如果点击取消,则返回null var ret = prompt(\u0026#34;请输入一个内容\u0026#34;,\u0026#34;默认值\u0026#34;); console.log( ret ); // close() 关闭当前浏览器窗口 window.close(); //打开一个新的浏览器窗口 window.open(\u0026#34;http://www.baidu.com\u0026#34;,\u0026#34;_blank\u0026#34;,\u0026#34;width=800px,height=500px,left=200px,top=200px\u0026#34;); 4.13、DOM对象(了解) DOM document Object Model 文档对象模型\n// 整个html文档,会保存一个文档对象document // console.log( document ); // 获取当前文档的对象 4.13.1、查找标签 直接查找标签 document.getElementsByTagName(\u0026#34;标签名\u0026#34;) document.getElementById(\u0026#34;id值\u0026#34;) document.getElementsByClassName(\u0026#34;类名\u0026#34;) //返回dom对象，就是标签对象或者数组 CSS选择器查找 document.querySelector(\u0026#34;css选择器\u0026#34;) //根据css选择符来获取查找到的第一个元素，返回标签对象（dom对象） document.querySelectorAll(\u0026#34;css选择器\u0026#34;); // 根据css选择符来获取查找到的所有元素,返回数组 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;i1\u0026#34;\u0026gt;DIV1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34;\u0026gt;DIV\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34;\u0026gt;DIV\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34;\u0026gt;DIV\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34;\u0026gt;item\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;c2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c3\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;c4\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;c5\u0026#34; id=\u0026#34;i2\u0026#34;\u0026gt;111\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;222\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;333\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 直接查找 var ele = document.getElementById(\u0026#34;i1\u0026#34;); // ele就是一个dom对象 console.log(ele); var eles = document.getElementsByClassName(\u0026#34;c1\u0026#34;); // eles是一个数组 [dom1,dom2,...] console.log(eles); var eles2 = document.getElementsByTagName(\u0026#34;div\u0026#34;); // eles2是一个数组 [dom1,dom2,...] console.log(eles2); //定位outer下的c1对应的标签 var outer = document.getElementsByClassName(\u0026#34;outer\u0026#34;)[0]; var te = outer.getElementsByClassName(\u0026#34;c1\u0026#34;); console.log(te); // css选择器 //层级定位(空格可以表示一个或多个层级) var dom = document.querySelector(\u0026#34;.c2 .c3 .c5\u0026#34;); console.log(\u0026#34;:::\u0026#34;,dom); //层级定位 var doms = document.querySelectorAll(\u0026#34;ul li\u0026#34;); console.log(\u0026#34;:::\u0026#34;,doms); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.13.2、绑定事件 静态绑定 ：直接把事件写在标签元素中 \u0026lt;div id=\u0026#34;div\u0026#34; onclick=\u0026#34;foo()\u0026#34;\u0026gt;click\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function foo(){ console.log(\u0026#34;foo函数\u0026#34;); } \u0026lt;/script\u0026gt; 动态绑定：在js中通过代码获取元素对象,然后给这个对象进行后续绑定 \u0026lt;p id=\u0026#34;i1\u0026#34;\u0026gt;试一试!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; var ele=document.getElementById(\u0026#34;i1\u0026#34;); ele.onclick=function(){ console.log(\u0026#34;ok\u0026#34;); }; \u0026lt;/script\u0026gt; 一个元素本身可以绑定多个不同的事件, 但是如果多次绑定同一个事件,则后面的事件代码会覆盖前面的事件代码\n在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。\n单独使用 this，则它指向全局(Global)对象。在浏览器中，window 就是该全局对象为 [object Window]:\nvar x = this; 在函数中，函数的所属者/调用者默认绑定到 this 上。\nfunction myFunction() { return this; } 对象方法中的this就是对象本身\nvar person = { firstName : \u0026#34;John\u0026#34;, lastName : \u0026#34;Doe\u0026#34;, id : 5566, myFunction : function() { return this; } }; 事件中的this就是接收事件的 HTML 标签\n\u0026lt;button onclick=\u0026#34;this.style.display=\u0026#39;none\u0026#39;\u0026#34;\u0026gt; 点我后我就消失了 \u0026lt;/button\u0026gt; 4.14 进阶操作（重点） ES6新特性\nES6是JavaScript语言的下一代标准，已经在2015年6月正式发布了。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0。 变量提升\n查看以下代码, 是否可以被运行\nfunction fn(){ console.log(name); var name = \u0026#39;大马猴\u0026#39;; } fn() 发现问题了么. 这么写代码, 在其他语言里. 绝对是不允许的. 但是在js里. 不但允许, 还能执行. 为什么呢? 因为在js执行的时候. 它会首先检测你的代码. 发现在代码中会有name使用. OK. 运行时就会变成这样的逻辑:\nfunction fn(){ var name; console.log(name); name = \u0026#39;大马猴\u0026#39;; } fn(); 看到了么. 实际运行的时候和我们写代码的顺序可能会不一样\u0026hellip;.这种把变量提前到代码块第一部分运行的逻辑被称为变量提升. 这在其他语言里是绝对没有的. 并且也不是什么好事情. 正常的逻辑不应该是这样的. 那么怎么办? 在新的ES6中. 就明确了, 这样使用变量是不完善的. es6提出. 用let来声明变量. 就不会出现该问题了.\nfunction fn(){ console.log(name); // 直接报错, let变量不可以变量提升. let name = \u0026#39;大马猴\u0026#39;; } fn() 用let声明变量是新版本javascript提倡的一种声明变量的方案 let还有哪些作用呢?\nfunction fn(){ var name = \u0026#34;周杰伦\u0026#34;; var name = \u0026#34;王力宏\u0026#34;; console.log(name); } fn() 显然一个变量被声明了两次. 这样也是不合理的. var本意是声明变量. 同一个东西. 被声明两次. 所以ES6规定. let声明的变量. 在同一个作用域内. 只能声明一次.\nfunction fn(){ let name = \u0026#34;周杰伦\u0026#34;; console.log(name); let name = \u0026#34;王力宏\u0026#34;; console.log(name); } fn() 注意, 报错是发生在代码检查阶段. 所以. 上述代码根本就执行不了. 在同一个作用域内. let声明的变量只能声明一次. 其他使用上和var没有差别.\neval函数\neval本身在js里面正常情况下使用的并不多. 但是很多网站会利用eval的特性来完成反爬操作. 我们来看看eval是个什么鬼?\n从功能上讲, eval非常简单. 它可以动态的把字符串当成js代码进行运行.\ns = \u0026#34;console.log(\u0026#39;我爱你\u0026#39;)\u0026#34;; eval(s); 也就是说. eval里面传递的应该是即将要执行的代码(字符串). 那么在页面中如果看到了eval加密该如何是好? 其实只要记住了一个事儿. 它里面不论多复杂. 一定是个字符串.\n比如:\neval(function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026#39;\u0026#39;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!\u0026#39;\u0026#39;.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return\u0026#39;\\\\w+\u0026#39;};c=1};while(c--)if(k[c])p=p.replace(new RegExp(\u0026#39;\\\\b\u0026#39;+e(c)+\u0026#39;\\\\b\u0026#39;,\u0026#39;g\u0026#39;),k[c]);return p}(\u0026#39;0.1(\\\u0026#39;我爱你\\\u0026#39;)\u0026#39;,62,2,\u0026#39;console|log\u0026#39;.split(\u0026#39;|\u0026#39;),0,{})) 这一坨看起来, 肯定很不爽. 怎么变成我们看着很舒服的样子呢? 记住. eval()里面是字符串. 记住~!!\n那我想看看这个字符串长什么样? 就把eval()里面的东西拷贝出来. 执行一下. 最终一定会得到一个字符串. 要不然eval()执行不了的. 对不\u0026hellip;于是就有了下面的操作.\nhttp://tools.jb51.net/password/evalencode, 在赠送你一个在线JS处理eval的网站. 大多数的eval加密. 都可以搞定了.\nprototype(忽略)\nprototype是js里面给类增加功能扩展的一种模式.\n写个类看看\nfunction People(name, age){ this.name = name; this.age = age; this.run = function(){ console.log(this.name+\u0026#34;在跑\u0026#34;) } } p1 = new People(\u0026#34;张三\u0026#34;, 18); p2 = new People(\u0026#34;李四\u0026#34;, 19); p1.run(); p2.run(); 我现在代码写完了. 突然之间, 我感觉好像少了个功能. 人不应该就一个功能. 光会吃是不够的. 还得能够睡. 怎么办? 直接改代码? 可以. 但不够好. 如果这个类不是我写的呢? 随便改别人代码是很不礼貌的. 也很容易出错. 怎么办? 我们可以在我们自己代码中对某个类型动态增加功能. 此时就用到了prototype.\nfunction People(name, age){ this.name = name; this.age = age; this.run = function(){ console.log(this.name+\u0026#34;在跑\u0026#34;) } } // 通过prototype可以给People增加功能 People.prototype.sleep = function(){ console.log(this.name+\u0026#34;还可以sleep\u0026#34;); } p1 = new People(\u0026#34;张三\u0026#34;, 18); p2 = new People(\u0026#34;李四\u0026#34;, 19); p1.run(); p2.run(); p1.sleep(); p2.sleep(); 内置对象：window\nwindow对象是一个很神奇的东西. 你可以把这东西理解成javascript全局的内置对象. 如果我们默认不用任何东西访问一个标识符. 那么默认认为是在用window对象.\nwindow.mm = \u0026#34;爱你\u0026#34; //定义了一个全局变量 console.log(mm); 综上, 我们可以得出一个结论. 全局变量可以用window.xxx来表示.\nok. 接下来. 注意看了. 我要搞事情了\n想要在函数外部调用该函数内部定义的一个内置函数，不可使用返回值的机制，如何实现？ (function(){ let chi = function(){ console.log(\u0026#34;我是吃\u0026#34;) } window.w_chi = chi //全局变量chi })(); //如何调用 w_chi() //chi() //换一种写法. 你还认识么? (function(w){ let chi = function(){ console.log(\u0026#34;我是吃\u0026#34;) } w.chi = chi })(window); chi() call和apply(忽略)\n对于咱们逆向工程师而言. 并不需要深入的理解call和apply的本质作用. 只需要知道这玩意执行起来的逻辑顺序是什么即可。\n在运行时. 正常的js调用:\nfunction People(name, age){ this.name = name; this.age = age; this.chi = function(what_1, what_2){ console.log(this.name, \u0026#34;在吃\u0026#34;, what_1, what_2) } } p1 = new People(\u0026#34;alex\u0026#34;, 18); p2 = new People(\u0026#34;wusir\u0026#34;, 20); p1.chi(\u0026#34;馒头\u0026#34;, \u0026#34;大饼\u0026#34;); p2.chi(\u0026#34;大米饭\u0026#34;, \u0026#34;金坷垃\u0026#34;); 接下来, 我们可以使用call和apply也完成同样的函数调用\nfunction People(name, age){ this.name = name; this.age = age; this.chi = function(what_1, what_2){ console.log(this.name, \u0026#34;在吃\u0026#34;, what_1, what_2); } } p1 = new People(\u0026#34;alex\u0026#34;, 18); p2 = new People(\u0026#34;wusir\u0026#34;, 20); function eat(what_1, what_2){ console.log(this.name, \u0026#34;在吃\u0026#34;, what_1, what_2); } eat.call(p1, \u0026#34;馒头\u0026#34;, \u0026#34;大饼\u0026#34;); eat.call(p2, \u0026#34;大米饭\u0026#34;, \u0026#34;金坷垃\u0026#34;); // call的语法是: 函数名.call(对象, 参数1, 参数2, 参数3....) // 执行逻辑是: 执行函数. 并把对象传递给函数中的this. 其他参数照常传递给函数 apply和他几乎一模一样. 区别是: apply传递参数要求是一个数组\neat.apply(p1, [\u0026#34;苞米茬子\u0026#34;, \u0026#34;大饼子\u0026#34;]); ES6中的箭头函数\n在ES6中简化了函数的声明语法.\nvar fn = function(){let num=10}; var fn = () =\u0026gt; {let num=10}; var fn = function(name){} var fn = name =\u0026gt; {} var fn = (name) =\u0026gt; {} var fn = function(name, age){} var fn = (name, age) =\u0026gt; {} 第5章 、jQuery 5.1、jQuery介绍 jQuery是什么 jQuery是一个快速、简洁的JavaScript框架。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理等功能。\njQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等\njQuery的版本 目前在市场上, 1.x , 2.x, 3.x 功能的完善在1.x, 2.x的时候是属于删除旧代码,去除对于旧的浏览器兼容代码。3.x的时候增加es的新特性以及调整核心代码的结构\njQuery的引入 根本上jquery就是一个写好的js文件,所以想要使用jQuery的语法必须先引入到本地\n\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 5.2、jQuery的选择器 5.2.1、直接查找 基本选择器 /* #id # id选择符 element # 元素选择符 .class # class选择符 selector1, selector2, selectorN # 同时获取多个元素的选择符 jQ选择器： $(\u0026#34;#id\u0026#34;) == document.getElementById(\u0026#39;id\u0026#39;) $(\u0026#34;.class\u0026#34;) $(\u0026#34;element\u0026#34;) $(\u0026#34;.class,p,div\u0026#34;) */ 5.3、jQuery的事件绑定 /* 用法: 直接通过事件名来进行调用 $().事件名(匿名函数) */ 案例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;d1\u0026#34;\u0026gt;i am div tag\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;t\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(\u0026#39;#d1\u0026#39;).click(function () { window.alert(\u0026#39;点击了div标签！\u0026#39;) }) $(\u0026#39;#t\u0026#39;).blur(function () { window.alert(\u0026#39;写完了吗？\u0026#39;) }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 5.4 Ajax请求 什么是ajax？\nAJAX = 异步的javascript和XML（Asynchronous Javascript and XML）\n它不是一门编程语言，而是利用JavaScript在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。\n对于传统的网页，如果想更新内容，那么必须要刷新整个页面，但有了Ajax，便可以在页面不被全部刷新的情况下更新其内容。在这个过程中，页面实际上是在后台与服务器进行了数据交互，获得数据之后，再利用JavaScript改变页面，这样页面内容就会更新了。（微博页面加载过程的例子，加载一会下方才会出现内容，这其实就是Ajax加载的过程。）\n简言之，在不重载整个网页的情况下，AJAX通过后台加载数据，并在网页上进行显示。\n通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。\n//get()方式 $.ajax({ url:\u0026#39;./data/index.txt\u0026#39;, type:\u0026#39;get\u0026#39;, dataType:\u0026#39;text\u0026#39;, success:function(data){ $(\u0026#39;p\u0026#39;).html(data); }, error:function(error){ console.log(error) } //post()方式 $.ajax({ url:\u0026#39;/index\u0026#39;, type:\u0026#39;post\u0026#39;, data:{name:\u0026#39;张三\u0026#39;,age:12}, success:function(data){ $(\u0026#39;p\u0026#39;).html(data); }, error:function(error){ console.log(error) } ","permalink":"https://canw0916.github.io/en/posts/tech/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","summary":"强调：前端所有的内容是作为了解，不需要自己能够写出来！ 目的：大致看懂网页的页面源码 第1章 、Web的基本概念 软件开发的架构 目前我们了解常见应用","title":"前端基础"},{"content":"并发编程（并发，并行，同步，异步） 通俗理解并发编程中的相关核心概念 核心概念：进程、线程和互斥锁\nCPU的作用\n计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 CPU的核数 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单核CPU一次只能运行一个任务。这个任务是什么呢？ 进程 就好比工厂的车间，它代表CPU所能处理的单个任务。\n任意时刻，CPU总是运行一个进程，其他进程处于非运行状态。\n基于车间来聊：\n一个车间里，可以有很多工人。他们协同完成一个任务。\n线程 就好比车间里的工人。一个进程可以包括多个线程。\n车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是被线程共享的，每个线程都可以使用这些共享内存。\n基于进程空间可以被线程共享的角度\u0026mdash;思考：\n每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。那么如何实现呢？\n一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫**\u0026ldquo;互斥锁\u0026rdquo;**，其作用是防止多个线程同时读写某一块内存区域。\n进程 什么是进程 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 在操作系统中，每启动一个应用程序其实就是OS开启了一个进程且为进程分类对应的内存/资源，应用程序的执行也就是进程在执行。 狭义定义：一个正在运行的应用程序在操作系统中被视为一个进程 举例： 我们有py1文件中和py2文件，两个文件运行起来后是两个进程。 进程调度 提问：\n进程就是计算机中正在运行的一个程序或者软件，并且在上述工厂案例中，我们说单个CPU一次只能运行一个任务，那么你有没有在电脑上一边聊微信一边听音乐一边打游戏的场景啊？why？ 是因为CPU在交替运行多个进程。 要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随机进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。\n目前已实现的调度算法有：先来先服务（FCFS）调度算法、短作业优先调度算法和时间片轮转法。不过被公认的一种比较好的进程调度算法是\u0026quot;时间片轮转法\u0026quot;。 \u0026#34;时间片轮转法\u0026#34;调度算法的实施过程如下所述。 (1) os会创建多个就绪队列存储进程，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，以此类推。并且该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先级愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍 (2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地排队等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列。 (3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果os正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的服务，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。 并发与并行 通过进程之间的调度，也就是进程之间的切换，我们用户感知到的好像是两个视频文件同时在播放，或者音乐和游戏同时在进行，那就让我们来看一下什么叫做并发和并行。\n无论是并行还是并发，在用户看来都是\u0026rsquo;同时\u0026rsquo;运行的，不管是进程还是线程，都只是一个任务而已，真实干活的是cpu，而一个cpu同一时刻只能执行一个任务。\n**并行：**同时运行，只有具备多个cpu才能实现并行\n**并发：**是伪并行，即看起来是同时运行。\n举例说明\n你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。\n总结\n并发的关键是你有处理多个任务的能力，不一定要同时。\n并行的关键是你有同时处理多个任务的能力。\n所以它们最关键的点就是：是否是『同时』。\n进程的状态 在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行、阻塞和终止。\n就绪(Ready)状态\n进程已经准备好，已分配到所需资源/内存。 执行/运行（Running）状态\n进程处于就绪状态被调度后，进程进入执行状态 阻塞(Blocked)状态\n正在执行的进程由于某些事件（I/O请求,input,申请缓存区失败）而暂时无法运行，进程受到阻塞,则进入就绪状态等待系统调用 终止状态\n进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行 同步和异步 举个例子来说，你去商场买手机的时候正好口渴了。\n同步的意思就是说，你和店员说你看上这部手机了，然后店员去仓库拿货，你在店里等待店员回来后再去买水喝。\n异步呢，异步的意思就是在店员去仓库拿货的时候，你趁机去买水喝，然后喝完水后，刚好店员也带着你的新手机回来了。\n使用方法的调用来举例：\n同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续该方法后续的行为代码。 异步方法调用更像一个消息传递，一旦调用开始，该方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程/进程中，“真实”地执行着。整个过程，不会阻碍调用者的工作 注意：同步和异步针对是cup遇到阻塞操作时，所产生的不同行为！\n思考：异步操作是基于并行的还是基于并发的？\n异步可以是基于并行的也可以是基于并发的，但是大部分情况下是基于并发的。 - 基于并发是指，在方法调用开始的时候，启动另一个进程/线程执行方法后序的操作，而当前的进程/线程执行该方法内部的操作。则当前进程/线程和启动的另一个新的进程/线程是基于cpu的调度算法，调度执行的。 基于并行是指，在多核情况下，如果应用程序执行过程中设计到的计算量特别大，则相关的运算操作启动的进程/线程会在另一个cup中启动，这样可以实现真正的并行。 下面我们就一起来学习，可以实现异步的具体操作：进程、线程和协程！\nPython进程的实现 multiprocessing包 multiprocess是python中管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块，提供的子模块非常多。\nProcess模块 Process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\n之前我们说过，运行一个py文件就相当于启动了一个进程，这个进程我们成为**\u0026ldquo;主进程\u0026rdquo;**\n而在主进程对应的py文件中，可以通过Process模块创建另一个进程，这个进程是基于主进程创建的，因此可以被称为**\u0026ldquo;子进程\u0026rdquo;**\n当有了两个进程后，我们其实就可以实现异步机制了！\n具体实现过程：\n1.导入模块：from multiprocessing import Process\n2.基于Process创建一个子进程对象(当前运行的整个py文件表示主进程)，然后可以基于target参数将外部的一个函数注册到该子进程中\n3.基于start()方法启动创建好的子进程\nfrom multiprocessing import Process def func(): print(\u0026#39;我是绑定给子进程的一组任务！\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;主进程开始执行！\u0026#39;) #创建一个进程p，给该进程绑定一组任务 p = Process(target=func) #启动创建好的进程 p.start() print(\u0026#39;主进程执行结束！\u0026#39;) 上面例子说了，我们通过主进程创建的子进程是异步执行的，那么我们就验证一下，并且看一下子进程和主进程来看看是否是父子关系。\n​\tos.getpid() 获取自己进程的ID号\n​\ts.getppid() 获取自己进程的父进程的ID号\nimport os from multiprocessing import Process from time import sleep def func(): print(\u0026#39;我是子进程！\u0026#39;) sleep(1) print(\u0026#39;子进程ID号：\u0026#39;,os.getpid()) print(\u0026#39;该子进程的父进程ID号:\u0026#39;,os.getppid()) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;主进程开始执行！主进程的ID号:\u0026#39;,os.getpid()) #创建一个进程p，给该进程绑定一组任务 p = Process(target=func) #启动创建好的进程 p.start() print(\u0026#39;主进程执行结束！\u0026#39;) 如何手动给注册在子线程中的函数传递指定的参数？\n通过args传递参数\nfrom multiprocessing import Process def func(num1,num2): print(\u0026#39;我是绑定给子进程的一组任务！\u0026#39;,num1,num2) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;主进程开始执行！\u0026#39;) #创建一个进程p，给该进程绑定一组任务 p = Process(target=func,args=(123,456)) #启动创建好的进程 p.start() print(\u0026#39;主进程执行结束！\u0026#39;) 使用进程实现异步效果：\n同步效果：\nimport time def get_request(url): print(\u0026#39;正在请求网址的数据：\u0026#39;,url) time.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) if __name__ == \u0026#34;__main__\u0026#34;: start = time.time() urls = [\u0026#39;www.1.com\u0026#39;,\u0026#39;www.2.com\u0026#39;,\u0026#39;www.3.com\u0026#39;] for url in urls: get_request(url) print(\u0026#39;总耗时：\u0026#39;,time.time()-start) 异步效果：\nimport time from multiprocessing import Process def get_request(url): print(\u0026#39;正在请求网址的数据：\u0026#39;,url) time.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) if __name__ == \u0026#34;__main__\u0026#34;: urls = [\u0026#39;www.1.com\u0026#39;,\u0026#39;www.2.com\u0026#39;,\u0026#39;www.3.com\u0026#39;] for url in urls: #创建了三个进程，表示三组任务 p = Process(target=get_request,args=(url,)) p.start() join方法的使用\n思考：如果有时候，主进程需要使用子进程运行后的结果，则必须保证主进程等待子进程运行结束后在结束，如何实现呢？ 主进程会在加上join的地方等待（也就是阻塞住），会等待子进程执行完之后，再继续往后执行主进程join后序的部分 from multiprocessing import Process import time def func(): print(\u0026#39;子进程正在执行......\u0026#39;) time.sleep(2) print(\u0026#39;子进程执行结束！\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;主进程正在执行......\u0026#39;) p = Process(target=func) p.start() print(\u0026#39;主进程执行结束！\u0026#39;) #发现：主进程执行结束后，子进程才执行结束！ from multiprocessing import Process import time ticketNum = 10 #全部的车票 def func(num): print(\u0026#39;我是子进程，我要购买%d张票！\u0026#39;%num) global ticketNum ticketNum -= num time.sleep(2) if __name__ == \u0026#39;__main__\u0026#39;: p = Process(target=func,args=(3,)) p.start() #主进程在子进程结束之后在结束 p.join() #只有当子进程结束后，join的调用结束，才会执行join后续的操作 print(\u0026#39;目前剩余车票数量为:\u0026#39;,ticketNum) #输出结果依然是10 #进程和进程之间是完全独立。两个进程对应的是两块独立的内存空间，每一个进程只可以访问自己内存空间里的数据。 如果主进程的查询结果是在2s中后才出现的，则join生效了。但是查询结果为什么是这样的呢？\n首先，ticketNum = 10这个变量是存在于主进程中的，然后再func函数中ticketNum则是将全局变量ticketNum的值拷贝到了子进程中的ticketNum变量中，因此在func中的减法操作只能作用在子进程的变量中。最终，最后一行主进程打印的ticketNum则是原来主进程未发生变量的值。 如何解决？(自己可以尝试文件共享)\n进程通信机制，管道，信号量等(没必要掌握，日后用不到) 继续思考：一个子进程函数的返回值如何被主进程获取？\n总结：进程之间的数据是隔离的，也就是数据不共享\n那怎么样开启多个进程呢？\n需求是：所有的子进程异步执行，然后所有的子进程全部执行完之后，在结束主进程，怎么搞？ 重点理解下两组代码的不同之处：(两种不同位置调用join的区别) import time from multiprocessing import Process def get_request(url): print(\u0026#39;正在请求网址的数据：\u0026#39;,url) time.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) if __name__ == \u0026#34;__main__\u0026#34;: start = time.time() urls = [\u0026#39;www.1.com\u0026#39;,\u0026#39;www.2.com\u0026#39;,\u0026#39;www.3.com\u0026#39;] for url in urls: #创建了三个进程，表示三组任务 p = Process(target=get_request,args=(url,)) p.start() #主进程每创建一个子进程就要执行一次join操作，就要等待创建好的子进程执行结束后才可以继续创建下一个子进程。 p.join() #整个异步效果消失了 print(\u0026#39;总耗时：\u0026#39;,time.time()-start) import time from multiprocessing import Process def get_request(url): print(\u0026#39;正在请求网址的数据：\u0026#39;,url) time.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) if __name__ == \u0026#34;__main__\u0026#34;: start = time.time() urls = [\u0026#39;www.1.com\u0026#39;,\u0026#39;www.2.com\u0026#39;,\u0026#39;www.3.com\u0026#39;] ps = [] #存储创建好的多个子进程 for url in urls: #三个子进程创建且启动了，将三个子进程存储到了ps列表中 #创建了三个进程，表示三组任务 p = Process(target=get_request,args=(url,)) p.start() ps.append(p) for p in ps: #主进程等待三个子进程结束后再结束 p.join() print(\u0026#39;总耗时：\u0026#39;,time.time()-start) 进程创建的第二种方式（继承）\n自定义类继承Process 重写父类的run方法 在类外部调用start方法 from multiprocessing import Process class MyProcess(Process): def __init__(self,name): super().__init__() self.name = name #重写父类的run方法 def run(self): #该方法就是用来表示当前进程对象执行的任务 print(\u0026#39;当前%s子进程正在执行\u0026#39;,self.name) def func(self): print(\u0026#39;我就是一个普通的实例方法！\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: p = MyProcess(\u0026#39;bobo\u0026#39;) p.start() #启动进程，相当于是在调用对象的run方法 守护进程 那么如果有一天我们的需求是我的主进程结束了，由我主进程创建的那些子进程必须跟着结束，怎么办？守护进程就来了！\n主进程创建守护进程后：\n其一：守护进程会在主进程代码执行结束后就终止\n其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children\n语法：\n​\t子进程对象.daemon = True\n注意：主进程代码运行结束，守护进程随即终止\nimport time from multiprocessing import Process def get_request(url): print(\u0026#39;正在请求网址的数据：\u0026#39;,url) time.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) if __name__ == \u0026#34;__main__\u0026#34;: start = time.time() p = Process(target=get_request,args=(\u0026#39;www.1.com\u0026#39;,)) # 将当前p这个子进程设置为了守护进程 p.daemon = True #该操作必须放置在子进程启动操作之前 p.start() print(\u0026#39;主进程执行结束\u0026#39;) 进程同步(锁) 通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，但是它们之间的运行没有顺序，一旦开启也不受我们控制。\n尽管并发编程让我们能更加充分的利用计算机的资源，但是也给我们带来了新的问题：进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件是没有问题的，要是对同一文件进行读写操作呢？要知道共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理。\nimport os import time import random from multiprocessing import Process def work(n): print(\u0026#39;%s: %s is running\u0026#39; %(n,os.getpid())) time.sleep(random.random()) print(\u0026#39;%s:%s is done\u0026#39; %(n,os.getpid())) if __name__ == \u0026#39;__main__\u0026#39;: for i in range(5): p=Process(target=work,args=(i,)) p.start() 通过结果可以看出两个问题：\n​\t问题一：每个进程中work函数的第一个打印不一定会是按照我们for循环的0-4的顺序来打印\n​\t问题二：每个work进程中有两个打印，但是所有进程中第一个打印的顺序和第二个打印顺序完全不同且无规律，说明我们一个进程中的程序的执行顺序都混乱了。\n问题的解决方法，第二个问题加锁来解决，第一个问题是没有办法解决的，因为进程开到了内核，有操作系统来决定进程的调度，我们自己控制不了\n加锁流程：\n​\t1.导包：from multiprocessing import Lock\n​\t2.加锁：lock.acquire()\n​\t3.解锁：lock.release()\n接下来，我们以模拟抢票为例，来看看数据安全的重要性。\n#在当前目录下创建一个文件（db） #文件db的内容：{\u0026#34;count\u0026#34;:1}表示的是余票数量 from multiprocessing import Process import time,json,random def search():#查询db文件中的余票数量 fp = open(\u0026#39;./db.txt\u0026#39;,\u0026#39;r\u0026#39;) dic = json.load(fp) #反序列化，将文件中的json数据转成python字典对象 print(\u0026#39;剩余车票数量为:\u0026#39;,dic[\u0026#39;count\u0026#39;]) def get(): #负责抢票，一次只能购买一张票 fp = open(\u0026#39;./db.txt\u0026#39;, \u0026#39;r\u0026#39;) dic = json.load(fp) time.sleep(0.1) if dic[\u0026#39;count\u0026#39;] \u0026gt; 0:#还有剩余车票 time.sleep(0.2) dic[\u0026#39;count\u0026#39;] -= 1 #一次只能购买一张票 time.sleep(0.1) #购买车票后，余票数量发生了变化，将最新的余票数量在写回到db文件中进行存储 json.dump(dic,open(\u0026#39;./db.txt\u0026#39;,\u0026#39;w\u0026#39;)) print(\u0026#39;购票成功！\u0026#39;) def task(): search() #先查询 get() #后购买 if __name__ == \u0026#39;__main__\u0026#39;: for i in range(3):#创建三个子进程 p = Process(target=task) p.start() 加锁后：\nfrom multiprocessing import Process import time,json,random from multiprocessing import Lock #进程锁 def search():#查询db文件中的余票数量 fp = open(\u0026#39;./db.txt\u0026#39;,\u0026#39;r\u0026#39;) dic = json.load(fp) #反序列化，将文件中的json数据转成python字典对象 print(\u0026#39;剩余车票数量为:\u0026#39;,dic[\u0026#39;count\u0026#39;]) def get(): #负责抢票，一次只能购买一张票 fp = open(\u0026#39;./db.txt\u0026#39;, \u0026#39;r\u0026#39;) dic = json.load(fp) time.sleep(0.1) if dic[\u0026#39;count\u0026#39;] \u0026gt; 0:#还有剩余车票 time.sleep(0.2) dic[\u0026#39;count\u0026#39;] -= 1 #一次只能购买一张票 time.sleep(0.1) #购买车票后，余票数量发生了变化，将最新的余票数量在写回到db文件中进行存储 json.dump(dic,open(\u0026#39;./db.txt\u0026#39;,\u0026#39;w\u0026#39;)) print(\u0026#39;购票成功！\u0026#39;) def task(lock): lock.acquire() #上锁 search() #先查询 get() #后购买 lock.release() #解锁 if __name__ == \u0026#39;__main__\u0026#39;: lock = Lock() #创建了一把进程锁 for i in range(3):#创建三个子进程 p = Process(target=task,args=(lock,)) p.start() 线程 基本概念 **线程：**线程是操作系统能够进行运算调度的最小单位（车间里的工人），它被包含在进程之中，线程是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n注意：\n​\t1.同一个进程内的多个线程是共享该进程的资源的，不同进程内的线程资源肯定是隔离的\n​\t2.创建线程的开销比创建进程的开销要小的多\n​\t3.每一个进程中至少会包含有一个线程，该线程叫做\u0026quot;主线程\u0026quot;\n思考：多线程可以实现并行吗？\n在CPU比较繁忙，资源不足的时候（开启了很多进程），操作系统只为一个含有多线程的进程分配仅有的CPU资源，这些线程就会为自己尽量多抢时间片，这就是通过多线程实现并发，线程之间会竞争CPU资源争取执行机会。 在CPU资源比较充足的时候，一个进程内的多线程，可以被分配到不同的CPU资源，这就是通过多线程实现并行。 至于多线程实现的是并发还是并行？上面所说，所写多线程可能被分配到一个CPU内核中执行，也可能被分配到不同CPU执行，分配过程是操作系统所为，不可人为控制。所有，如果有人问我我所写的多线程是并发还是并行的？我会说，都有可能。 不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。 Python实现线程 python线程模块的选择 Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，threading提供了更高级别、功能更强的线程管理的功能。Queue模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。\n由于更高级别的threading模块更为先进，对线程的支持更为完善，因此推荐大家使用该模块！\nThreading模块 我们先简单应用一下threading模块来看看并发效果： from threading import Thread def func(num): print(\u0026#39;num的值是:\u0026#39;,num) if __name__ == \u0026#39;__main__\u0026#39;: #创建好了一个子线程（在主线程中创建） t = Thread(target=func,args=(1,)) t.start() from threading import Thread import time def func(num): time.sleep(1) print(\u0026#39;num的值是:\u0026#39;,num) if __name__ == \u0026#39;__main__\u0026#39;: for i in range(3): #创建好了一个子线程（在主线程中创建） t = Thread(target=func,args=(1,)) t.start() 线程的两种创建方式 from threading import Thread import time class MyThread(Thread): def __init__(self): super().__init__() def run(self): print(\u0026#39;当前子线程正在执行\u0026#39;) time.sleep(1) print(\u0026#39;当前子线程执行结束\u0026#39;) for i in range(3): t = MyThread() #创建线程对象 t.start() #启动线程对象 join()方法 from threading import Thread import time class MyThread(Thread): def __init__(self): super().__init__() def run(self): print(\u0026#39;当前子线程正在执行\u0026#39;) time.sleep(2) print(\u0026#39;当前子线程执行结束\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: start = time.time() ts = [] for i in range(3): t = MyThread() #创建线程对象 t.start() #启动线程对象 ts.append(t) for t in ts: t.join() print(\u0026#39;总耗时:\u0026#39;,time.time()-start) 线程内存数据共享： from threading import Thread import time def work(): global n n = 0 #将全局变量修改为了0 if __name__ == \u0026#39;__main__\u0026#39;: n = 1 #全局变量 t = Thread(target=work) t.start() print(n) #在进程中输出全局变量的值就是线程修改后的结果为0 守护线程\n无论是进程还是线程，都遵循：守护xx会在主xx运行完毕后被销毁，不管守护xx时候被执行结束。\nfrom threading import Thread import time def work(): time.sleep(1) print(\u0026#39;子线程正在执行！\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: t = Thread(target=work) t.daemon = True #当前的子线程设置为了守护线程 t.start() print(\u0026#39;主线程结束！\u0026#39;) 多线程使用：\nfrom threading import Thread import time class MyThread(Thread): def __init__(self): super().__init__() def run(self): print(\u0026#39;当前子线程正在执行\u0026#39;) time.sleep(2) print(\u0026#39;当前子线程执行结束\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: start = time.time() ts = [] for i in range(3): t = MyThread() #创建线程对象 t.start() #启动线程对象 ts.append(t) for t in ts: t.join() print(\u0026#39;总耗时:\u0026#39;,time.time()-start) 线程的GIL锁（大致了解） 首先，一些语言（java、c++、c）是支持同一个进程中的多个线程是可以应用多核CPU的，也就是我们会听到的现在4核8核这种多核CPU技术的厉害之处。\n那么我们之前说过应用多进程的时候如果有共享数据是不是会出现数据不安全的问题啊，就是多个进程同时一个文件中去抢这个数据，大家都把这个数据改了，但是还没来得及去更新到原来的文件中，就被其他进程也计算了，导致数据不安全的问题啊，所以我们是不是通过加锁可以解决啊，多线程大家想一下是不是一样的，并发执行也会有这个数据安全的问题。如何解决呢？\n但是python最早期的时候对于多线程也加锁，但是python比较极端的加了一个GIL全局解释锁，锁的是整个线程，而不是线程里面的某些数据操作，也就是说每次只能有一个线程使用cpu，也就说多线程用不了多核实现并行。\n但是这个并不是python语言的问题，是CPython解释器的特性，在Cpython里面就是没办法用多核，这是python的弊病，历史问题，虽然众多python团队的大神在致力于改变这个情况，但是暂没有解决。\nGIL介绍 在同一个进程中只有一个线程可以获取cpu的使用权限，那么其他的线程就必须等待该线程的cpu使用权消失后才能使用cpu,即使多个线程直接不会相互影响，在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。\nGIL的优点：\n1、避免了大量的加锁解锁的繁琐操作\n2、使数据更加安全，解决多线程间的数据完整性和状态同步\n缺点：\n​\t多核处理器的效果退化成单核处理器，只能并发不能并行\nGIL与多线程 有了GIL的存在，虽然可以保证数据的安全，但是同一时刻同一进程中只有一个线程被执行\n听到这里，有的同学立马质问：进程可以利用多核，但是开销大，而python的多线程开销小，但却无法利用多核优势，也就是说python没用了，php才是最好的语言？\n别着急啊，我们还没讲完：要解决这个问题，我们需要在几个点上达成一致：\n1. cpu到底是用来做计算的，还是用来做I/O的？ 2. 多cpu，意味着可以有多个核并行完成计算，所以多核提升的是计算性能 3. 每个cpu一旦遇到I/O阻塞，仍然需要等待，所以多核对I/O操作没什么用处 就好比是：\n​\t一个工人相当于cpu，那么计算相当于工人在干活，I/O阻塞相当于为工人干活提供所需原材料的过程，工人干活的过程中如果没有原材料了，则工人干活的过程需要停止，直到等待原材料的到来。\n如果你的工厂干的大多数任务都要有准备原材料的过程（I/O密集型），那么你有再多的工人，意义也不大。\n反过来讲，如果你的工厂原材料都齐全，那当然是工人越多，效率越高。\n结论：\n对计算来说，cpu越多越好，但是对于I/O来说，再多的cpu也没用\n当然对运行一个程序来说，随着cpu的增多执行效率肯定会有所提高（不管提高幅度多大，总会有所提高），这是因为一个程序基本上不会是纯计算或者纯I/O，所以我们只能相对的去看一个程序到底是计算密集型还是I/O密集型，从而进一步分析python的多线程到底有无用武之地。\n计算密集型案例：多进程效率高\nos.cpu_count()：查看计算机的核数\nfrom multiprocessing import Process from threading import Thread import time,os def word(): #计算密集型任务 res = 1 for i in range(1000000): res *= i if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;当前计算机的核数为：\u0026#39;,os.cpu_count()) start = time.time() ps = [] for i in range(100): #使用多进程来处理计算密集型任务（利用多核优势【并行】） p = Process(target=word) #执行耗时1s # p = Thread(target=word) #执行耗时2s p.start() ps.append(p) for p in ps: p.join() print(\u0026#39;总耗时：\u0026#39;,time.time()-start) 密集IO型：多线程效率高\nfrom multiprocessing import Process from threading import Thread import time,os def word(): #IO密集型任务 time.sleep(2) print(\u0026#39;------------------\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;当前计算机的核数为：\u0026#39;,os.cpu_count()) start = time.time() ps = [] for i in range(999): # p = Process(target=word) #执行耗时11s p = Thread(target=word) #执行耗时2s p.start() ps.append(p) for p in ps: p.join() print(\u0026#39;总耗时：\u0026#39;,time.time()-start) 同步锁 什么是同步锁？\n一个进程中的一个线程只能使用一个cpu。要保证一个线程对应的某些操作在一段时间内被完整的直接完毕所加入的锁就是同步锁。 为什么用同步锁？\n因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io阻塞操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程序结果的完整性。 使用：\n#未上锁 from threading import Thread,Lock import time,random def work(): global n temp = n time.sleep(random.random()) n = temp - 1 if __name__ == \u0026#39;__main__\u0026#39;: n = 10 #全局变量 ts = [] for i in range(10): t = Thread(target=work) t.start() ts.append(t) for t in ts: t.join() print(\u0026#39;全局变量n的值为：\u0026#39;,n) #上锁 from threading import Thread,Lock import time,random def work(): global n lock.acquire() #上锁 temp = n time.sleep(random.random()) n = temp - 1 lock.release() #解锁 if __name__ == \u0026#39;__main__\u0026#39;: n = 10 #全局变量 ts = [] lock = Lock() for i in range(10): t = Thread(target=work) t.start() ts.append(t) for t in ts: t.join() print(\u0026#39;全局变量n的值为：\u0026#39;,n) 总结：保护不同的数据就应该加不同的锁。 GIL 与Lock是两把锁，保护的数据不一样，前者是解释器级别的（当然保护的就是解释器级别的数据，比如垃圾回收的数据），后者是保护用户自己开发的应用程序的数据，很明显GIL不负责这件事，只能用户自定义加锁处理，即Lock\n线程池 线程预先被创建并放入线程池中，同时处理完当前任务之后并不销毁而是被安排处理下一个任务，因此能够避免多次创建线程，从而节省线程创建和销毁的开销，能带来更好的性能和系统稳定性。\nfrom multiprocessing.dummy import Pool #导入了线程池模块 import time urls = [\u0026#39;www.1.com\u0026#39;,\u0026#39;www.2.com\u0026#39;,\u0026#39;www.3.com\u0026#39;,\u0026#39;www.4.com\u0026#39;,\u0026#39;www.5.com\u0026#39;] def get_reqeust(url): print(\u0026#39;正在请求数据：\u0026#39;,url) time.sleep(2) print(\u0026#39;请求结束:\u0026#39;,url) start = time.time() #创建一个线程池,开启了5个线程 pool = Pool(5) #可以利用线程池中三个线程不断的去处理5个任务 pool.map(get_reqeust,urls) #get_reqeust函数调用的次数取决urls列表元素的个数 #get_requests每次执行都会接收urls列表中的一个元素作为参数 print(\u0026#39;总耗时：\u0026#39;,time.time()-start) pool.close() #释放线程池 ","permalink":"https://canw0916.github.io/en/posts/tech/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","summary":"并发编程（并发，并行，同步，异步） 通俗理解并发编程中的相关核心概念 核心概念：进程、线程和互斥锁 CPU的作用 计算机的核心是CPU，它承担了所有","title":"并发编程"},{"content":"异常处理 首先我们要理解什么叫做\u0026quot;异常”？\n在程序运行过程中，总会遇到各种各样的问题和错误。 有些错误是我们编写代码时自己造成的： 比如语法错误、调用错误，甚至逻辑错误。 还有一些错误，则是不可预料的错误，但是完全有可能发生的： 比如文件不存在、磁盘空间不足、网络堵塞、系统错误等等。 这些导致程序在运行过程中出现异常中断和退出的错误，我们统称为异常。大多数的异常都不会被程序处理，而是以错误信息的形式展现出来。 #0不能被作为除数 1/0 异常信息为：ZeroDivisionError: division by zero 异常的分类：\n异常有很多种类型，Python内置了几十种常见的异常，无需特别导入，直接就可使用。 需要注意的是，所有的异常都是异常类，首字母是大写的！ 异常的危害：\n如果程序中一旦出现了异常的语句代码，则该异常就会立即中断程序的运行！ 因此：\n为了保证程序的正常运行，提高程序健壮性和可用性。我们应当尽量考虑全面，将可能出现的异常进行处理，而不是留在那里，任由其发生。 python处理异常的机制：\nPython内置了一套try\u0026hellip;except\u0026hellip;finally（else）\u0026hellip;的异常处理机制，来帮助我们进行异常处理。其基本语法是：\ntry: pass except Exception as ex: pass 机制说明：\n首先，执行try子句（在关键字try和关键字except之间的语句）\n如果没有异常发生，忽略except子句，try子句执行后结束。\n如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。\ntry: print(\u0026#34;发生异常之前的语句正常执行\u0026#34;) print(1/0) print(\u0026#34;发生异常之后的语句不会被执行\u0026#34;) except ZeroDivisionError as e: print(e) 如果程序发生的异常不在你的捕获列表中，那么依然会抛出别的异常:\n# 未捕获到异常，程序直接报错 s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as ex: # 本例为非法值异常，而你只捕获索引异常 print(ex) Exception是什么？\n在Python的异常中，有一个通用异常：Exception，它可以捕获任意异常。 思考：那么既然有这个什么都能管的异常，其他诸如OSError、ZeroDivisionError的异常是不是就可以不需要了？ 当然不是！很多时候程序只会弹出那么几个异常，没有必要针对所有的异常进行捕获，那样的效率会很低。另外，根据不同的异常种类，制定不同的处理措施，用于准确判断错误类型，存储错误日志，都是非常有必要甚至强制的。 常见的异常类型： 异常名 解释 AttributeError 试图访问一个对象没有的属性 IOError 输入/输出异常 ImportError 无法引入模块或包；多是路径问题或名称错误 IndentationError 缩进错误 IndexError 下标索引错误 KeyError 试图访问不存在的键 KeyboardInterrupt Ctrl+C被按下，键盘终止输入 NameError 使用未定义的变量 SyntaxError 语法错误 TypeError 传入对象的类型与要求的不符合 UnboundLocalError 试图访问一个还未被设置的局部变量 ValueError 传入一个调用者不期望的值，即使值的类型是正确的 OSError 操作系统执行错误 Python的异常机制具有嵌套处理的能力:\n比如在函数f3()调用f2()，f2()调用f1()，虽然是在f1()出错了，但只需要在f3()进行异常捕获，不需要每一层都捕获异常\n#函数嵌套出现异常 def f1(): return 10/0 def f2(): f1() def f3(): f2() f3() 函数嵌套处理异常：\ndef f1(): return 10/0 def f2(): f1() def f3(): f2() try: f3() except Exception as e: print(e) try…excetion的嵌套\n之前我们说过，不是只使用通用的异常类Exception就万事大吉了，为了效率问题，我们需要对常见的异常信息进行精准的捕获，那么如果异常出现在用户层的话，则就需要对用户操作可能会出现的异常进行判断然后精准捕获了，如何操作呢？\n如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。也就是前面说的嵌套处理能力。直到程序最顶端如果还没有被捕获，那么将弹出异常。\ntry: try: print(\u0026#34;发生异常之前的语句正常执行\u0026#34;) print(1/0) print(\u0026#34;发生异常之后的语句不会被执行\u0026#34;) except ValueError as e: print(e) except ZeroDivisionError as e: print(\u0026#34;里层没有抓好，只能辛苦我外层了\u0026#34;) 或者使用一个try和多个except的形式：\ntry: print(\u0026#34;发生异常之前的语句正常执行\u0026#34;) print(1/0) print(\u0026#34;发生异常之后的语句不会被执行\u0026#34;) except NameError as e: print(e) except ZeroDivisionError as e: print(\u0026#34;我是第一个抓取到除零异常的\u0026#34;) except (ValueError,ZeroDivisionError) as e: print(\u0026#34;我是备胎\u0026#34;) 或者在except后面跟一个元组，元组中包含多个异常类\nexcept (RuntimeError, TypeError, NameError): pass finally和else子句\ntry except语法还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行：\n同样的，还有一个可选的finally子句。无论try执行情况和except异常触发情况如何，finally子句都会被执行！\n当然，else和finally同时存在时：\ntry: pass except: pass else: print(\u0026#34;else\u0026#34;) finally: print(\u0026#34;finally\u0026#34;) 主动抛出异常：raise\n很多时候，我们需要主动抛出一个异常。Python内置了一个关键字raise，可以主动触发异常。\n疑问：\n为什么要自己主动抛出异常？不嫌多事么？因为有的时候，你需要记录错误信息，然后将异常继续往上层传递，让上层去处理异常，如下：\ntry: divNum = input(\u0026#39;enter a divNum:\u0026#39;) divNum = int(divNum) try: 1/divNum except ZeroDivisionError as ex: print(\u0026#34;记录异常日志： \u0026#34;, ex) print(\u0026#34;但是我自己无法处理，只能继续抛出，看看上层能否处理（甩锅）\u0026#34;) raise ValueError(\u0026#39;非法录入\u0026#39;) except Exception as e: print(e) print(\u0026#39;用户录入非法数据，请重新输入！\u0026#39;) 有时候，你需要主动弹出异常，作为警告或特殊处理：\n#用户录入自己的性别：1表示男，2表示女 sex = int(input(\u0026#34;Please input a number: \u0026#34;)) try: if sex == 1: print(\u0026#34;这是个男人！\u0026#34;) elif sex == 0: print(\u0026#34;这是个女人！\u0026#34;) else: print(\u0026#34;好像有什么不符合常理的事情发生了！！\u0026#34;) raise ValueError(\u0026#34;非法的输入\u0026#34;) except ValueError: print(\u0026#34;这是个人妖！\u0026#34;) 迭代器 在介绍迭代器之前，先说明下迭代的概念：\n迭代：\n通过for循环遍历\u0026quot;对象”的每一个元素的过程。 这里的对象指的就是可迭代对象。因此记住：for循环遍历的只能是可迭代的对象。 可迭代类型的对象：\n在Python中，list/tuple/string/dict/set/bytes都是可以迭代的数据类型/可迭代对象！ 如何判定一个对象是否为可迭代对象呢？(了解)\n可以通过collections模块的Iterable类型作用在isinstance中来判断一个对象是否可迭代\nfrom collections import Iterable print(isinstance(\u0026#39;abc\u0026#39;,Iterable)) 迭代器\n迭代器是一种可以被遍历的对象，并且能作用于next()函数。\n性质：\n迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往后遍历不能回溯，不像列表，你随时可以取后面的数据，也可以返回头取前面的数据。 迭代器通常要实现两个基本的方法：iter() 和 next()。\n注意：\n可迭代对象并不一定是迭代器！ 常见的数据结构，字符串、列表、元组都属于可迭代对象，并不是迭代器！ 如何创建一个迭代器呢？\n字符串，列表或元组对象，甚至自定义对象都可用于创建迭代器：\n#使用Python内置的iter()方法创建迭代器对象 lis=[1,2,3,4] it = iter(lis) 可以使用type查看列表和迭代器类型的不同：\nlis=[1,2,3,4] it = iter(lis) print(type(lis),type(it)) 使用next()方法获取迭代器的下一个元素：\nlis=[1,2,3,4] it = iter(lis) print(next(it)) print(next(it)) 使用for循环遍历迭代器：\nlis = [1,2,3,4] it = iter(lis) # 创建迭代器对象 for x in it: # 使用for循环遍历迭代对象 print (x, end=\u0026#34; \u0026#34;) 思考：迭代器的作用是什么？\n可迭代对象的优缺点： 可迭代对象的优点：可以直观查看里面的对象，如直接查看列表的内容 可迭代对象缺点：全部内容要加载至内存中，故占用内存 迭代器的优缺点： 优点： 提供了一种通用不依赖索引的迭代取值方式； 节省内存，迭代器在内存中相当于只占一个数据的空间：因为每次取值都上一条数据会在内存释放，加载当前的此条数据。 缺点： 因为有next方法，即只能往后取值,不能往前，取值不如按照索引的方式灵活，不能取指定的某一个值 无法预测迭代器的长度 总结：迭代器和可迭代的区别？\n1.凡是可作用于for循环的对象都是可迭代类型； 2.凡是可作用于next()函数的对象都是迭代器类型； 3.list、dict、str等是可迭代的但不是迭代器，因为next()函数无法调用它们。可以通过iter()函数将它们转换成迭代器。 自定义迭代器\n很多时候，为了让我们自己写的类成为一个迭代器，需要在类里实现__iter__()和__next__()方法\n实际上，在使用next()函数的时候，调用的就是迭代器对象的__next__方法 python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现__iter__方法，而__iter__方法要返回一个迭代器。 迭代器自身正是一个迭代器，所以迭代器的__iter__方法返回自身即可 #迭代生成指定范围数列的平方值 class Squares: def __init__(self, start, stop): # 迭代起始、终止位 self.start = start self.stop = stop def __iter__(self): # 返回自身的迭代器 return self def __next__(self): # 返回下一个元素 if self.start \u0026gt; self.stop: # 结尾时抛出异常 raise (StopIteration) item = self.start**2 self.start += 1 return item if __name__ == \u0026#34;__main__\u0026#34;: for i in Squares(1, 5): print(i, end=\u0026#34; \u0026#34;) 推导式 Python语言有一种独特的语法，相当于语法糖的存在，可以帮你在某些场合写出比较精简酷炫的代码。但没有它，也不会有太多的影响。Python语言有几种不同类型的推导式\n列表推导式 字典推导式 集合推导式 元组推导式? 列表推导式\n列表推导式是一种快速生成列表的方式。其形式是用方括号括起来的一段语句，如下例子所示：\nalist = [x*2 for x in range(1,10)] print(alist) ############上下两组代码是等效 alist = [] for x in range(1,10): alist.append(x*2) print(alist) 列表推导式要这么理解，首先执行for循环，对于遍历的每一个x，代入x*x表达式中进行运算，将运算结果逐一添加到一个新列表内，循环结束，得到最终列表。它相当于下面的代码：\nalist = [] for x in range(1,10): alist.append(x*2) print(alist) 作用：\n列表推导式为我们提供了一种在一行内实现较为复杂逻辑的生成列表的方法。其核心语法是用中括号[]将生成逻辑封装起来。当然列表推导式也有多样用法 增加条件语句\nalist = [x * x for x in range(1,11) if x % 2 == 0] print(alist) ##############相当于如下代码 alist_1 = [] for x in range(1,11): if x % 2 == 0: alist_1.append(x*x) print(alist_1) 多重循环\nre = [a+b for a in \u0026#39;123\u0026#39; for b in \u0026#39;abc\u0026#39;] print(re) ############# alist = [] for a in \u0026#39;123\u0026#39;: for b in \u0026#39;abc\u0026#39;: alist.append(a+b) print(alist) 字典推导式\n既然使用中括号[]可以编写列表推导式，那么使用大括号呢？你猜对了！使用大括号{}可以制造字典推导式！\ndic = {x:x**2 for x in [2,4,6]} print(dic) \u0026#39;\u0026#39;\u0026#39; dic = {} for x in [2,4,6]: dic[x] = x**2 \u0026#39;\u0026#39;\u0026#39; 注意x: x**2的写法，中间的冒号，表示左边的是key右边的是value。\n集合推导式\n大括号除了能用作字典推导式，还可以用作集合推导式，两者仅仅在细微处有差别。\na = {x for x in \u0026#39;aabbccddeeff\u0026#39;} print(a) 元组推导式\n使用了中括号和大括号，那么使用圆括号，是不是元组推导式？想法不错，但事实却没有。圆括号在Python中被用作生成器的语法了，很快我们就会讲到，没有元组推导式。\na = (x for x in \u0026#39;aabbccddeeff\u0026#39;) print(a) #\u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x102f45970\u0026gt; #返回的是一个生成器对象 生成器 在Python这门语言中，生成器毫无疑问是最有用的特性之一。\n与此同时，也是使用的最不广泛的Python特性之一\n究其原因，主要是因为，在其他主流语言里面没有生成器的概念。正是由于生成器是一个“新”的东西，所以，它一方面没有引起广大工程师的重视，另一方面，也增加了工程师的学习成本，最终导致大家错过了Python中如此有用的一个特性。那到底什么是生成器呢？\n有时候，序列或集合内的元素的个数非常巨大，如果全制造出来并放入内存，对计算机的压力是非常大的。\n比如，假设需要获取一个10**20次方如此巨大的数据序列，把每一个数都生成出来，并放在一个内存的列表内，如果使用这种粗暴的方式，你能确保你的计算机会有如此大的内存么？ 那么如果元素可以按照某种算法推算出来，需要该元素的话那就计算到哪个元素，那么就可以在循环的过程中不断推算出后续的元素，而不必创建完整的元素集合，从而节省大量的空间。在Python中，这种一边循环一边计算出元素的机制，称为生成器：generator。 因此：生成器是一种特殊的迭代器，生成器自动实现了“迭代器协议”（即__iter__和next方法），不需要再手动实现两方法。 下面，我们一起来看看如何创建一个生成器！2种方式\n生成器推导式(忽略) for循环,yield关键字 生成器推导式：\na = (x for x in \u0026#39;aabbccddeeff\u0026#39;) print(a)#生成器对象 可以通过next()函数获得generator的下一个返回值：\na = (x for x in \u0026#39;aabbccddeeff\u0026#39;) print(next(a)) print(next(a)) print(next(a)) 但更多情况下，我们使用for循环创建生成器：\ng = (x for x in range(5)) for i in g: print(i) yield关键字创建生成器(重点)\n在 Python中，使用yield返回的函数会变成一个生成器（generator）。 在调用生成器的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行next()方法时从当前位置继续运行。下面重点理解yield关键字的使用：\nyield 是一个类似 return 的关键字，只是这个函数返回的是个生成器 当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象 当你使用for进行遍历的时候或者调用next函数后，函数中的代码才会执行 简单示例代码：函数体通过for循环结合yield返回一个生成器\ndef createGenerator(): for i in range(5): print(\u0026#39;我是循环体！\u0026#39;) yield i*i #使用了yield返回的结果而不是用return g = createGenerator() print(g) #\u0026lt;generator object createGenerator at 0x104bc5970\u0026gt; v1 = next(g) print(v1) #我是循环体！ #0 v2 = next(g) print(v2) #我是循环体！ #1 思考：下述函数的执行结果是什么？\ndef yieldTest(): i = 0 while i \u0026lt; 3: temp = yield i #赋值语句一定是先执行等号右侧的，在执行等号左侧 print(temp) i += 1 #在生成器函数实现内部是可以向yield后面写代码 obj = yieldTest()#创建一个生成器对象 v1 = next(obj) print(v1) #执行结果：0 v2 = next(obj) print(v2) #执行结果：None 1 思考None是如何产生的第一次取值：yield 返回了 i 值 0，停在yield i，temp没赋到值。第二次取值，开始在print，temp没被赋值，故打印None，i加1，继续while判断，yield 返回了 i 值 1，停在yield i）\n装饰器(了解) 装饰器（Decorator）：\n从字面上理解，就是装饰对象的器件。\n就是可以在不修改原有代码的情况下，为被装饰的对象增加新的功能或者附加限制条件。\n装饰器有很多种，有函数的装饰器，也有类的装饰器。装饰器在很多语言中的名字也不尽相同，它体现的是设计模式中的装饰模式。\n装饰器的语法是将@装饰器名，放在被装饰对象上面。\n@dec def func(): pass def outer(f):#2.f == func 将被装饰函数的名字传递给参数f def inner(): #6.执行inner函数体操作 f() #6.1.调用原先的func函数 print(\u0026#39;注册功能\u0026#39;) #6.2 执行添加的新功能 return inner #3.此处的返回值会返回给被装饰函数的名字 @outer #1.调用outer装饰器函数 def func(): #4. func == inner print(\u0026#39;登录功能\u0026#39;) func() #5.func() == inner() #需求：给func函数增添一个注册功能 在进行装饰器的介绍之前，我们必须先明确几个概念和原则：\n首先，Python程序是从上往下顺序执行的,而且碰到函数的定义代码块是不会立即执行的，只有等到该函数被调用时，才会执行其内部的代码块 其次，由于顺序执行的原因，如果你真的对同一个函数定义了两次，那么，后面的定义会覆盖前面的定义。因此，在Python中代码的放置位置是有区别的，不能随意摆放，通常函数体要放在调用的语句之前。 虚拟场景\n有一个大公司，下属的基础平台部负责内部应用程序及API的开发。另外还有上百个业务部门负责不同的业务，这些业务部门各自调用基础平台部提供的不同函数，也就是API处理自己的业务，情况如下：\n#基础平台部门开发了上百个函数的API def f1(): print(\u0026#39;业务部门1的数据接口......\u0026#39;) def f2(): print(\u0026#39;业务部门2的数据接口......\u0026#39;) def f3(): print(\u0026#39;业务部门3的数据接口......\u0026#39;) def f100(): print(\u0026#39;业务部门100的数据接口......\u0026#39;) #各部分分别调用自己部分的API f1() f2() f3() f100() 公司还在创业初期时，基础平台部就开发了这些函数。由于各种原因，比如时间紧，比如人手不足，比如架构缺陷，比如考虑不周等等，没有为函数的调用进行安全认证。现在，公司发展壮大了，不能再像初创时期的“草台班子”一样将就下去了，基础平台部主管决定弥补这个缺陷，于是：\n第一天：主管叫来了一个运维工程师，工程师跑上跑下逐个部门进行通知，让他们在代码里加上认证功能，然后，当天他被开除了。\n第二天：主管叫来了一个python自动化开发工程师。哥们是这么干的，只对基础平台的代码进行重构，让N个业务部门无需做任何修改。这哥们很快也被开了，连运维也没得做。　#基础平台部门开发了上百个函数的API def f1(): #加入认证程序代码 xxx print(\u0026#39;业务部门1的数据接口......\u0026#39;) def f2(): #加入认证程序代码 xxx print(\u0026#39;业务部门2的数据接口......\u0026#39;) def f3(): #加入认证程序代码 xxx print(\u0026#39;业务部门3的数据接口......\u0026#39;) def f100(): #加入认证程序代码 xxx print(\u0026#39;业务部门100的数据接口......\u0026#39;) #各部分分别调用自己部分的API f1() f2() f3() f100() 第三天：主管又换了个开发工程师。他是这么干的：定义个认证函数，在原来其他的函数中调用它，代码如下:\n#基础平台部门开发了上百个函数的API def cheak(): pass def f1(): cheak() print(\u0026#39;业务部门1的数据接口......\u0026#39;) def f2(): cheak() print(\u0026#39;业务部门2的数据接口......\u0026#39;) def f3(): cheak() print(\u0026#39;业务部门3的数据接口......\u0026#39;) def f100(): cheak() print(\u0026#39;业务部门100的数据接口......\u0026#39;) #各部分分别调用自己部分的API f1() f2() f3() f100() 但是主管依然不满意，不过这一次他解释了为什么。\n主管说：写代码要遵循开放封闭原则，简单来说，已经实现的功能代码内部不允许被修改，但外部可以被扩展。如果将开放封闭原则应用在上面的需求中，那么就是不允许在函数f1 、f2、f3\u0026hellip;\u0026hellip;f100的内部进行代码修改，但是可以在外部对它们进行扩展。 第四天：已经没有时间让主管找别人来干这活了，他决定亲自上阵，使用装饰器完成这一任务，并且打算在函数执行后再增加个日志功能。主管的代码如下：\ndef outer(func): def inner(): print(\u0026#39;认证功能操作\u0026#39;) result = func() return result return inner #基础平台部门开发了上百个函数的API @outer def f1(): print(\u0026#39;业务部门1的数据接口......\u0026#39;) @outer def f2(): print(\u0026#39;业务部门2的数据接口......\u0026#39;) @outer def f3(): print(\u0026#39;业务部门3的数据接口......\u0026#39;) @outer def f100(): print(\u0026#39;业务部门100的数据接口......\u0026#39;) #各部分分别调用自己部分的API f1() f2() f3() f100() 使用装饰器@outer，也是仅需对基础平台的代码进行拓展，就可以实现在其他部门调用函数API之前都进行认证操作，并且其他业务部门无需对他们自己的代码做任何修改，调用方式也不用变。\n装饰器机制分析\n下面以f1函数为例，对装饰器的运行机制进行分析：\n#1.定义一个装饰器 #装饰器outer是有特殊要求的： #要求1：装饰器函数必须要有一个参数（表示的是被装饰函数的函数名） def outer(func): #step2.func == f1 def inner(): print(\u0026#39;给f1函数增添的安全认证功能\u0026#39;) func() #step3:等同于在调用f1() print(\u0026#39;给f1函数增加了数据检测的功能\u0026#39;) return inner#step4：inner表示的是内部函数的名字，该函数名就会替换被装饰的函数名 #2.使用定义好的装饰器，去装饰某一个函数（在不修改函数原有代码的基础上给其增添新的功能） #如果装饰器装饰了一个函数，则装饰器函数就会被自动调用 @outer # step1.调用装饰器函数，且将被装饰的函数名传递给装饰器函数的参数 #使用outer装饰器装饰f1函数 def f1(): #step5：f1 == inner; inner()函数调用就是在调用f1() print(\u0026#39;业务部门1的数据接口......\u0026#39;) def f2(): #f2是没有被outer装饰的 print(\u0026#39;f2函数的原有实现\u0026#39;) f1() #实际上就是在调用inner() - 1.程序开始运行，从上往下解释，读到def outer(func):的时候，发现这是个函数定义，于是把函数体加载到内存里。 - 2.读到@outer的时候，程序被@这个语法吸引住了，解释器知道这是个装饰器，按规矩要立即执行的，于是程序开始运行@后面那个名字outer所定义的函数。 - 3.程序返回到outer函数，开始执行装饰器的语法规则。规则是： - 被装饰的函数的名字会被当作参数传递给装饰函数。装饰函数执行它自己内部的代码后，会将它的返回值赋值给被装饰的函数。原来的f1函数被当做参数传递给了func，而f1这个函数名之后会指向inner函数。 - 注意： - @outer和@outer()有区别，没有括号时，outer函数依然会被执行，这和传统的用括号才能调用函数不同，需要特别注意！ - f1这个函数名当做参数传递给装饰函数outer，也就是：func = f1，@outer等于outer(f1),实际上传递了f1的函数体，而不是执行f1后的返回值。 - outer函数return的是inner这个函数名，而不是inner()这样被调用后的返回值 - 4.程序开始执行outer函数内部的内容，一开始它又碰到了一个函数inner，inner函数定义块被程序观察到后不会立刻执行，而是读入内存中（这是默认规则）。 - 5.再往下，碰到return inner，返回值是个函数名，并且这个函数名会被赋值给f1这个被装饰的函数，也就是f1 = inner。根据前面的知识，我们知道，此时f1函数被新的函数inner覆盖了（实际上是f1这个函数名更改成指向inner这个函数名指向的函数体内存地址，f1不再指向它原来的函数体的内存地址），再往后调用f1的时候将执行inner函数内的代码，而不是先前的函数体。那么先前的函数体去哪了？还记得我们将f1当做参数传递给func这个形参么？func这个变量保存了老的函数在内存中的地址，通过它就可以执行老的函数体，你能在inner函数里看到result = func()这句代码，它就是这么干的！ - 6.接下来，还没有结束。当业务部门，依然通过f1()的方式调用f1函数时，执行的就不再是旧的f1函数的代码，而是inner函数的代码。 - 7.以上流程走完后，你应该看出来了，在没有对业务部门的代码和接口调用方式做任何修改的同时，也没有对基础平台部原有的代码做内部修改，仅仅是添加了一个装饰函数，就实现了我们的需求，在函数调用前进行认证，调用后写入日志。这就是装饰器的最大作用。 思考：为什么我们要搞一个outer函数一个inner函数这么复杂呢？一层函数不行吗？\n请注意，@outer这句代码在程序执行到这里的时候就会自动执行outer函数内部的代码，如果不封装一下，在业务部门还未进行调用的时候，就执行了，这和初衷不符。当然，如果你对这个有需求也不是不行。 带参装饰器\n上面的例子中，f1函数没有参数，在实际情况中肯定会需要参数的，函数的参数怎么传递的呢？\n在inner函数的定义部分也加上一个参数，调用func函数的时候传递这个参数：\ndef outer(func):#2.func == f1 def inner(n): #3.n == name,n就是被装饰函数的参数 print(\u0026#39;新功能！\u0026#39;) func(n) #4.func(n) == f1(n) return inner #5.inner就会覆盖原先的被装饰函数名f1 @outer #1.调用装饰器函数，将被装饰的函数名f1作为实参，传递给outer的形参 def f1(name): #6.f1 == inner print(\u0026#39;f1的原有功能，f1的参数值为：\u0026#39;,name) f1(\u0026#39;bobo\u0026#39;) #7.inner(\u0026#39;bobo\u0026#39;) ","permalink":"https://canw0916.github.io/en/posts/tech/python%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/","summary":"异常处理 首先我们要理解什么叫做\u0026quot;异常”？ 在程序运行过程中，总会遇到各种各样的问题和错误。 有些错误是我们编写代码时自己造成的： 比如语","title":"Python高级语法"},{"content":"面向对象 面向过程VS面向对象 面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线，考虑周全什么时候处理什么东西。\n优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。\n缺点是：一套流水线就是用来解决一个问题，代码牵一发而动全身。\n应用场景：\n一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。 面向对象OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，并且一个对象包含数据和操作数据的方法。\n面向对象的程序设计的核心是对象，要理解对象为何物，必须把自己当成上帝（上帝式思维）。上帝眼里世间存在的万物皆为对象。\n形象化场景设计：\n面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，\u0026ldquo;如来”想了想解决这个问题需要四个人（对象）：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法）。然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。“如来”根本不会管师徒四人按照什么流程去取，只关心最后结果是否可以实现。 因此面向对象的核心思想就是使用一个有一个的对象来完成某件具体是事件，且不用关心完成的具体过程！ 面向对象的优点：面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使他人更加容易理解你的代码逻辑，从而使团队开发变得更从容。\n应用场景：需求经常变化的软件，如互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。\n类和实例 类，英文名字Class，有“类别”，“分类”，“聚类”的意思。\n必须牢记类是抽象的模板，用来描述具有相同属性和方法的对象的集合，比如Animal类。\n而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\nPython使用class关键字来定义类，其基本结构如下：\nclass 类名(): #一般类名首字母是大写 pass 下面是一个学生类：\nclass Student(): #数据 classroom = \u0026#39;101\u0026#39; address = \u0026#39;beijing\u0026#39; #构造方法 def __init__(self, name, age): self.name = name self.age = age #操作 def print_age(self): print(\u0026#39;%s: %s\u0026#39; % (self.name, self.age)) 对象的创建\n可以通过调用类的实例化方法（有的语言中也叫初始化方法或构造函数）来创建一个类的实例（对象）。\nPython提供了一个def __init__(self):的实例化机制。任何一个类中，名字为__init__的方法就是类的实例化方法，具有__init__方法的类在实例化的时候，会自动调用该方法，并传递对应的参数。\nzhangsan = Student(\u0026#39;zhangsan\u0026#39;,20) lisi = Student(\u0026#39;lisi\u0026#39;,30) 实例变量和类变量 实例变量\n实例变量指的是实例（对象）本身拥有的变量。Student类中__init__方法里的name和age就是两个实例变量。\n通过实例名加圆点的方式调用实例变量（可以通过对象名打点的方式去调用/访问属于对象的成员）。\nclass Student(): #init称为构造方法 def __init__(self,i_name,i_age): #只要定义在init方法内部的变量就是【实例/对象变量】 self.name = i_name #self.name就是定义的实例变量，name是init方法的参数值 self.age = i_age #self.age就是定义的实例变量，age就是init方法的参数值 s1 = Student(\u0026#39;zhangsan\u0026#39;,20) #调用Student类中的init这个构造方法 s2 = Student(\u0026#39;lisi\u0026#39;,25) #根据对象的引用访问对象的实例变量 print(s1.name,s1.age) #访问s1对象的name和age这两个实例变量 print(s2.name,s2.age) #访问s2对象的name和age这两个实例变量 类变量\n定义在类中，方法之外的变量，称作类变量。类变量是所有实例公有的变量，每一个实例都可以访问类变量。\n在Student类中，classroom和address两个变量就是类变量。可以通过类名或者实例名加圆点的方式访问类变量，比如：\nclass Student(): #定义在方法外部的变量：类变量 address = \u0026#39;Beijing\u0026#39; classroom = 167 #init称为构造方法 def __init__(self,i_name,i_age): #只要定义在init方法内部的变量就是【实例/对象变量】 self.name = i_name #self.name就是定义的实例变量，name是init方法的参数值 self.age = i_age #self.age就是定义的实例变量，age就是init方法的参数值 s1 = Student(\u0026#39;zhangsan\u0026#39;,20) #调用Student类中的init这个构造方法 s2 = Student(\u0026#39;lisi\u0026#39;,25) #根据对象的引用访问对象的实例变量 print(s1.name,s1.age) #访问s1对象的name和age这两个实例变量 print(s2.name,s2.age) #访问s2对象的name和age这两个实例变量 类变量的特性：\n所有的类变量是可以通过类名或者对象名打点的方式访问/调用的。\nprint(s1.address,s1.classroom) #通过对象名可以访问类变量（不推荐） #通过类名可以访问类变量（推荐） print(Student.address,Student.classroom) 类变量是可以被所有的对象公用的\nprint(s1.address,s1.classroom) #通过s1对象访问类变量 print(s2.address,s2.classroom) #通过s2对象访问类变量 思考：如何修改类变量中存储的数据？\n通过对象名访问类变量对其进行内容的修改？\nclass Student(): #定义在方法外部的变量：类变量 address = \u0026#39;Beijing\u0026#39; classroom = 167 #init称为构造方法 def __init__(self,i_name,i_age): #只要定义在init方法内部的变量就是【实例/对象变量】 self.name = i_name #self.name就是定义的实例变量，name是init方法的参数值 self.age = i_age #self.age就是定义的实例变量，age就是init方法的参数值 s1 = Student(\u0026#39;zhangsan\u0026#39;,20) #调用Student类中的init这个构造方法 s2 = Student(\u0026#39;lisi\u0026#39;,25) #想要通过s1对象访问address类变量，且给其修改内容 s1.address = \u0026#39;SH\u0026#39; print(s2.address) #思考：类变量是被所有的对象共享，因此通过s1对象修改了类变量，s2再次访问类变量，情况如何？ #s2访问的类变量address依然是beijing不是s1修改后的上海，Why？ #这种情况是说明类变量不是被所有对象共享的吗？一定不是这样！ 特别注意：建议大家使用类名访问类变量。如果通过对象名直接访问类变量是没有问题的。但是通过对象名访问类变量后给其进行赋值操作意图修改类变量实则发生的是通过对象打点的方式给对象动态的新增了一个实例变量，并不是在修改类变量。\ns1.address = \u0026#39;SH\u0026#39; #动态的给s1这个变量新增了一个实例变量，这个实例变量叫做address。该操作执行完毕后，则s1这个对象内部多了一个实例变量叫做s1，且s1对象对应的类中也有一个address表示的类变量。 print(Student.address)#在访问类变量address，这个类变量依然还是Beijing。 通过实例名修改？\n#在访问类变量 print(s1.address,s2.address) #通过类名访问类变量且对其进行修改 Student.address = \u0026#39;SH\u0026#39; #查看修改后的结果 print(s1.address,s2.address) #SH SH 注意：\n#对象创建好了之后，是可以通过对象名动态的给对象添加新的实例变量。对象添加了实例变量后，只会影响该对象本身，不会对类和其他对象造成影响。 #给s1对象动态添加了一个实例变量book s1.book = \u0026#39;sanguo\u0026#39; #下述语句报错，因为s1动态增加的实例变量，只会影响它自己，不会影响到其他 print(s2.book,Student.book) 测试：\nclass Student(): address = \u0026#39;Beijing\u0026#39; #构造方法：用来实例变量初始化赋值 def __init__(self,addr): #构造方法中也可以写入其他操作，但是一般情况下，只需要在构造方法中写给实例变量初始化赋值的操作。 self.address = addr #实例变量名和类变量名一致 s = Student(\u0026#39;SH\u0026#39;) #创建对象其实就是在调用类中的init方法 #如果实例变量和类变量同名，通过对象名访问，优先方位对象的实例变量 print(s.address) #输出：SH print(Student.address)#输出：Beijing 类的方法 Python的类中包含实例方法、静态方法和类方法三种方法。区别在于传入的参数和调用方式不同。\n在类的内部，使用def关键字来定义一个方法。\n实例方法 类的实例方法由实例调用，至少包含一个self参数，且为第一个参数。执行实例方法时，会自动将调用该方法的实例赋值给self。\nself代表的是类的实例，而非类本身。self不是关键字，而是Python约定成俗的命名，你完全可以取别的名字，但不建议这么做。\n例如，我们前面Student类中的print_age()就是实例方法：\nclass Student(): classroot = 167 #类变量 #构造方法 def __init__(self,name,age): #实例变量 self.name = name self.age = age #实例方法:self不是python的关键字，实例方法的第一个参数也可以叫其他的名字，但是约定俗成叫做self。 #注意：实例方法只可以通过对象调用。 def study(self,book):#self是不需要手动给其传值 print(\u0026#39;正在学习的书籍是：\u0026#39;,book) s = Student(\u0026#39;zhangsan\u0026#39;,20) #调用构造方法 #只给除了self其他的参数传值 s.study(\u0026#39;高等数学\u0026#39;) 实例方法中的第一个参数self到底是什么鬼？\n想要在一个实例方法内部调用另一个实例方法？ 核心：实例方法只可以被对象调用 class Student(): classroot = 167 #类变量 #构造方法 def __init__(self,name,age): #实例变量 self.name = name self.age = age #实例方法 def study(self,book): #self就是study方法的调用者（对象） #注意：在study方法内部调用play方法，如何实现？ self.play(\u0026#39;足球\u0026#39;) #实例方法必须使用对象调用 #self表示的就是调用该方法的对象的引用 print(\u0026#39;正在学习的书籍是：\u0026#39;,book) #实例方法 def play(self,b): print(\u0026#39;正在玩的项目是:\u0026#39;,b) s = Student(\u0026#39;zhangsan\u0026#39;,20) #调用构造方法 s.study(\u0026#39;高等数学\u0026#39;) self就是study方法的调用者（对象），self表示的就是调用该方法的对象的引用 对象之间的交互：设计人狗大战游戏，让他们真正的打一架。\nclass Person(): def __init__(self,name): self.name = name self.blood = 100 #人的初始血量 self.gjl = 10 #人的攻击力 def hitDog(self,dog): #dog参数表示的是狗对象 #人打狗后，需要让狗的血量减去人的攻击力 dog.blood -= self.gjl #展示剩余血量 def showBlood(self): print(\u0026#39;%s，剩下的血量为：%d\u0026#39;%(self.name,self.blood)) class Dog(): def __init__(self,name): self.name = name self.blood = 50 #狗的初始血量 self.gjl = 5 #狗的攻击力 def hitPerson(self,p): #参数p就是狗攻击的人那个对象 p.blood -= self.gjl #展示剩余血量 def showBlood(self): print(\u0026#39;%s，剩下的血量为：%d\u0026#39;%(self.name,self.blood)) p1 = Person(\u0026#39;zhangsan\u0026#39;) p2 = Person(\u0026#39;lisi\u0026#39;) d1 = Dog(\u0026#39;doudou\u0026#39;) d2 = Dog(\u0026#39;huanghuang\u0026#39;) p2.hitDog(d1) #lisi去攻击doudou这条狗 d1.showBlood() #查看被攻击后的狗还剩下多少血量 d2.hitPerson(p1) #huanghuang去攻击zhangsan p1.showBlood() #查看被攻击后的人还剩下多少血量 静态方法 静态方法由类调用，无默认参数。将实例方法参数中的self去掉，然后在方法定义上方加上@staticmethod，就成为静态方法。\n静态方法属于类，和实例无关。建议只使用类名.静态方法的调用方式。（虽然也可以使用实例名.静态方法的方式调用）\nclass Obj(): def __init__(self): pass #定义一个静态方法 @staticmethod def staticFunc(name):#静态方法不需要有任何的必要参数 print(\u0026#39;我是静态方法！，我有一个普通参数：\u0026#39;,name) Obj.staticFunc(\u0026#39;bobo\u0026#39;) #通过类名调用（推荐） o = Obj() o.staticFunc(\u0026#39;bobo\u0026#39;) #通过对象名调用（不推荐） #静态方法既不属于类也不属于对象，仅仅是写在类内部的一个普通函数而已 类方法 类方法由类调用，采用@classmethod装饰，至少传入一个cls（代指类本身，类似self）参数。\n执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用）\nclass Obj(): f = \u0026#39;classVar\u0026#39; #类变量 def __init__(self): pass @classmethod def classFunc(cls): #类方法必须要有一个cls的参数，且作为第一个参数 #cls也不是python的关键字，cls也可以写作其他的形式，比如：name，self print(\u0026#39;我是类方法！必要参数cls的值为：\u0026#39;,cls) print(\u0026#39;类变量的值为:\u0026#39;,cls.f) #类名访问类变量 #cls表示的是当前类 o = Obj() o.classFunc() #通过对象名访问（不推荐） Obj.classFunc() #通过类名访问（推荐） 测试题：\n在类方法中是否可以调用实例方法和实例变量？ 不能，因为实例变量和实例方法只可以通过对象名访问，但是在类方法内部不存在对象名。 在实例方法中是否可以调用类方法和类变量？ 可以，但是不建议这么做！ 面向对象的组合用法 组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合\n思路设计：一个学生会有一步手机，学生使用手机看电影。\nclass Student(): def __init__(self): #将创建好的手机对象赋值给了phone这个实例变量 self.phone = Phone(\u0026#39;霸王别姬\u0026#39;) class Phone(): def __init__(self,movie_name): self.movie_name = movie_name def playMovie(self): print(\u0026#39;手机正在播放的电影是：\u0026#39;,self.movie_name) s1 = Student() s1.phone.playMovie() 封装、继承和多态 面向对象有三大特性：封装、继承和多态\n封装 封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现且不能通过任何形式修改对象内部实现，正是由于封装机制。\n作用：\n程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。 class Student: classroom = \u0026#39;101\u0026#39; address = \u0026#39;beijing\u0026#39; def __init__(self, name, age): self.name = name self.age = age def print_age(self): print(\u0026#39;%s: %s\u0026#39; % (self.name, self.age)) # 以下是错误的用法 # 类将它内部的变量和方法封装起来，阻止外部的直接访问 print(classroom) print(adress) print_age() 继承 继承来源于现实世界：\n一个最简单的例子就是孩子会具有父母的一些特征，即每个孩子都会继承父亲或者母亲的某些特征，当然这只是最基本的继承关系，现实世界中还存在着更复杂的继承。 在OOP程序设计中，当我们定义一个新类的时候，新的类称为子类（Subclass），而被继承的类称为基类、父类或超类（Base class、Super class）。\n继承最大的好处是子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展。其语法结构如下：\nclass Foo(superA, superB,superC....): pass Python支持多父类的继承机制。\n继承示例代码：子类可以继承到父类中所有的成员\nclass Father(): address = \u0026#39;Beijing\u0026#39; #类变量 #构造方法 def __init__(self,fistName,hobby): #两个实例变量 self.firstName = fistName self.hobby = hobby def get_xxx(self): print(\u0026#39;我是Father的实例方法\u0026#39;) @classmethod def classFunc(cls): print(\u0026#39;我是Father类的类方法\u0026#39;) @staticmethod def staticFunc(): print(\u0026#39;我是Father类的静态方法\u0026#39;) #Son继承了Father这个类 #Son子类，Father父类 class Son(Father): pass #1.子类可以继承到父类的构造方法 s = Son(\u0026#39;zhang\u0026#39;,\u0026#39;smoke\u0026#39;) #调用子类的构造方法，子类是可以继承到父类的构造方法 #2.子类可以继承到父类的类变量 print(Son.address) #3.子类可以继承到父类的实例变量 print(s.firstName,s.hobby) #4.子类可以继承到父类的实例方法 s.get_xxx() #5.子类可以继承到父类的类方法 Son.classFunc() #6.子类可以继承到父类的静态方法 Son.staticFunc() 派生 子类添加自己独有的方法和或属性 class Father(): address = \u0026#39;Beijing\u0026#39; #类变量 #构造方法 def __init__(self,fistName,hobby): #两个实例变量 self.firstName = fistName self.hobby = hobby def get_xxx(self): print(\u0026#39;我是Father的实例方法\u0026#39;) @classmethod def classFunc(cls): print(\u0026#39;我是Father类的类方法\u0026#39;) @staticmethod def staticFunc(): print(\u0026#39;我是Father类的静态方法\u0026#39;) class Son(Father): #子类自己派生出来的独有的方法 def sing(self): print(\u0026#39;子类的实例方法sing\u0026#39;) s = Son(\u0026#39;zhang\u0026#39;,\u0026#39;smoke\u0026#39;) s.sing() 方法的重写 重写:子类继承到父类的方法，如果满足不了子类的需求，则子类可以重写从父类中继承到的方法。重写父类方法有两种方式：1完全重写，2部分重写\n1.完全重写：完全重新将父类的方法进行的全新的定义/实现（毫无保留父类方法原始的功能）\nclass Father(): def __init__(self,firstName): self.firstName = firstName def hobby(self): print(\u0026#39;我喜欢读书，运动和跳舞！\u0026#39;) class Son(Father): #完全重写 def hobby(self): print(\u0026#39;我喜欢吃鸡，王者！\u0026#39;) s = Son(\u0026#39;zhang\u0026#39;) s.hobby() 2.部分重写：在父类方法功能实现的基础上新增了其他操作/功能\nclass Father(): def __init__(self,firstName): self.firstName = firstName def hobby(self): print(\u0026#39;我喜欢读书，运动和跳舞！\u0026#39;) class Son(Father1): #部分重写 def hobby(self): #调用一下父类的hobby方法 super().hobby() #调用父类的方法 print(\u0026#39;我喜欢吃鸡，王者！\u0026#39;) s = Son(\u0026#39;zhang\u0026#39;) s.hobby() super()只可以作用在类的内部，然后表示的是父类对象的引用。\nsuper函数\n如果你想强制调用父类的成员该如何实现呢？使用super()函数！这是一个非常重要的函数，最常见的就是通过super调用父类的实例化方法__init__！\n语法：super(子类名, self).方法名()，需要传入的是子类名和self，调用的是父类里的方法，按父类的方法需要传入参数。\nclass Father(): def __init__(self,firstName): self.firstName = firstName def hobby(self): print(\u0026#39;我喜欢读书，运动和跳舞！\u0026#39;) class Son(Father): #子类需要有属于自己的实例变量 def __init__(self,firstName,classroom,score): super().__init__(firstName) #子类自己派生出的独有的实例变量 self.classroom = classroom self.score = score #部分重写 def hobby(self): #调用一下父类的hobby方法 super().hobby() #调用父类的方法 print(\u0026#39;我喜欢吃鸡，王者！\u0026#39;) s = Son(\u0026#39;zhang\u0026#39;,102,100) s.hobby() 继承的作用：\n实现了程序的高复用，大大缩短程序的开发周期！ 在多继承中，继承关系的优先级\nclass Father1(): def hobby(self): print(\u0026#39;我是Father1，我喜欢唱歌！\u0026#39;) class Father2(): def hobby(self): print(\u0026#39;我是Father2，我喜欢跳舞！\u0026#39;) #注意：越靠前的父类越优先被继承 class Son(Father1,Father2): #方法的重写 def hobby(self): #思考：现在Son有两个父类，super()表示的是哪一个父类对象？ #输出结果显示super表示的是Father1对象 super().hobby() print(\u0026#39;我是Son，我喜欢吃鸡！\u0026#39;) s = Son() s.hobby() type和isinstance\nisinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。\nisinstance() 方法的语法:\nisinstance(object, classinfo) 参数： object -- 实例对象。 classinfo -- 可以是类名、基本类型或者有它们组成的元组。 返回值： 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。 class Father(): pass class Son(Father): pass s = Son() #子类对象 print(isinstance(s,Son)) #True #s这个对象是属于Son这个数据类型的。 #python的数据类型：内置类型（8中），自定义类型（类） class Father(): pass class Son(Father): pass s = Son() #子类对象 print(isinstance(s,Father)) #True #注意：子类对象可以被视为是一种父类类型 class Father(): pass class Son(Father): pass s = Son() #子类对象 print(type(s)) #\u0026lt;class \u0026#39;__main__.Son\u0026#39;\u0026gt; type：返回对象的类型\nisinstance() 与 type() 区别：\ntype() 不会认为子类是一种父类类型，不考虑继承关系。\nisinstance() 会认为子类是一种父类类型，考虑继承关系。\n继承注意事项 实例方法中的self参数是一个相对的值？\nclass Father(): def get_xxx(self): print(self) class Son(Father): pass f = Father() f.get_xxx() #输出：\u0026lt;__main__.Father object at 0x103536580\u0026gt; #说明self表示的是父类类型的对象 class Father(): def get_xxx(self): print(self) class Son(Father): pass s = Son() #是子类对象从父类中继承过来，self原本是写在父类的实例方法中的 s.get_xxx() #输出结果：\u0026lt;__main__.Son object at 0x100e2a880\u0026gt; self所处的位置不同，表示的对象类型也是不同的！ 类方法中的cls参数是一个相对的值？\nclass Father(): #类变量 class_var = \u0026#39;father var\u0026#39; @classmethod def getVar(cls): print(Father.class_var) class Son(Father): #类变量：和父类的类变量同名，子类同名的类变量就会覆盖从父类中继承过来的类变量 class_var = \u0026#39;son var\u0026#39; Son.getVar() #输出：father var class Father(): #类变量 class_var = \u0026#39;father var\u0026#39; @classmethod def getVar(cls): print(cls.class_var) class Son(Father): #类变量：和父类的类变量同名，子类同名的类变量就会覆盖从父类中继承过来的类变量 class_var = \u0026#39;son var\u0026#39; Son.getVar() #输出：son var 注意：cls存在哪个类中，就表示的是当前的类。 类方法的作用 思考：实例方法中的self参数的值是从哪来的？\nPython 中的__new__和__init__的区别: 【同】 二者均是Python面向对象语言中的函数，__new__比较少用，__init__则用的比较多。 【异】 __new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象。 __init__是在对象创建好之后被调用的，init给对象的实例变量赋值，说明得事先存在实例变量，实例变量属于对象，实例变量存在则对象肯定也已经存在了。所以说对象存在了，则实例变量存在，实例变量存在则才可使用/调用init给实例变量赋值。 也就是： __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。 类方法 如下场景：\n假设我有一个学生类和一个班级类，想要实现的功能为： 学生类继承自班级类，每实例化一个学生对象，班级人数都能增加； 最后，我想定义一些学生，获得班级中的总人数。\n要求： 必须通过班级类获取所有的学生对象的个数 不能创建班级对象，只能创建学生对象 思路： 需要在班级类中定义一个变量，让该变量记录学生的人数（每创建好一个学生对象则让班级类中的该变量进行加1操作），那么该变量如何创建（类变量or实例变量）？ 应该创建类变量：上述要求明确指明了，不可以创建班级对象，因此无法访问实例变量，所以应该创建一个类变量。 如果班级类中有一个类变量，该类变量记录学生的个数，需要给该类变量提供一个访问的接口，该接口应该使用类方法getNum来实现。类方法可以直接被班级类名访问。 当每创建好一个学生对象，如何同步使得班级类中的类变量num进行加一操作呢？ 在班级类中提供一个类方法addNum，该类方法可以给num类变量进行加一操作。该方法必须保证，当创建好一个学生对象的时候被调用一次。 如何保证每创建好一个学生对象让addNum这个类方法调用一次呢？ 需要在班级类中重写new方法（该new方法是可以继承给学生这个子类）,该new方法可以继承给Student子类，因此每创建一个子类对象，就会调用一次new方法，则在new方法中就可以执行给num类变量进行加一操作。 class ClassRoom(): num = 0 #记录学生对象的个数 #类方法是用来显示计数器num的数值 @classmethod def getNum(cls): print(cls.num) #是用来给num进行加一操作，该方法必须保证，当创建好一个学生对象的时候被调用一次 @classmethod def addNum(cls): cls.num += 1 #new最终是可以被继承给Student这个子类 def __new__(cls, *args, **kwargs): ClassRoom.addNum() return super().__new__(cls) class Student(ClassRoom): def __init__(self,name): self.name = name s1 = Student(\u0026#39;zhangsan\u0026#39;) s2 = Student(\u0026#39;lisi\u0026#39;) s3 = Student(\u0026#39;wangwu\u0026#39;) s4 = Student(\u0026#39;bobo\u0026#39;) ClassRoom.getNum() 成员保护和访问限制 在类的内部，有各种变量和方法。这些数据成员，可以在类的外部通过实例或者类名进行调用，例如：\nclass Student(): def __init__(self,name): self.name = name def study(self): print(\u0026#39;正在学习！\u0026#39;) s = Student(\u0026#39;lisi\u0026#39;) s.study() 上面的调用方式是我们大多数情况下都需要的，但是往往我们也不希望所有的变量和方法能被外部访问，需要针对性地保护某些成员，限制对这些成员的访问。这样的程序才是健壮、可靠的，也符合业务的逻辑。\n在Python中，如果要让内部成员不被外部访问，可以在成员的名字前加上两个下划线__，这个成员就变成了一个私有成员（private）。私有成员只能在类的内部访问，外部无法访问。\nclass Student(): def __init__(self,name): #name属性就变成了私有属性 self.__name = name def study(self): #可以访问私有成员属性 print(\u0026#39;正在学习！学习的人员是:\u0026#39;,self.__name) s = Student(\u0026#39;lisi\u0026#39;) s.study() print(s.__name) #无法访问私有成员 思考：私有成员是否可以被子类继承？\nclass Person(): def __init__(self,p): #私有成员 self.__p = p class Student(Person): def get_p(self): print(self.__p) s = Student(1) print(s.get_p()) #无法访问私有成员 #程序执行会报错！ 注意：私有成员是无法被继承的。 那么，以双下划线开头的数据成员是不是一定就无法从外部访问呢？其实也不是！本质上，从内部机制原理讲，外部不能直接访问__age是因为Python解释器对外把__age变量改成了_People__age，也就是_类名__age（类名前是一个下划线）。因此，投机取巧的话，你可以通过_ People__age在类的外部访问__age变量：\nclass Person(): def __init__(self,p): #私有成员 self.__p = p p = Person(1) print(p._Person__p) #无法访问私有成员 也就是说：Python的私有成员和访问限制机制是“假”的，没有从语法层面彻底限制对私有成员的访问。这一点和常量的尴尬地位很相似。\nreflect反射 首先，我们要区分两个概念——“标识名”和“字符串”。两者字面上看起来一样，却是两种东西，比如下面的func函数和字符串“func”：\ndef func(): pass s = \u0026#34;func()\u0026#34; #字符串，不是函数调用 前者是函数func的函数名，后者只是一个叫“func”的字符串，两者是不同的事物。我们可以用func()的方式调用函数func，但我们不能用\u0026quot;func\u0026rdquo;()的方式调用函数。说白了就是，不能通过字符串来调用名字看起来相同的函数！\n实例分析\n考虑有这么一个场景：需要根据用户输入url的不同，调用不同的函数，实现不同的操作，也就是一个WEB框架的url路由功能。\n首先，有一个commons.py文件，它里面有几个函数，分别用于展示不同的页面。\n# commons.py def login(): print(\u0026#39;这是登录页面！\u0026#39;) def logout(): print(\u0026#39;这是退出页面\u0026#39;) def home(): print(\u0026#39;这是主页面\u0026#39;) 其次，有一个visit.py文件，作为程序入口，接收用户输入，并根据输入展示相应的页面\n# visit.py import commons def run(): inp = input(\u0026#39;请输入您要访问的网址:\u0026#39;) if inp == \u0026#39;login\u0026#39;: commons.login() elif inp == \u0026#39;logout\u0026#39;: commons.logout() elif inp == \u0026#39;home\u0026#39;: commons.home() else: print(\u0026#39;404\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: run() 运行visit.py，输入home，页面结果如下：\n请输入您想访问页面的url： home 这是网站主页面！ 这就实现了一个简单的url路由功能，根据不同的url，执行不同的函数，获得不同的页面。\n然而，让我们思考一个问题，如果commons文件里有成百上千个函数呢(这很常见)？难道在visit模块里写上成百上千个elif？显然这是不可能的！那么怎么办？\n仔细观察visit.py中的代码，会发现用户输入的url字符串和相应调用的函数名好像！\n如果能用这个字符串直接调用函数就好了！但是，前面已经说了字符串是不能用来调用函数的。为了解决这个问题，Python提供了反射机制，帮助我们实现这一想法!\n现在将前面的visit.py修改一下，代码如下:\n# visit.py import commons def run(): inp = input(\u0026#39;请输入您要访问的网址:\u0026#39;) #inp == \u0026#34;login\u0026#34; func = getattr(commons,inp) #func == login func() #login() if __name__ == \u0026#39;__main__\u0026#39;: run() func = getattr(commons,inp)语句是关键，通过getattr()函数，从commons模块里，查找到和inp字符串“外形”相同的函数名，并将其返回，然后赋值给func变量。变量func此时就指向那个函数，func()就可以调用该函数。\ngetattr()函数的使用方法：接收2个参数，前面的是一个类或者模块，后面的是一个字符串，注意了！是个字符串！\n这个过程就相当于把一个字符串变成一个函数名的过程。这是一个动态访问的过程，一切都不写死，全部根据用户输入来变化。\n瑕疵：前面的代码还有个小瑕疵，那就是如果用户输入一个非法的url，比如jpg，由于在commons里没有同名的函数，肯定会产生运行错误\n那怎么办呢？python提供了一个hasattr()的内置函数，用法和getattr()基本类似，它可以判断commons中是否具有某个成员，返回True或False。现在将代码修改一下：\n# visit.py import commons def run(): inp = input(\u0026#39;请输入您要访问的网址:\u0026#39;) if hasattr(commons,inp): func = getattr(commons,inp) func() else: print(\u0026#39;404\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: run() 这下就没有问题了！通过hasattr()的判断，可以防止非法输入导致的错误，并将其统一定位到错误页面。\n单例模式 单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于被外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。\n单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n应用场景\n比如,某个服务器的配置信息存在在一个文件中,客户端通过AppConfig类来读取配置文件的信息.如果程序的运行的过程中,很多地方都会用到配置文件信息,则就需要创建很多的AppConfig实例,这样就导致内存中有很多AppConfig对象的实例,造成资源的浪费.其实这个时候AppConfig我们希望它只有一份,就可以使用单例模式.\nclass Singleton(): def __new__(cls, *args, **kwargs): if not hasattr(cls,\u0026#39;instance\u0026#39;): Singleton.instance = super().__new__(cls) return Singleton.instance s1 = Singleton() s2 = Singleton() print(id(s1),id(s2)) 链表 链表就是用来修正/优化列表存在的某一个弊端的。\n列表存在的弊端：\n列表开启的内存空间是连续的,导致如果向列表中增加或者删除元素，需要将增加或者删除元素后面的所有元素批量移动，该行为会严重影响列表元素添加或者删除的性能。 列表是不适合进行高频的元素添加和删除操作的。 分析：\n链表如何进行列表弊端的优化？ 优化核心在于，元素的内存空间不可以连续开辟，因此链表的内存空间不是连续开辟，则意味着链表就丧失了索引的机制。 链表的作用： 如果需求需要进行高频的元素增加和删除，则使用链表最合适。 class Node(): def __init__(self,item): self.item = item self.next = None class Link(): def __init__(self): #head指向第一个节点 self.head = None def addHead(self,item): #向链表头部插入新的节点 node = Node(item) node.next = self.head self.head = node def travel(self): #遍历链表中节点的item # print(self.head.item) # print(self.head.next.item) # print(self.head.next.next.item) # print(self.head.next.next.next.item) # print(self.head.next.next.next.next.item) cur = self.head while cur != None: print(cur.item) cur = cur.next def isEmpty(self): #判定链表是否为空，空返回True，否则返回False return self.head == None def length(self): #返回链表中节点的个数 count = 0 #记录节点的个数 cur = self.head while cur != None: count += 1 cur = cur.next return count #向链表尾部添加新的节点 def append(self,item): node = Node(item) if self.isEmpty():#如果链表为空 self.head = node else:#链表为非空的情况 pre = None #pre要指向cur前面的一个节点 cur = self.head while cur != None: pre = cur cur = cur.next #循环结束后cur指向了None而pre指向了最后一个节点 pre.next = node #将新的节点插入到pos表示的位置中 def insertNode(self,item,pos): node = Node(item) pre = None cur = self.head if pos == 0: self.addHead(item) return for i in range(pos): pre = cur cur = cur.next pre.next = node node.next = cur #从链表中删除item表示的节点 def removeNode(self,item): pre = None cur = self.head if self.head.item == item:#删除的是第一个节点 self.head = cur.next return while cur != None: if cur.item == item: #条件成立则cur就是我们要删除的节点 pre.next = cur.next break else: pre = cur cur = cur.next link = Link() link.addHead(1) link.addHead(2) link.addHead(3) link.addHead(4) link.addHead(5) link.append(6) link.removeNode(5) link.travel() ","permalink":"https://canw0916.github.io/en/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","summary":"面向对象 面向过程VS面向对象 面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线","title":"面向对象"},{"content":"模块与包 模块 模块介绍 在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。\n为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。而这样的一个py文件在Python中称为模块（Module）。\n模块是组织代码的更高级形式，大大提高了代码的阅读性和可维护性。\n模块一共四种：\n解释器内建模块 python标准库 第三方模块 应用程序自定义模块 另外，使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。\n模块导入 \u0026#39;\u0026#39;\u0026#39; # 方式1：导入一个模块 import 模块名 import 模块名 as 别名 # 方式2：导入多个模块 import ( 模块1 模块2 ) import 模块1,模块2 # 方式3：导入成员变量 from 模块名 import 成员变量 from 模块名 import * \u0026#39;\u0026#39;\u0026#39; 导入模块时会执行模块，多次导入只执行一次。\n案例：\ncal.py logger.py main.py #cal.py def add(x,y): return x + y def mul(x,y): return x * y print(\u0026#39;这是cal模块文件\u0026#39;) #logger.py def get_logger(): print(\u0026#39;打印日志！\u0026#39;) print(\u0026#39;这是logger模块文件\u0026#39;) #main.py import cal #导入了cal模块 import logger #导入和logger模块 #注意：import导入模块，就好比是将模块中的代码执行了 from cal import mul #将cal模块中的mul成员进行导入 #调用用了cal模块中的add函数 result = cal.add(1,2) print(result) c = mul(3,4) print(c) #调用了logger模块中的get_logger函数 logger.get_logger() 注意：执行源文件的名字一定不要和模块的名字同名 __name__ __name__是python内置变量，存储的是当前模块名称。\n对于很多编程语言来说，程序都必须要有一个入口。像C，C++都有一个main函数作为程序的入口，而Python作为解释性脚本语言，没有一个统一的入口，因为Python程序运行时是从模块顶行开始，逐行进行翻译执行，所以，最顶层（没有被缩进）的代码都会被执行，所以Python中并不需要一个统一的main()作为程序的入口。\n在刚才的案例中三个模块都打印一次__name__\n#cal.py def add(x,y): return x + y def mul(x,y): return x * y print(\u0026#39;这是cal模块文件,__name__内置变量的值为：\u0026#39;,__name__) #logger.py def get_logger(): print(\u0026#39;打印日志！\u0026#39;) print(\u0026#39;这是logger模块文件,__name__内置变量的值为：\u0026#39;,__name__) #main.py：作为执行文件 import cal #导入了cal模块 import logger #导入和logger模块 print(\u0026#39;main文件的__name__这个内置变量为：\u0026#39;,__name__) 结果为：\n这是cal模块文件,__name__内置变量的值为： cal 这是logger模块文件,__name__内置变量的值为： logger main文件的__name__这个内置变量为： __main__ 通过结果发现__name__只有在执行模块中打印__main__,在其他导入模块中打印各自模块的名称。\n所以，__name__可以有以下作用：\n利用__name__==\u0026quot;__main__\u0026quot;声明程序入口。 可以对导入的模块进行功能测试 包 什么是包 当一个项目中模块越来越多，维护和开发不是那么高效的时候，我们可以引入一种比模块更高级语法：包。\n包是对相关功能的模块py文件的组织方式。\n包可以理解为文件夹，更确切的说，是一个包含__init__文件的文件夹。\n导入包的语法 import 包名[.模块名 [as 别名]] from 包名 import 模块名 [as 别名] from 包名.模块名 import 成员名 [as 别名] 案例：将上面案例中的cal .py文件放到utils包中管理，logger.py放到logger包中管理。\n-- demo main.py #执行文件 -- m_log #包 __init__.py logger.py #存储在logger包中的一个模块 from m_log import logger logger.get_logger() #调用了logger模块中的get_logger函数 常见模块 time模块 # \u0026lt;1\u0026gt; 时间戳 \u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; time.time() 1493136727.099066 # \u0026lt;2\u0026gt; 时间字符串 \u0026gt;\u0026gt;\u0026gt; time.strftime(\u0026#34;%Y-%m-%d %X\u0026#34;) #%Y:年 %m：月 %d：天 %X:时分秒 \u0026#39;2017-04-26 00:32:18\u0026#39; #\u0026lt;3\u0026gt; 程序暂定固定的时间 import time print(\u0026#39;正在下载数据......\u0026#39;) time.sleep(2) #程序暂定n秒 print(\u0026#39;下载成功！\u0026#39;) 小结：时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的\nimport time #计算一组程序执行的耗时 start = time.time() #测试代码 num = 0 for i in range(10000000): num += 1 print(num) ############################## print(\u0026#39;总耗时：\u0026#39;,time.time()-start) random模块 \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.random() # 大于0且小于1之间的小数 0.7664338663654585 \u0026gt;\u0026gt;\u0026gt; random.randint(1,5) # 大于等于1且小于等于5之间的整数 2 \u0026gt;\u0026gt;\u0026gt; random.randrange(1,3) # 大于等于1且小于3之间的整数 1 \u0026gt;\u0026gt;\u0026gt; random.choice([1,\u0026#39;23\u0026#39;,[4,5]]) # 返回列表中的随机一个元素 1 \u0026gt;\u0026gt;\u0026gt; random.sample([1,\u0026#39;23\u0026#39;,[4,5]],2) # 列表元素任意2个随机组合 [[4, 5], \u0026#39;23\u0026#39;] \u0026gt;\u0026gt;\u0026gt; random.uniform(1,3) #大于1小于3的小数 1.6270147180533838 \u0026gt;\u0026gt;\u0026gt; item=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; random.shuffle(item) # 直接将原来的列表元素打乱次序，不会返回一个新列表 \u0026gt;\u0026gt;\u0026gt; item [5, 1, 3, 7, 9] os模块 os模块是与操作系统交互的一个接口\nimport os os.getcwd() # 获取当前工作目录，即当前python脚本工作的目录路径 os.chdir(\u0026#34;dirname\u0026#34;) # 改变当前脚本工作目录；相当于shell下cd os.curdir # 返回当前目录: (\u0026#39;.\u0026#39;) os.pardir # 获取当前目录的父目录字符串名：(\u0026#39;..\u0026#39;) os.makedirs(\u0026#39;dirname1/dirname2\u0026#39;) # ***可生成多层递归目录 os.removedirs(\u0026#39;dirname1\u0026#39;) # ***若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(\u0026#39;dirname\u0026#39;) #*** 生成单级目录；相当于shell中mkdir dirname os.rmdir(\u0026#39;dirname\u0026#39;) # *** 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(\u0026#39;dirname\u0026#39;) # ***列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() #*** 删除一个文件 os.rename(\u0026#34;oldname\u0026#34;,\u0026#34;newname\u0026#34;) #*** 重命名文件/目录 os.stat(\u0026#39;path/filename\u0026#39;) # 获取文件/目录信息 os.sep # 输出操作系统特定的路径分隔符，win下为\u0026#34;\\\\\u0026#34;,Linux下为\u0026#34;/\u0026#34; os.linesep # 输出当前平台使用的行终止符，win下为\u0026#34;\\t\\n\u0026#34;,Linux下为\u0026#34;\\n\u0026#34; os.pathsep # 输出用于分割文件路径的字符串 win下为;,Linux下为: os.name # 输出字符串指示当前使用平台。win-\u0026gt;\u0026#39;nt\u0026#39;; Linux-\u0026gt;\u0026#39;posix\u0026#39; os.system(\u0026#34;bash command\u0026#34;) # 运行shell命令，直接显示 os.environ # 获取系统环境变量 os.path.abspath(path) # ***返回path规范化的绝对路径 os.path.split(path) # 将path分割成目录和文件名二元组返回 os.path.dirname(path) # 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) # 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path) # ***如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) # 如果path是绝对路径，返回True os.path.isfile(path) # ***如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) # ***如果path是一个存在的目录，则返回True。否则返回False os.path.join(path1[, path2[, ...]]) # 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) # 返回path所指向的文件或者目录的最后访问时间 os.path.getmtime(path) # 返回path所指向的文件或者目录的最后修改时间 os.path.getsize(path) # ***返回path的大小 序列化模块：json（重点） 序列化： 将python中的字典，列表对象转换成指定形式字符串\n反序列化：将指定格式的字符串转换成字典，列表对象\n基本使用\nimport json dic = { \u0026#39;hobby\u0026#39;:[\u0026#39;football\u0026#39;,\u0026#39;pingpang\u0026#39;,\u0026#39;smoke\u0026#39;], \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:97.6, \u0026#39;name\u0026#39;:\u0026#39;zhangsan\u0026#39; } #序列化：将字典对象转换成了json格式的字符串 r = json.dumps(dic) print(r) import json str = \u0026#39;{\u0026#34;hobby\u0026#34;: [\u0026#34;football\u0026#34;, \u0026#34;pingpang\u0026#34;, \u0026#34;smoke\u0026#34;], \u0026#34;age\u0026#34;: 20, \u0026#34;score\u0026#34;: 97.6, \u0026#34;name\u0026#34;: \u0026#34;zhangsan\u0026#34;}\u0026#39; #反序列化：将字符串转换成了字典对象 dic = json.loads(str) print(dic) #持久化存储字典 import json dic = { \u0026#39;hobby\u0026#39;:[\u0026#39;football\u0026#39;,\u0026#39;pingpang\u0026#39;,\u0026#39;smoke\u0026#39;], \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:97.6, \u0026#39;name\u0026#39;:\u0026#39;zhangsan\u0026#39; } fp = open(\u0026#39;./dic.json\u0026#39;,\u0026#39;a\u0026#39;) #dump首先将dic字典进行序列化，然后将序列化后的结果写入到了fp表示的文件中 json.dump(dic,fp) fp.close() import json fp = open(\u0026#39;./dic.json\u0026#39;,\u0026#39;r\u0026#39;) #load将文件中的字符串数据进行读取，且将其转换成字典类型 dic = json.load(fp) print(dic) fp.close() 正则模块（重点） 什么是正则表达式？\n正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（例如，*，+，？等）。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 常用的正则标识\n单字符： . : 除换行以外所有字符 [] ：[aoe] [a-w] 匹配集合中任意一个字符 \\d ：数字 [0-9] 数量修饰： * : 任意多次 \u0026gt;=0 + : 至少1次 \u0026gt;=1 ? : 可有可无 0次或者1次 {m} ：固定m次 hello{3,} {m,} ：至少m次 {m,n} ：m-n次 边界： $ : 以某某结尾 ^ : 以某某开头 分组： (ab) 命名分组： (?P\u0026lt;name\u0026gt;正则表达式)，name是一个合法的标识符 贪婪模式： .* 非贪婪（惰性）模式： .*? 正则在python中的使用\n基于re模块进行正则匹配操作\n主要使用re模块中的findall进行指定规则的匹配\nfindall(str,rule) str表示即将进行匹配的原始字符串数据 rule表示指定规则的正则表达式 findall返回的是列表，列表中存储匹配到的指定内容 练习\nimport re #提取170 string = \u0026#39;我喜欢身高为170的女孩\u0026#39; ex = \u0026#39;\\d+\u0026#39; result = re.findall(ex,string) print(result[0]) ##################################################################### #提取出http和https key=\u0026#39;http://www.baidu.com and https://boob.com\u0026#39; ex = \u0026#39;https?\u0026#39; result = re.findall(ex,key) print(result) ##################################################################### import re #提取出hello key=\u0026#39;lalala\u0026lt;hTml\u0026gt;hello\u0026lt;/HtMl\u0026gt;hahah\u0026#39; ex = \u0026#39;\u0026lt;hTml\u0026gt;(.*)\u0026lt;/HtMl\u0026gt;\u0026#39; result = re.findall(ex,key) print(result) ##################################################################### #提取出hit. key=\u0026#39;bobo@hit.edu.com\u0026#39;#想要匹配到hit. # ex = \u0026#39;h.*\\.\u0026#39; #贪婪模式 ex = \u0026#39;h.*?\\.\u0026#39; #？将正则的贪婪模式调整为非贪婪模式。默认下为贪婪模式 result = re.findall(ex,key) print(result) ##################################################################### #匹配sas和saas key=\u0026#39;saas and sas and saaas\u0026#39; ex = \u0026#39;sa{1,2}s\u0026#39; result = re.findall(ex,key) print(result) ##################################################################### key = \u0026#39;你好我的手机号是13222222222你记住了吗\u0026#39; ex = \u0026#39;1[3,5,7,8,9]\\d{9}\u0026#39; result = re.findall(ex,key) print(result) ##################################################################### #提取ip和端口号 import re s = \u0026#34;my computer ip is \u0026#39;230.192.168.78\u0026#39;,and port is 8889 you got it?\u0026#34; rep = re.search(r\u0026#34;ip is \u0026#39;(?P\u0026lt;ip\u0026gt;\\d+\\.\\d+\\.\\d+\\.\\d+).* port is (?P\u0026lt;port\u0026gt;\\d+)\u0026#34;,s) rep.group(\u0026#39;ip\u0026#39;),rep.group(\u0026#39;port\u0026#39;)#通过命名分组引用分组 ","permalink":"https://canw0916.github.io/en/posts/tech/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/","summary":"模块与包 模块 模块介绍 在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。 为了编写可维护的代码，我","title":"模块与包"},{"content":"文件操作 引言 到目前为止，我们做的一切操作，都是在内存里进行的，这样会有什么问题吗？如果一旦断电或发生意外关机了，那么你辛勤的工作成果将瞬间消失。是不是感觉事还挺大的呢？现在你是否感觉你的编程技巧还缺了点什么呢？是的，我们还缺少将数据在本地文件系统进行持久化的能力，白话讲就是文件的读写能力。 文件打开 Python内置了一个open()方法，用于对文件进行读写操作。使用open()方法操作文件就像把大象塞进冰箱一样，可以分三步走，一是打开文件，二是操作文件，三是关闭文件。\n文件句柄/文件描述符\nopen()方法的返回值是一个file对象，可以将它赋值给一个变量，这个变量就是所谓的文件句柄。 file对象： 可以调用read()和write()方法，对打开的文件进行读写操作。 open方法的语法\nf = open(filename, mode) filename： 一个包含了你要访问的文件名称的字符串值，通常是一个文件路径。 文件路径作用：定位到指定文件 mode： 打开文件的模式，有很多种，默认是只读方式r。 文件打开的模式：\n常规文件打开模式操作演示\nb模式： 二进制模式，通常用来读取图片、视频等二进制文件。注意，它在读写的时候是以bytes类型读写的，因此获得的是一个bytes对象而不是字符串。在这个读写过程中，需要自己指定编码格式。在使用带b的模式时一定要注意传入的数据类型，确保为bytes类型。 +模式： 对于w+模式，在读写之前都会清空文件的内容，建议不要使用！ 对于a+模式，永远只能在文件的末尾写入，(常用)！ 对于r+模式，也就是读写模式，配合seek()和tell()方法，可以实现更多操作。 编码问题\n要读取非UTF-8编码的文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件 遇到有些编码不规范的文件，可能会抛出UnicodeDecodeError异常，这表示在文件中可能夹杂了一些非法编码的字符。遇到这种情况，可以提供errors=’ignore‘参数，表示如果遇到编码错误后如何处理。 文件对象操作 每当我们用open方法打开一个文件时，将返回一个文件对象。这个对象内置了很多操作方法。\nf.read(size) #size读取数据的个数\n读取一定大小的数据, 然后作为字符串或字节对象返回。size是一个可选的数字类型的参数，用于指定读取的数据量。当size被忽略了或者为负值，那么该文件的所有内容都将被读取并且返回。 注意： 如果文件体积较大，请不要使用read()方法一次性读入内存，而是read(512)这种一点一点的读。 f.readline()\n从文件中读取一行n内容。换行符为\u0026rsquo;\\n\u0026rsquo;。如果返回一个空字符串，说明已经已经读取到最后一行。这种方法，通常是读一行，处理一行，并且不能回头，只能前进，读过的行不能再读了。 f.readlines()\n将文件中所有的行，一行一行全部读入一个列表内，按顺序一个一个作为列表的元素，并返回这个列表。readlines方法会一次性将文件全部读入内存，所以也存在一定的风险。但是它有个好处，每行都保存在列表里，可以随意存取。 #需求：读取文件中的数据 fp = open(\u0026#39;./test.txt\u0026#39;,\u0026#39;r\u0026#39;) text = fp.read(10) #读取指定字节的数据 text_line = fp.readline() #一次读取一行数据 text_lines = fp.readlines() #读取多行数据，返回一个列表 print(text_lines) fp.close() 总结：\n几种不同的读取和遍历文件的方法比较：如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便。普通情况，使用for循环更好，速度更快。 f.write()\n将字符串或bytes类型的数据写入文件内。write()动作可以多次重复进行，其实都是在内存中的操作，并不会立刻写回硬盘，直到执行close()方法后，才会将所有的写入操作反映到硬盘上。在这过程中，如果想将内存中的修改，立刻保存到硬盘上，可以使用f.flush()方法。\nfp = open(\u0026#39;./test123.txt\u0026#39;,\u0026#39;w\u0026#39;) fp.write(\u0026#39;hello bobo\u0026#39;) fp.close() #将文件内容清空，在写入新数据 fp = open(\u0026#39;./test123.txt\u0026#39;,\u0026#39;a\u0026#39;) fp.write(\u0026#39;hello bobo\u0026#39;) fp.close() #在文件数据末尾追加数据 fp.tell()（了解）\n返回文件读写指针当前所处的位置,它是从文件开头开始算起的字节数。一定要注意了，是字节数，不是字符数。\nfp = open(\u0026#39;./test123.txt\u0026#39;,\u0026#39;w\u0026#39;) # fp.write(\u0026#39;hello bobo\u0026#39;) print(fp.tell()) fp.close() fp.seek()（了解）\n如果要改变文件指针的位置, 可以使用fp.seek(offset, from_what)方法。seek()经常和tell()方法配合使用。\nfrom_what\n如果是0表示从文件开头计算 如果是1表示从文件读写指针的当前位置开始计算 2表示从文件的结尾开始计算，默认为0 offset：表示偏移量\nseek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字节 seek(x,1) ： 表示从当前位置往后移动x个字节 seek(-x,2)：表示从文件的结尾往前移动x个字节 fp = open(\u0026#39;./test.txt\u0026#39;,\u0026#39;r\u0026#39;) fp.seek(9,0) text = fp.read(5) print(text) fp.close() f.close()\n关闭文件对象。当处理完一个文件后，调用f.close()来关闭文件并释放系统的资源。文件关闭后，如果尝试再次调用该文件对象，则会抛出异常。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了，或者更糟糕的结果。也就是说大象塞进冰箱后，一定不要忘记关上冰箱的门。 with关键字 with关键字用于Python的上下文管理器机制。为了防止诸如open这一类文件打开方法在操作过程出现异常或错误，或者最后忘了执行close方法，文件非正常关闭等可能导致文件泄露、破坏的问题。Python提供了with这个上下文管理器机制，保证文件会被正常关闭。在它的管理下，不需要再写close语句。注意缩进。\nwith open(\u0026#39;./test123.txt\u0026#39;,\u0026#39;r\u0026#39;) as fp: #fp = open() text = fp.read(5) print(text) #上下两组代码功效一样 fp = open(\u0026#39;./test123.txt\u0026#39;,\u0026#39;r\u0026#39;) text = fp.read(5) print(text) fp.close() 对图片，音频，视频，压缩包等二进制的数据进行文件读写操作\n实现一个图片文件的拷贝\n1.打开一个图片文件，读取其二进制的数据\n2.将读取到的数据写入到另一个路径下\nfp = open(\u0026#39;bobo.jpg\u0026#39;,\u0026#39;rb\u0026#39;) #r是读取文本数据，rb是读取二进制数据 img_data = fp.read() #读取到了图片的二进制数据 #将图片的二进制数据写到另一个路径下 fp1 = open(\u0026#39;/Users/zhangxiaobo/Desktop/bobo123.jpg\u0026#39;,\u0026#39;wb\u0026#39;) fp1.write(img_data) fp.close() fp1.close() 练习：登录注册 \u0026#39;\u0026#39;\u0026#39; 需求：注册功能 1.让用户录入用户名，密码，重复密码，手机号基本信息 2.检测两次输入的密码是否一致，一致则注册成功，否则注册失败 3.注册成功后需要将用户信息存储到文件中进行保存 \u0026#39;\u0026#39;\u0026#39; def regist(): #让用户录入用户名，密码，重复密码，手机号基本信息 print(\u0026#39;------欢迎来到注册页面--------\u0026#39;) username = input(\u0026#39;输入注册的账号：\u0026#39;) password = input(\u0026#39;输入注册的密码：\u0026#39;) repeatpwd = input(\u0026#39;重复密码:\u0026#39;) phonenum = input(\u0026#39;手机号：\u0026#39;) #检测两次输入的密码是否一致，一致则注册成功，否则注册失败 if password == repeatpwd:#==可以判断两个字符串是否一样： #两次密码一致：注册成功，将用户信息写入到文件保存 with open(\u0026#39;userData.txt\u0026#39;,\u0026#39;a+\u0026#39;) as fp: #\\n表示回车换行的意思 fp.write(username+\u0026#39;-\u0026#39;+password+\u0026#39;-\u0026#39;+phonenum+\u0026#39;\\n\u0026#39;) print(\u0026#39;恭喜您注册成功，账号为：\u0026#39;,username) else:#两次密码不一致，注册失败 print(\u0026#39;两次密码不一致，注册失败，请重新注册！\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 登录功能： 1.让用户录入用户名，密码 2.验证登录状态 \u0026#39;\u0026#39;\u0026#39; def login(): #1.让用户录入用户名，密码 print(\u0026#39;------欢迎来到登录页面------\u0026#39;) username = input(\u0026#39;请输入登录的账号：\u0026#39;) password = input(\u0026#39;请输入登录的密码：\u0026#39;) #2,验证登录状态 #读取文件中的用户信息的数据 with open(\u0026#39;userData.txt\u0026#39;,\u0026#39;r\u0026#39;) as fp: #[bobo-123-222, jay-456-666] user_data_list = fp.readlines() #读取每一行数据，返回的是一个列表 for data in user_data_list: data = data.strip()#取出字符串中的回车 #切分字符串，取出用户名和密码即可 #s_data = [bobo,123,222] s_data = data.split(\u0026#39;-\u0026#39;) #从文件中获取的用户名和密码 f_username = s_data[0] f_password = s_data[1] #判断登录状态 flat = 0 #如果flat=0表示登录失败，为1表示登录成功 if username == f_username and password == f_password: flat = 1 #表示登录成功 break if flat == 1: print(\u0026#39;登录成功\u0026#39;) else: print(\u0026#39;登录失败\u0026#39;) login() # regist()#调用该函数完成注册功能 管理系统完整实现(自己拓展:了解)： import time def regist(): print(\u0026#39;\\n\\n欢迎来到注册页面\u0026#39;) print(\u0026#39;-------------\u0026#39;) username = input(\u0026#39;enter username:\u0026#39;) password = input(\u0026#39;enter password:\u0026#39;) repeatpwd = input(\u0026#39;repeat enter password:\u0026#39;) email = input(\u0026#39;enter email:\u0026#39;) #判定用户的注册状态 if password == repeatpwd: isHave = False#用户名是否重复的状态显示，isHave==True表示用户名重复 with open(\u0026#39;./userData.txt\u0026#39;,\u0026#39;r+\u0026#39;) as fp: #bobo-123-123@qq.com #jay-456-456@qq.com #读取文件中所有注册用户的用户名 user_data_list = fp.readlines() for user_data in user_data_list: userName = user_data.split(\u0026#39;-\u0026#39;)[0] if username == userName:#用户名重复 isHave = True if isHave == False: fp.write(username+\u0026#39;-\u0026#39;+password+\u0026#39;-\u0026#39;+email+\u0026#39;\\n\u0026#39;) print(\u0026#39;注册成功,三秒后自动跳转到登录页面......\u0026#39;) time.sleep(3) #暂停三秒 login() else: print(\u0026#39;注册失败，%s用户名已被占用！\u0026#39;%username) print(\u0026#39;是否重新注册？y/n\u0026#39;) c = input(\u0026#39;enter your choose:\u0026#39;) if c == \u0026#39;y\u0026#39; or c == \u0026#39;Y\u0026#39;: regist() else: exit() else: print(\u0026#39;两次密码不一致，注册失败！\u0026#39;) def insertBook(): title = input(\u0026#39;插入图书的名称:\u0026#39;) publish_date = input(\u0026#39;插入图书的出版时间:\u0026#39;) author = input(\u0026#39;插入图书的作者:\u0026#39;) publish = input(\u0026#39;插入图书的出版社:\u0026#39;) with open(\u0026#39;./bookData.txt\u0026#39;,\u0026#39;a\u0026#39;) as fp: fp.write(title+\u0026#39;-\u0026#39;+publish_date+\u0026#39;-\u0026#39;+author+\u0026#39;-\u0026#39;+publish+\u0026#39;\\n\u0026#39;) print(title,\u0026#39;插入成功！\u0026#39;) print(\u0026#39;是否继续插入？y/n\u0026#39;) c = input(\u0026#39;enter your choose:\u0026#39;) if c == \u0026#39;y\u0026#39; or c == \u0026#39;Y\u0026#39;: insertBook() else: manageView() def showBooks(): print(\u0026#39;\\n\\n\u0026#39;) with open(\u0026#39;./bookData.txt\u0026#39;,\u0026#39;r\u0026#39;) as fp: book_list = fp.readlines() for book in book_list: print(book) c = input(\u0026#39;返回主页面请按1:\u0026#39;) if c == \u0026#39;1\u0026#39;: manageView() def deleteBook(): #指定一个删除的条件 name = input(\u0026#39;请输入即将要删除的图书名称:\u0026#39;) with open(\u0026#39;./bookData.txt\u0026#39;,\u0026#39;r\u0026#39;) as fp: book_list = fp.readlines() for book in book_list: if name in book: book_list.remove(book) fp = open(\u0026#39;./bookData.txt\u0026#39;,\u0026#39;w\u0026#39;) for book in book_list: fp.write(book) fp.close() print(name,\u0026#39;被成功删除！3秒后自动跳转会主页面......\u0026#39;) time.sleep(3) manageView() def updateBook(): name = input(\u0026#39;请输入即将要修改图书的名字:\u0026#39;) with open(\u0026#39;./bookData.txt\u0026#39;,\u0026#39;r\u0026#39;) as fp: book_list = fp.readlines() for book in book_list: if name in book: old_author = book.split(\u0026#39;-\u0026#39;)[2] new_author = input(\u0026#39;请输入新的作者名称:\u0026#39;) new_book = book.replace(old_author,new_author) book_list.append(new_book) book_list.remove(book) break fp = open(\u0026#39;./bookData.txt\u0026#39;,\u0026#39;w\u0026#39;) for book in book_list: fp.write(book) print(\u0026#39;图书修改成功！等待3秒返回主页面......\u0026#39;) fp.close() time.sleep(3) manageView() def manageView(): print(\u0026#39;\\n\\n欢迎来到管理系统\u0026#39;) print(\u0026#39;1.查看所有图书\\n2.插入图书\\n3.删除图书\\n4.修改图书\\n5.返回主页面\\n\u0026#39;) choose = input(\u0026#39;enter your choose:\u0026#39;) if choose == \u0026#39;1\u0026#39;: showBooks() elif choose == \u0026#39;2\u0026#39;: insertBook() elif choose == \u0026#39;3\u0026#39;: deleteBook() elif choose == \u0026#39;4\u0026#39;: updateBook() else: main_view() def login(): print(\u0026#39;\\n\\n欢迎来到登录页面\u0026#39;) print(\u0026#39;-------------\u0026#39;) username = input(\u0026#39;enter username:\u0026#39;) password = input(\u0026#39;enter password:\u0026#39;) #判定登录状态 login_state = False with open(\u0026#39;./userData.txt\u0026#39;,\u0026#39;r\u0026#39;) as fp: user_data_list = fp.readlines() for user_data in user_data_list: un = user_data.split(\u0026#39;-\u0026#39;)[0] pw = user_data.split(\u0026#39;-\u0026#39;)[1] if username == un and password == pw: login_state = True break if login_state == True: manageView() else: print(\u0026#39;登录失败,是否返回主页面？y/n\u0026#39;) c = input(\u0026#39;enter your choose:\u0026#39;) if c == \u0026#39;y\u0026#39; or c == \u0026#39;Y\u0026#39;: main_view() else: exit() def findPwd(): un = input(\u0026#39;enter your username:\u0026#39;) em = input(\u0026#39;enter your email\u0026#39;) with open(\u0026#39;./userData.txt\u0026#39;,\u0026#39;r\u0026#39;) as fp: isFind = False user_data_list = fp.readlines() for user_data in user_data_list: username = user_data.split(\u0026#39;-\u0026#39;)[0] email = user_data.split(\u0026#39;-\u0026#39;)[2] #将email中的回车去掉 email = email.strip() if username == un and email == em: password = user_data.split(\u0026#39;-\u0026#39;)[1] print(\u0026#39;找回的密码为：\u0026#39;,password) isFind = True break if isFind == False: print(\u0026#39;密码找回失败，用户名和邮箱不匹配！\u0026#39;) def main_view(): print(\u0026#39;欢迎来到xxx管理系统\u0026#39;) print(\u0026#39;----------------\u0026#39;) print(\u0026#39;1.登录\\n2.注册\\n3.找回密码\\n4.退出\u0026#39;) choose = input(\u0026#39;请选择功能:\u0026#39;) if choose == \u0026#39;1\u0026#39;: login() elif choose == \u0026#39;2\u0026#39;: regist() elif choose == \u0026#39;3\u0026#39;: findPwd() elif choose == \u0026#39;4\u0026#39;: return #退出整个程序 else: print(\u0026#39;输入有误，程序退出！\u0026#39;) main_view() ","permalink":"https://canw0916.github.io/en/posts/tech/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","summary":"文件操作 引言 到目前为止，我们做的一切操作，都是在内存里进行的，这样会有什么问题吗？如果一旦断电或发生意外关机了，那么你辛勤的工作成果将瞬间消","title":"文件操作"},{"content":"变量的作用域 讲到了函数就必须介绍变量的作用域相关。\n作用域指的是变量的有效范围。变量并不是在哪个位置都可以访问的，访问权限取决于这个变量是在哪里赋值的，也就是在哪个作用域内赋的值。变量在哪个作用域内赋值，则表示该变量的作用域就是该区域，变量只可以在其作用域指定区域被访问。 通常而言，在编程语言中，变量的作用域从代码结构形式来看，有块级、函数、类、模块、包等由小到大的级别。但是在Python中，没有块级作用域，也就是类似if语句块、for语句块、while语句块，with上下文管理器等等是不存在作用域概念的，他们等同于普通的语句。\n核心：\n通常，函数内部的变量无法被函数外部访问，但内部可以访问；类内部的变量无法被外部访问，但类的内部可以。通俗来讲，就是内部代码可以访问外部变量，而外部代码通常无法访问内部变量。\n#下列程序存在的问题是什么？ age = 10 def func(): name = \u0026#39;bobo\u0026#39; print(age,name) func() print(name) def outer(): def inner(): print(\u0026#39;i am inner\u0026#39;) inner() return inner inner() 全局变量和局部变量 局部变量\n定义在函数内部的变量拥有一个局部作用域，被叫做局部变量 全局变量\n定义在函数外的拥有全局作用域的变量，被称为全局变量。（类、模块等同理） num = 123 #？ def func(): email = \u0026#39;www.123.com\u0026#39; #？ print(email,num) func() 注意： 所谓的局部变量是相对的。局部变量也有可能是更小范围内的变量的外部变量。 a = 1 #全局变量 def func(): b = 2 #局部变量 print(a) #全局变量可以在全局区域被访问 def inner(): c = 3 #更局部的变量 print(a) print(b) print(c) return inner result = func() result() global关键字 先来看一个例子\ntotal = 0 #全局变量 #函数定义 def plus(arg1,arg2): #arg1=10,arg2=20 #total是局部变量!只不过和外部的全局变量同名了而已！ total = arg1 + arg2 #total=30 print(\u0026#39;函数内的变量total=\u0026#39;,total) return total #函数调用 plus(10,20) print(\u0026#39;函数外部变量total=\u0026#39;,total) 很明显，函数plus内部通过total = arg1 + arg2语句，新建了一个局部变量total，它和外面的全局变量total是两码事。而如果我们，想要在函数内部修改外面的全局变量total呢？使用global关键字！\nglobal：\n指定当前变量使用外部的全局变量 total = 0 #全局变量 #函数定义 def plus(arg1,arg2): #arg1=10,arg2=20 global total #应用外部全局变量的声明 total = arg1 + arg2 #total=30 print(\u0026#39;函数内的变量total=\u0026#39;,total) return total #函数调用 plus(10,20) print(\u0026#39;函数外部变量total=\u0026#39;,total) 函数其他 我们将函数涉及到的其他几点进行讲解\nrange()函数 递归函数 匿名函数 range函数 range函数是内置函数，无须特别导入，在任何地方都可以直接使用它，下面看一下具体用法：\n1.提供一个数字参数，直接遍历数字：\nfor item in range(5): print(item) 只给一个数字类型参数，range会遍历从0到参数减1的数字。要特别注意，range默认从0开始，到参数减1，也就是左闭右开的规则，这也是Python很多地方的规则，比如切片。 2.也可以指定遍历的区间：\nfor item in range(1,5): print(item) 3.还可以指定步长，就像切片一样\nfor item in range(1,11,3): print(item) 4.但更多的时候是结合range和len函数，遍历一个序列的索引\nalist = [1,2,3,4,5] for i in range(len(alist)): print(alist[i]) 5.指定步长为-1可以倒序遍历\nfor i in range(6,1,-1): print(i) 递归函数 如果一个函数在内部调用了自身，这个函数就被称为递归函数。\ndef func(): print(\u0026#39;正在调用func函数\u0026#39;) func() func() What？函数可以自己调用自己？会不会进入死循环，永远退出不了？我们先看一个例子，典型的高斯求和问题，1+2+3+4+…+99+100,不使用递归的话，我们可以用循环，这么做：\ndef sum_number(n): sum = 0 for i in range(1,n+1): sum += i return sum result = sum_number(5) print(result) 但如果使用递归函数来写，是这样的：\ndef sum_number(n): if n == 1: return 1 return n + sum_number(n-1) print(sum_number(5)) 分析一下代码，当n小于等于0的时候，直接给出和值为0，这句不能省。当n大于0时，结果是n加上sum_number(n-1)。这里的sum_number(n-1)又是一次sum_number函数的调用，不过参数的值变成了n-1，要得sum_number(n)到的值就必须等待sum_number(n-1)的值被计算出来，同样要得到sum_number(n-1)的值必须等待sum_number(n-2)的值，如此一路推算下去，直到sum_number(0)，因为if语句的存在，它不需要等待sum_number(-1)的计算了，而是直接给出结果0。然后程序一路返回，直到回到最初的sum_number(n)，并给出最终结果。 递归最核心的思想是：\n每一次递归，整体问题都要比原来减小，并且递归到一定层次时，要能直接给出结果！ 递归的优点\n递归函数的优点是定义简单，代码量少，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 注意：\n使用递归函数需要注意防止递归深度溢出，在Python中，通常情况下，这个深度是1000层，超过将抛出异常。在计算机中，函数递归调用是通过栈（stack）这种数据结构实现的，每当进入一个递归时，栈就会加一层，每当函数返回一次，栈就会减一层。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 def sum_number(n): if n == 1: return 1 return n + sum_number(n-1) print(sum_number(5)) \u0026#39;\u0026#39;\u0026#39; 递归调用的执行过程： sum_number(5)：5 + sum_number(4) sum_number(4)：4 + sum_number(3) sum_number(3)：3 + sum_number(2) sum_number(2)：2 + sum_number(1) sum_number(1)：1 \u0026#39;\u0026#39;\u0026#39; 匿名函数 提问：\n刚开始编程的同学可能会遇到一个头疼的问题，就是变量或者函数命名的问题，虽然命名规范很简单，但是如果涉及到的操作过多给每一个操作的函数都起一个高可读性的名称，必然会挖空你的英语词汇量。 当我们在创建函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。这省去了我们挖空心思为函数命名的麻烦，也能少写不少代码，很多编程语言都提供这一特性。匿名函数用好了，会有画龙点睛的效果，没用好，就容易“画虎不成反类犬”，需要我们在平时的代码过程中，多学、多看、多琢磨。\n匿名函数的使用\nPython语言使用lambda关键字来创建匿名函数。 所谓匿名，即不再使用def语句这样标准的形式定义一个函数。 lambda只是一个表达式,而不是一个代码块，函数体比def简单很多。 仅仅能在lambda表达式中封装有限的逻辑。 定义语法： 其形式通常是这样的：lambda 参数: 表达式 例子：它相当于下面的函数：\ndef func(num): if num \u0026gt; 0: return 1 else: return 0 #该匿名函数就等同于上面的有名函数 result = lambda x:1 if x \u0026gt; 0 else 0 #x就是匿名函数的参数，0和1就是返回值 print(result(1)) #调用匿名函数 匿名函数只能有一个表达式，不用也不能写return语句，表达式的结果就是其返回值。\n","permalink":"https://canw0916.github.io/en/posts/tech/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%87%BD%E6%95%B0/","summary":"变量的作用域 讲到了函数就必须介绍变量的作用域相关。 作用域指的是变量的有效范围。变量并不是在哪个位置都可以访问的，访问权限取决于这个变量是在哪","title":"作用域和函数"},{"content":"函数 引言 什么是函数？\n前面在讲解Python数据类型的时候，我们已经接触过函数了。我们说，所谓的函数其实就是Python语言中的一种工具，基于该工具可以完成不同的具体操作。函数可以分为两种，一种是内置函数，另一种是自定义函数，我们可以这么理解： 内置函数： 内置函数其实就是Python语言的开发者已经给我们设计好的工具，我们可以直接使用这些已经被设计好的工具或者函数完成相关的操作 自定义函数： 当然，Python语言的开发者们也无法将我们在不同需求中要使用的操作都设计成不同的函数或者工具，那么我们也可以向开发者那样自行设计定制我们专属功能的工具函数。 案例：当你在野外露营的时候，如果想生火，如果你身上恰好带了打火机，则可以直接使用该工具自行完成生火操作，否则，你也可以自己利用现有环境下的资源自行制作取火工具。 那么，为什么要使用函数呢？\n第一： 函数的使用可以重用代码，省去重复性代码的编写，提高代码的重复利用率。如果程序中需要多次使用某种特定的功能，那么只需要编写一个合适的函数就可以了。程序可以在任何需要的地方调用该函数，并且同一个函数可以在不同的程序中调用，就像我们经常使用的print()和input()函数一样。 第二： 函数能封装内部实现，保护内部数据。很多时候，我们把函数看做“黑盒子”，即对应一定的输入会产生特定的结果或返回某个对象。往往函数的使用者并不是函数的编写者，函数的使用者对黑盒子的内部行为并不需要考虑，可以把精力投入到自身业务逻辑的设计而不是函数的实现细节。只有函数的设计者或者说编写者，才需要考虑函数内部实现的细节，如何暴露对外的接口，返回什么样的数据，也就是API的设计。 函数基础 自定义函数的使用要经过两个过程\n函数的定义（制定） 函数的调用（使用） 函数定义语法\ndef 函数名(参数)： #内部代码 return 表达式 def myFunc(): #函数定义的时候，函数体是不会被执行的 #函数体 a = 1 b = 2 c = a + b print(\u0026#39;a和b的计算结果为:\u0026#39;,c) 函数调用语法\n函数编写出来就是给人调用的。\n要调用一个函数，必须使用函数名后跟圆括号的方式才能调用函数。\n调用的同时要根据函数的定义体，提供相应个数和类型的参数，每个参数之间用逗号分隔，否则就会报错。\nmyFunc() #函数调用，函数定义中的函数体才会被执行 函数定义规范使用\n返回值 return语句 当一个函数被调用结束后，该函数势必已经将一组操作执行结束了，如果在操作执行结束后，想要将一个结果返回给调用者，则就可以使用return语句实现。 #返回一个表达式 def func(): return 1 + 2 #返回一个表达式 result = func() print(result) #不写return默认返回None(空) def func(): a = 10 b = 20 sum = a + b result = func() print(result) #返回多个结果 def func(): return 1,\u0026#39;two\u0026#39;,3.3 r1,r2,r3 = func() print(r1,r2,r3) ###################### def func(): return 1,\u0026#39;two\u0026#39;,3.3 result = func() #使用一个变量接收多个返回值，多个返回值会被封装到一个元组中 print(result) #return后面的代码无意义：程序执行到return语句后，表示函数调用结束 def func(): return \u0026#39;bobo\u0026#39; print(\u0026#39;i love bobo\u0026#39;) #会执行吗？不会执行的（报错）！ func() def outer(): print(\u0026#39;我是外部函数outer\u0026#39;) def inner(): print(\u0026#39;我是内部函数inner\u0026#39;) #想要调用inner函数？ outer() #如何调用inner这个内部函数呢？ def outer(): print(\u0026#39;我是外部函数outer\u0026#39;) def inner(): print(\u0026#39;我是内部函数inner\u0026#39;) return inner #返回的是内部函数名，不加括号的！ result = outer() # outer() == inner, result == inner result() # inner() #返回函数调用（了解） def outer(): print(\u0026#39;我是外部函数outer\u0026#39;) def inner(): print(\u0026#39;我是内部函数inner\u0026#39;) return inner() #return None outer() 闭包函数（简单了解即可）： 首先给出闭包函数的必要条件： 闭包函数必须返回一个函数对象/内部函数名 闭包函数返回的那个函数必须引用外部变量，而返回的那个函数内部不一定要return返回值 函数参数 增加函数的通用性\n#定义一个函数可以计算出两个数据的和 def my_add(): num1 = 1 num2 = 2 return num1 + num2 result = my_add() print(result) #局限性：只可以计算指定两个数的和，无法实现具有较高的通用性 #定义一个函数可以计算出两个数据的和:具有更强的通用性 def my_add(num1,num2): #num1=5,num2=9 return num1 + num2 result = my_add(5,9) print(result) 绝大多数函数在定义的时候需要接收一定数量的参数，然后根据实际调用时提供的参数的不同，输出不同的结果。注意将函数内部的参数名字，定义得和外部变量的名字一样是一种不好的习惯，它容易混淆思维，甚至发生错误。\n参数的两种称谓\n形参(形式参数) 函数定义时，制定的参数叫做形参 实参(实际参数) 函数调用时，传递的参数叫做实参 而我们通常讨论的参数，指的都是形参 参数传递\n函数通常都有参数，用于将外部的实际数据传入函数内部进行处理。但是，在处理不同数据类型的参数时，会有不同的情况发生。这一切都是因为以下一点。\nPython的函数参数传递的是实际数据的内存地址。 例子1：不可变类型参数\na = 1 def func(b): b = 2 print(\u0026#39;形参b的内存地址为:%s\u0026#39;%id(b)) print(\u0026#39;函数内部的b为：\u0026#39;,b) print(\u0026#39;变量a的内存地址为：\u0026#39;,id(a)) func(a) print(\u0026#39;函数调用后，函数外部的变量a为:\u0026#39;,a) 例子2：上面例子说的是不可变类型参数，如果是可变类型的，比如列表呢？\na = [1,2,3] def func(b): b.append(4) print(\u0026#39;变量b的内存地址为：\u0026#39;,id(b)) print(\u0026#39;函数内部的b为：\u0026#39;,b) print(\u0026#39;变量a的内存地址为：\u0026#39;,id(a)) func(a) print(\u0026#39;函数外部的变量a为：\u0026#39;,a) 调用函数时将列表对象a的地址传递给了函数内部的变量b。b.append(4)的时候，根据传进来的内存地址，找到[1,2,3]这个列表对象，在它的后面添加了4。\n可以看出，此时的a和b实际指向了同一个对象。为什么会这样？因为最关键的b.append(4)这句代码，它不同于“=”赋值语句，不会创建新的变量，而列表作为可变类型，具有append方法，这个方法只是对列表的一种调用而已。因此，a和b实际还是同一个对象。\n参数类型 参数的不同种类 定义函数时，参数的名字和位置确定下来，函数的接口就固定了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。Python函数的参数定义灵活度非常大。除了正常定义的位置参数外，还可以使用： 位置参数 默认参数 动态参数 位置参数 也叫必传参数或者顺序参数，是最重要的、也是必须在调用函数时明确提供的参数！位置参数必须按先后顺序，一一对应，个数不多不少的传递！\ndef add(a,b,c): return a+b+c x = y = 5 r1 = add(x,y,x) r2 = add(4,5,6) print(r1,r2) 上面例子中的a，b，c就是位置参数，我们在使用add(4, 5, 6)调用时，就是将4的地址传给a，5的传给b，6的传给c的一一对应传递。\n类似add(4, 5, 6, 7)、add(4)这种“画蛇添足”、“缺胳膊少腿”和“嫁错郎”类型的调用都是错误的。 注意: Python在做函数参数传递的时候不会对数据类型进行检查，理论上你传什么类型都可以！\ndef add(a,b,c): return a+b+c add(1,2,\u0026#39;haha\u0026#39;) 但是，上面的add函数，如果你传递了一个字符串和两个数字，结果是弹出异常，因为字符串无法和数字相加。\n这就是Python的弱数据类型和动态语言的特点。在简单、方便的时候，需要你自己去实现数据类型检查。 默认参数 在函数定义时，如果给某个参数提供一个默认值，这个参数就变成了默认参数，不再是位置参数了。在调用函数的时候，我们可以给默认参数传递一个自定义的值，也可以使用默认值。\ndef power(x,n=2): #x是位置参数，n是默认参数 return x * n power(10) power(10,4) 上面例子中的n就是个默认参数。默认参数可以简化函数的调用，在为最常用的情况提供简便调用的同时，还可以在特殊情况时传递新的值。\n默认参数的注意事项：\n默认参数必须在位置参数后面！ 使用参数名传递参数 def student(name,sex,age,classroom=\u0026#39;101\u0026#39;,tel=\u0026#39;1323333333\u0026#39;,address=\u0026#39;...\u0026#39;): pass #下述函数调动是否可以？ student(\u0026#39;jack\u0026#39;,\u0026#39;male\u0026#39;,17) #？ student(\u0026#39;tom\u0026#39;,\u0026#39;male\u0026#39;,18,\u0026#39;102\u0026#39;,\u0026#39;666\u0026#39;,\u0026#39;Beijing\u0026#39;) #？ student(\u0026#39;marry\u0026#39;,\u0026#39;female\u0026#39;,18,\u0026#39;102\u0026#39;,address=\u0026#39;SH\u0026#39;) #？ student(\u0026#39;mary\u0026#39;,\u0026#39;female\u0026#39;,address=\u0026#39;Bj\u0026#39;,18) #？ 首先先来看一道面试真题：输出程序运行后的结果\ndef func(a=[]): #将可变类型数据作为了默认参数的默认值 a.append(\u0026#39;A\u0026#39;) return a print(func()) print(func()) print(func()) 解释：\n因为Python函数体在被读入内存的时候，默认参数a指向的空列表对象就会被创建，并放在内存里了。因为默认参数a本身也是一个变量，保存了指向对象[]的地址。每次调用该函数，往a指向的列表里添加一个A。a没有变，始终保存的是指向列表的地址，变的是列表内的数据！ 动态参数 顾名思义，动态参数就是传入的参数的个数是动态的，可以是1个、2个到任意个，还可以是0个。在不需要的时候，你完全可以忽略动态函数，不用给它传递任何值。\nPython的动态参数有两种，分别是：\n*args **kwargs 这里面的关键是一个和两个星号的区别，而不是args和kwargs在名字上的区别 注意：\n动态参数，必须放在所有的位置参数和默认参数后面！ *args\n一个星号表示接收任意个参数。调用时，会将实际参数打包成一个元组传入形式参数。如果参数是个列表，会将整个列表当做一个参数传入。例如：\ndef func(*args):#动态参数 print(args) for param in args: print(param) #param就是接收到的每一个参数 func(1,2,3) 问题：\n通过循环args，我们可以获得传递的每个参数。但是li这个列表，我们本意是让它内部的1,2,3分别当做参数传递进去，但实际情况是列表本身被当做一个整体给传递进去了。怎么办呢？\ndef func(*args): print(args) for param in args: print(param) li = [1,2,3] func(li) 解决：\n使用一个星号！调用函数，传递实参时，在列表前面添加一个星号就可以达到目的了。实际情况是，不光列表，任何序列类型数据对象，比如字符串、元组都可以通过这种方式将内部元素逐一作为参数，传递给函数。而字典，则会将所有的key逐一传递进去。\ndef func(*args): print(args) for param in args: print(param) li = [1,2,3] func(*li) **kwargs\n两个星表示接受键值对的动态参数，数量任意。调用的时候会将实际参数打包成字典。例如：\ndef func(**kwargs): print(kwargs) func(k1=1,age=2,k3=2) 问题：\n而如果我们这样传递一个字典dic呢？我们希望字典内的键值对能够像上面一样被逐一传入。\ndef func(**kwargs): print(kwargs) dic = { \u0026#39;k1\u0026#39;:1, \u0026#39;age\u0026#39;:20, \u0026#39;k3\u0026#39;:3 } func(d = dic) 上述程序实际结果却是弹出错误，为什么？\n解释：\n因为这时候，我们其实是把dic当做一个位置参数传递给了func函数。而func函数并不接收任何位置函数。那怎么办呢？使用两个星号！ def func(**kwargs): print(kwargs) dic = { \u0026#39;k1\u0026#39;:1, \u0026#39;age\u0026#39;:20, \u0026#39;k3\u0026#39;:3 } func(**dic) 有了前面一个星号的基础，这里我们应该很好理解了。两个星号能将字典内部的键值对逐一传入**kwargs。\n万能参数\n当*args和kwargs组合起来使用，理论上能接受任何形式和任意数量的参数，在很多代码中我们都能见到这种定义方式。需要注意的是，*args必须出现在kwargs之前。 ","permalink":"https://canw0916.github.io/en/posts/tech/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/","summary":"函数 引言 什么是函数？ 前面在讲解Python数据类型的时候，我们已经接触过函数了。我们说，所谓的函数其实就是Python语言中的一种工具，基于","title":"函数基础"},{"content":"流程控制 流程控制指的是代码运行逻辑、分支走向、循环控制，是真正体现程序执行顺序的操作。\n程序是由语句构成，而流程控制语句 是用来控制程序中每条语句执行顺序的语句。可以通过控制语句实现更丰富的逻辑以及更强大的功能。几乎所有编程语言都有流程控制语句，功能也都基本相似。\n流程控制的意义\n流程控制体现了一种编程中的“因果关系”，也就是有什么样的因就产生什么样的果，例如有什么输入就会有相应的输出，同一个输入不管执行多少次必然得到同样的输出，所有的都是确定的、可控的。 流程控制的组成\n流程控制一般分为顺序执行、条件判断和循环控制。 伪代码\n伪代码(Pseudocode)是一种算法描述语言。使用伪代码的目的是使被描述的算法可以容易地以任何一种编程语言实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。 通俗简单地讲，就是用中文把你的程序先写出来，在检查过伪代码没有问题后，再用Python等语言将其真正实现。 上图中就是一组典型的流程控制操作，很明确的阐述了编程中的因果关系，同一个输入不管执行多少次必然会得到同样的输出结果。\n顺序执行 顾名思义，就是根据编写程序的上下顺序依次执行或者说是自上而下逐行顺序执行。 条件判断 顺序结构的程序虽然能解决计算、输出等问题，但不能做判断再选择。对于要先做判断再选择的问题就要使用分支结构。\n单分支语句\n语法：\nif 表达式: 代码块 说明：\n1、“表达式”可以是一个单一的值或者复杂语句，形式不限，但解释器最后会通过bool获取一个true或者false的布尔值\n2、“代码块”由：与具由相同缩进标识的若干条语句组成（一般是四个缩进）。\nage = input(\u0026#39;enter your age:\u0026#39;) age = int(age) #将字符串形式的age转换成了数字类型 if age \u0026gt; 18: print(\u0026#39;成年\u0026#39;) print(\u0026#39;over!\u0026#39;) 双分支语句\n双分支语句顾名思义，二条分支二选一执行！语法格式：\nif 表达式： 代码块 1 else： 代码块 2 age = input(\u0026#39;enter a age:\u0026#39;)#age是一个字符串类型 #将字符串类型的age转换成整形 age = int(age) if age \u0026gt;= 18: #if后面的表达式返回True说明该条件成立，否则说明该条件不成立 print(\u0026#39;成年\u0026#39;) else: print(\u0026#39;未成年\u0026#39;) 多分支语句\n多分支即从比双分支更多的分支选择一支执行。语法格式：\nif 表达式 1： 代码块 1 elif 表达式 2： 代码块 2 elif 表达式 3： 代码块 3 ...# 其它elif语句 else： 代码块 n age = input(\u0026#39;enter a age:\u0026#39;)#age是一个字符串类型 #将字符串类型的age转换成整形 age = int(age) if age \u0026gt;= 18: #if后面的表达式返回True说明该条件成立，否则说明该条件不成立 print(\u0026#39;成年\u0026#39;) elif age \u0026gt;= 12: print(\u0026#39;未成年\u0026#39;) elif age \u0026gt;= 8: print(\u0026#39;儿童\u0026#39;) else: print(\u0026#39;婴儿\u0026#39;) 案例:猜数字游戏\n#第一种写法 true_num = 9 #标准答案 num = input(\u0026#39;please guess a num:\u0026#39;) num = int(num) #用户猜数字只有三种可能：猜对了，猜小了和猜大了 if num == true_num:#猜对了 print(\u0026#39;恭喜您，猜对了！\u0026#39;) else:#包含了用户猜大了和猜小了两种可能 # print(\u0026#39;猜错了\u0026#39;) if num \u0026lt; true_num: print(\u0026#39;猜小了\u0026#39;) else:#只剩下一种可能：猜大了 print(\u0026#39;猜大了\u0026#39;) print(\u0026#39;一轮游戏结束！\u0026#39;) #第二种写法： true_num = 9 #标准答案 num = input(\u0026#39;please guess a num:\u0026#39;) num = int(num) #用户猜数字只有三种可能：猜对了，猜小了和猜大了 if num == true_num:#猜对了 print(\u0026#39;恭喜您，猜对了！\u0026#39;) elif num \u0026lt; true_num: print(\u0026#39;猜小了\u0026#39;) else: print(\u0026#39;猜大了\u0026#39;) print(\u0026#39;一轮游戏结束！\u0026#39;) 循环控制语句 在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。\nPython语言中的循环语句支持 while循环（条件循环）和for循环（遍历循环）。\nwhile循环 语法：\nwhile 表达式: 循环体 案例：循环打印十遍\u0026quot;hello world\u0026quot;\ni = 0 while i \u0026lt; 10: print(\u0026#39;hello world!\u0026#39;) #步进语句 i += 1 #i = i + 1 让猜数字游戏多次执行\ntrue_num = 9 #标准答案 i = 0 while i \u0026lt; 5: num = input(\u0026#39;please guess a num:\u0026#39;) num = int(num) #用户猜数字只有三种可能：猜对了，猜小了和猜大了 if num == true_num:#猜对了 print(\u0026#39;恭喜您，猜对了！\u0026#39;) elif num \u0026lt; true_num: print(\u0026#39;猜小了\u0026#39;) else: print(\u0026#39;猜大了\u0026#39;) i += 1 #步进语句 print(\u0026#39;一轮游戏结束！\u0026#39;) 案例：求解1-3累加和\n#案例：求解1-3累加和 sum = 0 #保存累加后的结果 i = 1 while i \u0026lt;= 3: sum = sum + i i += 1 print(sum) #第一次循环结束：sum = 1 i = 2 #第二次循环结束：sum = 3 i = 3 #第三次循环结束：sum = 6 i = 4 想要计算n！(5! = 5 * 4 * 3 * 2 * 1)\ns = 1 #前n个数的积 i = 1 while i \u0026lt;= 5: s = s * i i += 1 print(s) x = input(\u0026#39;您想要计算几的阶乘呢，请录入：\u0026#39;) x = int(x) s = 1 #前n个数的积 i = 1 while i \u0026lt;= x: s = s * i i += 1 print(s) 找出1-100之间所有的偶数,将其存储到一个列表中\n#找出1-100之间所有的偶数,将其存储到一个列表中 alist = [] #存放所有符合条件的偶数 i = 1 while i \u0026lt;= 100: #判断偶数 if i % 2 == 0:#i可以被2整除 alist.append(i) #将偶数添加到指定的列表中 i += 1 print(alist) for循环 语法格式\nfor 迭代变量 in 字符串|列表|元组|字典|集合： 代码块 格式中，迭代变量用于存放从序列类型变量中读取出来的元素，所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。\nalist = [1,2,3,4,5] #item变量不需要提前声明/定义 #循环次数取决于in后面那个数据结构中元素的个数 for item in alist: #遍历列表元素 print(item) #循环体 alist = [1,2,3,4,5] #item变量不需要提前声明/定义 #循环次数取决于in后面那个数据结构中元素的个数 for item in alist: #遍历列表元素 print(\u0026#39;hello world\u0026#39;) #循环体 计算1-5之和\nalist = [1,2,3,4,5] sum = 0 for item in alist: sum += item print(sum) 遍历字典\ndic = { \u0026#39;name\u0026#39;:\u0026#39;bobo\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;address\u0026#39;:\u0026#39;Bj\u0026#39; } #keys返回的是一个列表，列表中存储的是字典中所有的key for key in dic.keys(): print(dic[key]) for key,value in dic.items(): print(key,value) 遍历字符串\ns = \u0026#39;hello bobo\u0026#39; for item in s: print(item) 总结：\n如果遍历一个数据结构，则最好使用for循环 如果一个需求循环次数不确定最好使用while 如果一个需求循环次数确定最好使用for 死循环 永远都不会结束的循环。\n但有我们是会需要无限循环。例如Web服务器响应客户端的实时请求。\nwhile True: pass #循环体 while 1: pass #循环体 循环嵌套 if判断可以嵌套，while和for当然也可以嵌套。但是建议大家不要嵌套3层以上，那样的效率会很低。\n#查看下述的print会被循环执行多少次 i = 0 while i \u0026lt; 3: j = 0 while j \u0026lt; 2: print(\u0026#39;hello world!\u0026#39;) #会被打印6次 j += 1 i += 1 alist = [1,2,3,4,5] for i in alist: for j in alist: print(\u0026#39;hello\u0026#39;) #重复执行25次 退出循环 如果想提前结束循环（在不满足结束条件的情况下结束循环），可以使用break或continue关键字。\nbreak\n通常情况下的循环要么执行出错，要么死循环，要么就只能老老实实等它把所有的元素循环一遍才能退出。如果想在循环过程中退出循环，怎么办？用break语句！ break只能用于循环体内。其效果是直接结束并退出当前循环，剩下的未循环的工作全部被忽略和取消。注意当前两个字，Python的break只能退出一层循环，对于多层嵌套循环，不能全部退出。 alist = [1,2,3,4,5] for i in alist: print(\u0026#39;hello world\u0026#39;) if i == 3: break #终止整个循环 continue\n与break不同，continue语句用于跳过当前循环的剩余部分代码，直接开始下一轮循环。它不会退出和终止循环，只是提前结束当前轮次的循环。同样的，continue语句只能用在循环内。\nalist = [1,2,3,4,5] for i in alist: if i == 3: continue #结束当次循环，开始下一次新的循环 print(i) 注意：break和continue只可以作用在离其最近的那一层循环中。\nalist = [1,2,3] for i in alist: for j in alist: print(\u0026#39;inner\u0026#39;) if j == 1: break print(\u0026#39;outer\u0026#39;) else从句 while的else从句 while循环还可以增加一个else从句。当while循环正常执行完毕，会执行else语句。但如果是被break等机制强制提前终止的循环，不会执行else语句。注意else与while平级的缩进方式！\ni = 0 while i \u0026lt; 5: print(i) if i == 3: break i += 1 else: #只有当循环被正常结束，才会执行else从句 print(\u0026#39;while循环正常结束！\u0026#39;) for的else从句 与while一样，for循环也可以有else子句。同样是正常结束循环时，else子句执行。被中途break时，则不执行。\nalist = [1,2,3,4,5] for i in alist: print(i) if i == 2: break else: print(\u0026#39;for循环正常结束！\u0026#39;) 1.实现完整的猜数字游戏：\n规则如下：\n​\t可以不间断的进行猜数字游戏环节，找到猜对了，结束程序，猜不对，可以不断的进行游戏，并且需要提示用户猜大了还是猜小了。\n拓展功能实现：\n​\t1.最后需要统计出，用户猜了多少次才猜对。\n​\t2.每一个用户的初始分数为100，每猜错一次扣5分，最后程序结束，统计用户的得分。\nimport random score = 100 #初始分值 count = 0 #用来统计循环了多少次 #随机产生一个1-100之间的数字 num = int(random.random() * 100) while True: count += 1 guessNum = int(input(\u0026#39;enter a num:\u0026#39;)) if guessNum == num: print(\u0026#39;猜对了\u0026#39;) break elif guessNum \u0026lt; num: if score \u0026gt; 0: score -= 5 else: break print(\u0026#39;猜小了\u0026#39;) else: if score \u0026gt; 0: score -= 5 else: break print(\u0026#39;猜大了\u0026#39;) print(\u0026#39;一共猜了%d次,总得分为：%d\u0026#39;%(count,score)) 排序算法 冒泡排序\n1.将序列中的元素两两比较，然后实现将序列中的最大值逐一偏移到序列的末尾位置。\nalist = [3,8,5,7,6] for i in range(len(alist)-1): if alist[i] \u0026gt; alist[i+1]: #将两个元素交换位置 alist[i],alist[i+1] = alist[i+1],alist[i] print(alist) 2.将上述步骤1的核心操作重复执行n次就可以实现有序效果\nalist = [3,8,5,7,6] for j in range(len(alist)-1): for i in range(len(alist)-1-j): if alist[i] \u0026gt; alist[i+1]: #将两个元素交换位置 alist[i],alist[i+1] = alist[i+1],alist[i] print(alist) 选择排序\n1.将序列中的元素两两比较，找出最大值，将最大值和序列中最后一个元素交换位置。\nalist = [3,8,5,7,6] #一开始假设最大值的小标为0 max_index = 0 #保存最大元素的小标 for i in range(len(alist)-1):#i的取值为0，1，2，3 if alist[max_index] \u0026lt; alist[i+1]: max_index = i+1 alist[max_index],alist[len(alist)-1] = alist[len(alist)-1],alist[max_index] print(alist) 将上述步骤1的核心操作重复执行n次就可以实现有序效果\nalist = [3,8,5,7,6] for j in range(len(alist)-1): #一开始假设最大值的小标为0 max_index = 0 #保存最大元素的小标 for i in range(len(alist)-1-j):#i的取值为0，1，2，3 if alist[max_index] \u0026lt; alist[i+1]: max_index = i+1 alist[max_index],alist[len(alist)-1-j] = alist[len(alist)-1-j],alist[max_index] print(alist) 插入排序\n假设将列表分为两部分： 有序部分：默认情况下，列表的第一个元素为有序部分 无序部分：默认情况下，列表的非第一个元素为无序部分 [3, 8,5,7,6] #初始列表 [3,8, 5,7,6] #第一次插入 [3,5,8, 7,6] #第二次插入 [3,5,7,8, 6] #第三次插入 [3,5,6,7,8 ] #第四次插入 定义一个变量i，i的初始值为1.变量i表示的是有序部分的元素个数。\ni = 1的情况：\ni = 1 alist = [3,8,5,7,6] #alist[i]无序部分的第一个元素 #alist[i-1]有序部分最后一个元素 if alist[i] \u0026lt; alist[i-1]: alist[i],alist[i-1] = alist[i-1],alist[i] i = 2 或者说i\u0026gt;1的情况\n#alist[i]无序部分的第一个元素 #alist[i-1]有序部分最后一个元素 while i \u0026gt; 0: if alist[i] \u0026lt; alist[i-1]: alist[i],alist[i-1] = alist[i-1],alist[i] i -= 1 else: break 完整代码：\nalist = [3,8,5,7,6,2,1,0] for i in range(1,len(alist)): while i \u0026gt; 0: if alist[i] \u0026lt; alist[i-1]: alist[i],alist[i-1] = alist[i-1],alist[i] i -= 1 else: break print(alist) 二分查找\n只可以作用在有序序列中\nisFind = False #假设现在查找2是否存在于当前列表中 toFind = input(\u0026#39;enter a num of you want to find:\u0026#39;) toFind = int(toFind) alist = [1,2,3,4,5,6] low = 0 #第一个元素下标 high = len(alist)-1 #最后一个元素下标 while low \u0026lt;= high: #mid保存中间元素下标 mid = (low + high) // 2 #如果条件成立，则可以去中间元素右侧查找 if toFind \u0026gt; alist[mid]: low = mid + 1 elif toFind \u0026lt; alist[mid]:#查找的元素可能存在中间元素左侧 high = mid - 1 else: #中间元素等于查找的元素 isFind = True break print(isFind) 衡量算法性能好坏优劣的指标：\n时间复杂度\n量化算法执行步骤的数量。 例子：\nn = 5 #1 while n \u0026gt; 0: #2n print(\u0026#39;haha\u0026#39;) a -= 1 print(\u0026#39;over!\u0026#39;)#1 #上述算法量化出执行步骤的数量：2+2n 时间复杂度最终是通过大O记法来表示：\n将量化出的表达式取出最有意义的一项，放入在大O后面的括号中即可。 2+2*n：最优意义的一项是n，该算法就可以表示为：O(n) ","permalink":"https://canw0916.github.io/en/posts/tech/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"流程控制 流程控制指的是代码运行逻辑、分支走向、循环控制，是真正体现程序执行顺序的操作。 程序是由语句构成，而流程控制语句 是用来控制程序中每条语","title":"流程控制"},{"content":"重要数据类型 列表数据类型 在实际开发中，经常需要将一组（不只一个）数据存储起来，以便后边的代码使用。列表就是这样的一个数据结构。且列表是Python中最基本也是最常用的数据结构之一。\n什么是数据结构呢？\n通俗来讲，可以将数据结构当做是某种容器，该容器是用来装载或者存储数据的。不同的数据结构决定了对数据不同的组织方式。 那么当数据被装载或者存储到了某个数据结构中后，那么就可以基于该数据结构的特性对数据进行不同形式的处理和运算。 列表的创建方式\n创建一个列表，只要把逗号分隔的不同的数据元素使用方括号括起来即可。列表内的元素，可以是其它任意类型的数据，可多层嵌套列表，元素个数无限制。 a = [1,2,3,\u0026#39;four\u0026#39;,5.5,False] 列表元素：\n存储在列表数据结构中的每一个数据被称为列表元素，简称元素。 列表索引：\n列表中的每个元素都被分配一个数字作为索引，用来表示该元素在列表内所排在的位置。第一个元素的索引是0，第二个索引是1，依此类推。 列表的内存结构\n从数据结构角度看，Python的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针/引用。 比如，对于这个列表 alist = [1, “a”, [11,22], {“k1”:”v1”}]，其在内存内的存储方式是这样的： 列表特性：\nPython的列表是一个有序可重复的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。 访问列表内的元素\n列表从0开始为它的每一个元素顺序创建下标索引，直到总长度减一。要访问它的某个元素，以方括号加下标值的方式即可。注意要确保索引不越界，一旦访问的 索引超过范围，会抛出异常。所以，一定要记得最后一个元素的索引是len(list)-1。\nalist = [1,2,3] print(alist[0]) print(alist[len(alist)-1]) 修改元素的值\n直接对元素进行重新赋值\nalist = [1,2,3,4,5,6,7,8,9] alist[3] = \u0026#39;four\u0026#39; print(alist) 删除元素\n使用del语句或者remove(),pop()方法删除指定的元素。\nalist = [1,2,3,4,5] #方式1 del alist[0] print(alist) alist = [1,2,3,4,5] #方式2：pop(下标)可以将列表中指定元素取出 item = alist.pop(1) print(\u0026#39;pop取出的元素为：\u0026#39;,item) print(alist) alist = [1,2,3,4,5] #方式3：remove(删除的元素) alist.remove(5) #将5这个元素从alist中删除 print(alist) 添加元素\n使用append和insert添加元素 alist = [1,2,3,4,5] alist.append(666) #可以将一个元素添加到列表的末尾 alist.append([7,8,9]) print(alist) alist = [1,2,3,4,5] alist.insert(2,666) #将元素添加到列表指定的位置 print(alist) 列表的特殊操作\n上述讲解的操作都是列表的常规操作，当然除了这些常规的操作列表还有很多有用的其它特殊形式的操作。 针对列表的常用函数\nPython有很多内置函数，可以操作列表。 排序：\na = [3,8,5,7,6] a.sort() #在原先列表中进行排序 a = [3,8,5,7,6] sorted(a)#返回新的列表 列表和字符串的相互转换\ns = \u0026#39;hello-bobo-123\u0026#39; result = s.split(\u0026#39;-\u0026#39;) #将字符串转换为列表 #将列表转换为字符串 s1 = \u0026#39;~\u0026#39;.join(result) s1 切片\n切片指的是对序列进行截取，选取序列中的某一段。\n切片的语法是： list[start:end]\nalist = [1,2,3,4,5] print(alist[0:3]) 以冒号分割索引，start代表起点索引，end代表结束点索引。省略start表示以0开始，省略end表示到列表的结尾。注意，区间是左闭右开的！也就是说[1:4]会截取列表的索引为1/2/3的3个元素，不会截取索引为4的元素。分片不会修改原有的列表，可以将结果保存到新的变量，因此切片也是一种安全操作，常被用来复制一个列表，例如newlist = lis[:]。\n如果提供的是负整数下标，则从列表的最后开始往头部查找。例如-1表示最后一个元素，-3表示倒数第三个元素。\nalist = [1,2,3,4,5] print(alist[0:-1]) 切片过程中还可以设置步长，以第二个冒号分割，例如list[3:9:2]，表示每隔多少距离取一个元素。\nalist = [1,2,3,4,5,6,7,8,9,10] print(alist[0:9:2]) 列表的内置方法\n上文中我们说过，数据存储到不同的数据结构中，可以基于该数据结构的特性对数据进行指定形式的操作和处理。下图中的方法是列表专有的内置方法，请熟记于心。 深浅拷贝是python中经常涉及到一个面试，也是同学们经常出错的地方，那么什么是深浅拷贝呢？\n浅拷贝\ncopy方法: 意思是复制一个相同的列表(赋值出的别表是一块全新的内存空间)\nnames = [\u0026#39;小明\u0026#39;,\u0026#39;小红\u0026#39;,\u0026#39;小黑\u0026#39;,\u0026#39;小黄\u0026#39;,\u0026#39;小白\u0026#39;] names2 = names.copy() print(names,names2) print(id(names),id(names2)) 把 names 列表中的 小黄改成英文 Yellow，那么 names2 的小黄会发生变化吗？\nnames = [\u0026#39;小明\u0026#39;,\u0026#39;小红\u0026#39;,\u0026#39;小黑\u0026#39;,\u0026#39;小黄\u0026#39;,\u0026#39;小白\u0026#39;] names2 = names.copy() print(names,names2) print(id(names),id(names2)) names[1] = \u0026#39;red\u0026#39; print(names2) 其实它的原理很简单，如下图:\n首先，names 指向一个列表，然后把 names 复制了一份，赋值给 names2 ，由于 修改的是 第一个 列表的 小黄，所以第二个列表不受影响。\n那么现在我改一下这个列表，从names列表中再添加一个列表，如下代码\nnames = [\u0026#39;小明\u0026#39;,\u0026#39;小红\u0026#39;,[\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;,\u0026#39;王五\u0026#39;],\u0026#39;小黑\u0026#39;,\u0026#39;小黄\u0026#39;,\u0026#39;小白\u0026#39;] names2 = names.copy() names2[2][1] = \u0026#39;lisi\u0026#39; print(names) print(names2) 这段代码的运行结果是，两个列表的李四都变成了英文，来分析一下原理\n其实这个图也挺简单的，就是中间那个列表是单独分配了一块空间，然后从第一层列表中去引用地址，复制的names2 也是引用的地址，所以真实的值一变，两个列表的内部列表的值也就变了。\n也就是说 list.copy() 方法只能 copy 一层，这就是所谓的浅复制。\n深拷贝\nimport copy #将copy这个工具箱搬过来 names = [\u0026#39;小明\u0026#39;,\u0026#39;小红\u0026#39;,[\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;,\u0026#39;王五\u0026#39;],\u0026#39;小黑\u0026#39;,\u0026#39;小黄\u0026#39;,\u0026#39;小白\u0026#39;] names2 = copy.deepcopy(names) #将names复制一份给names2 names2[2][1] = \u0026#39;lisi\u0026#39; print(names) 列表的维度：浅拷贝只可以完全拷贝一维列表，如果是多维列表务必使用深拷贝！\na1 = [1,2,3] #一维列表 a2 = [[1,2,3],[4,5,6]] #二维列表 a3 = [[[1,2],[3,4]],[[5,6],[7,8]]] #三维列表 元组数据类型 用方括号括起来的是列表，那么用圆括号括起来的就是元组。\nt = (1,2,3,4,5) t1 = (1,) #只有一个元素的元组 t2 = (1,2,3,(4,5)) 元组也是序列结构，但是是一种不可变序列，你可以简单的理解为内容不可变的列表。除了在内部元素不可修改的区别外，元组和列表的用法差不多。\n元组与列表相同的操作：\n使用方括号加下标访问元素\n切片（形成新元组对象）\nt = (1,2,3,4,5) n_t = t[0:3] print(n_t) count()/index()\nt = (1,2,3,4,5,3) print(t.count(3)) #返回指定元素的个数 print(t.index(5)) #返回指定元素的下标 len()/max()/min()\nt = (1,2,3,4,5,3) max = t.max() min = t.min() len = len(t) 元组中不允许的操作，确切的说是元组没有的功能：\n修改、新增元素 删除某个元素（但可以删除整个元组） 所有会对元组内部元素发生修改动作的方法。例如，元组没有remove，append，pop等方法。 元组与列表类似的特殊操作：\n提问：\n在学完列表后，在使用元素我们会发现元组由于是一个不可变序列，则很多操作会受到限制，这不能，那不能，要你何用，我直接用列表不行吗？\n还是有用的，有些数据一旦创建之后就不允许修改了，这些数据就适合用元组来创建，比如主机地址和端口（ip，port），（\u0026ldquo;192.168.1.1\u0026rdquo;， 80），两者捆绑在一起，不允许修改。\nip_port = (\u0026#34;192.168.1.1\u0026#34;, 8080) 元组看来是很安全的。但真的吗？\na = (1,2,[3,4]) a[2][0] = \u0026#39;Three\u0026#39; a 实则不然，注意：元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！\n所以，在使用元组的时候，请尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。 字典数据类型 字典的实现机制：\nPython的字典数据类型是基于hash散列算法实现的，采用键值对(key:value)的形式，根据key的值计算value的地址，具有非常快的查取和插入速度。\n字典特性：\n字典包含的元素个数不限，值的类型可以是任何数据类型！但是字典的key必须是不可变的对象，例如整数、字符串、bytes和元组，最常见的还是将字符串作为key。列表、字典、集合等就不可以作为key。同时，同一个字典内的key必须是唯一的，但值则不必。 注意：从Python3.6开始，字典是有序的！它将保持元素插入时的先后顺序！请务必清楚！ 创建字典\n字典的每个键值对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ，例如：\nd = {key1 : value1, key2 : value2 } dic = { \u0026#39;name\u0026#39;:\u0026#39;bobo\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:[99.88] } print(dic) 访问字典\n虽然现在的字典在访问时有序了，但字典依然是集合类型，不是序列类型，因此没有索引下标的概念，更没有切片的说法。但与list类似的地方是，字典采用把相应的键放入方括号内获取对应值的方式取值。\ndic = { \u0026#39;name\u0026#39;:\u0026#39;bobo\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:[100,99,80], \u0026#39;address\u0026#39;:{\u0026#39;zhangsan\u0026#39;:\u0026#39;beijing\u0026#39;,\u0026#39;lisi\u0026#39;:\u0026#39;shanghai\u0026#39;}, } print(dic[\u0026#39;address\u0026#39;]) #通过中括号的机制取value值 print(dic.get(\u0026#39;age\u0026#39;)) #通过调用get取value值 通过中括号访问value值和通过get访问value值得区别是什么？\nget可以访问不存在的key，中括号不可以 添加和修改\n增加就是往字典插入新的键值对，修改就是给原有的键赋予新的值。由于一个key只能对应一个值，所以，多次对一个key赋值，后面的值会把前面的值冲掉。 dic = { \u0026#39;name\u0026#39;:\u0026#39;bobo\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:[100,99,80], \u0026#39;address\u0026#39;:{\u0026#39;zhangsan\u0026#39;:\u0026#39;beijing\u0026#39;,\u0026#39;lisi\u0026#39;:\u0026#39;shanghai\u0026#39;}, } dic[\u0026#39;salary\u0026#39;] = 10000 #直接给一个不存在的key赋值，就表示向字典中增加了一个键值对 print(dic) dic = { \u0026#39;name\u0026#39;:\u0026#39;bobo\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:[100,99,80], \u0026#39;address\u0026#39;:{\u0026#39;zhangsan\u0026#39;:\u0026#39;beijing\u0026#39;,\u0026#39;lisi\u0026#39;:\u0026#39;shanghai\u0026#39;}, } dic[\u0026#39;age\u0026#39;] = 100 #直接给一个存在的key赋值，就表示修改了字典中的一个键值对 print(dic) 删除字典元素、清空字典和删除字典\n使用del关键字删除字典元素或者字典本身，使用字典的clear()方法清空字典。\ndic = { \u0026#39;name\u0026#39;:\u0026#39;bobo\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:[100,99,80], \u0026#39;address\u0026#39;:{\u0026#39;zhangsan\u0026#39;:\u0026#39;beijing\u0026#39;,\u0026#39;lisi\u0026#39;:\u0026#39;shanghai\u0026#39;}, } del dic[\u0026#39;age\u0026#39;] #删除了age表示的键值对 print(dic) dic = { \u0026#39;name\u0026#39;:\u0026#39;bobo\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:[100,99,80], \u0026#39;address\u0026#39;:{\u0026#39;zhangsan\u0026#39;:\u0026#39;beijing\u0026#39;,\u0026#39;lisi\u0026#39;:\u0026#39;shanghai\u0026#39;}, } dic.clear() #清空字典中所有的键值对 print(dic) 字典的重要方法\n下表中列出了字典的重要内置方法。其中的get、items、keys和values是核心中的核心，必须熟练掌握！ 遍历字典\n从Python3.6开始遍历字典获得的键值对是有序的！以下的遍历方法必须全部熟练掌握 bytes字节类型/二进制类型 在Python3以后，字符串和bytes类型彻底分开了。字符串是以字符为单位进行处理的，bytes类型是以字节为单位处理的。 bytes数据类型在所有的操作和使用甚至内置方法上和字符串数据类型基本一样，也是不可变的序列对象。 作用 bytes对象只负责以二进制字节序列的形式记录所需记录的对象。Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等 创建方式 bs = b\u0026#39;hello world\u0026#39; print(type(bs)) 字符串和bytes类型的数据相互转换\nbs = b\u0026#39;hello world\u0026#39; #将bytes类型的数据转换成字符串类型的数据 ss = bs.decode() print(type(ss)) #将字符串类型的数据转换成bytes类型 bss = ss.encode() print(type(bss)) set集合 特性\nset集合是一个无序不重复元素的容器，集合数据类型的核心在于自动去重。 创建方式\n集合使用大括号{}框定元素，并以逗号进行分隔。但是注意：如果要创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典。集合除了在形式上最外层用的也是花括号外，其它的和字典没有一毛钱关系。 s = {1,2,3,3,3,4,4,5,5,6,7,7,7} print(s) print(s[0]) #会报错，因为set集合没有下标的机制 应用\n对于字符串，集合会把它一个一个拆开，然后去重 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果 可以通过update()方法，将另一个对象更新到已有的集合中，这一过程同样会进行去重。 通过remove(key)方法删除指定元素，或者使用pop()方法。注意，集合的pop方法无法设置参数，删除指定的元素 alist = [1,2,3,4,4,4,4,5,6,7] s = {9,0} s.update(alist) print(s) 注意：\n集合既不支持下标索引也不支持字典那样的通过键获取值。 ","permalink":"https://canw0916.github.io/en/posts/tech/%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"重要数据类型 列表数据类型 在实际开发中，经常需要将一组（不只一个）数据存储起来，以便后边的代码使用。列表就是这样的一个数据结构。且列表是Pyt","title":"重要数据类型"},{"content":"基本数据类型 引言 提问\n前面我们说过，计算机的本质作用就是用来存储和运算二进制的数据。但是在实际应用中，我们看到计算机存储或者运算的数据并非只有二进制的数据，例如使用Excel可以对一些数值数据、文本数据或者图像数据进行不同形式的处理。也就是说计算机可以处理运算的数据有很多不同的种类或者类型。那这不就违背计算机的本质作用了吗？ 在后面讲解了计算机编码后，我们自然就会理解了，后面在聊。 至少，现在我们应该可以感受到，计算机在实际应用中看起来是可以存储和处理不同类型的数据，要是想要使用Python指挥计算机处理不同的数据，则Python需要定义或者规范下不同数据的类型，那么Python中给我们规范了哪些类型的数据呢？ Python数据类型\n在Python的世界，数据类型分两种，内置的和自定义的 内置数据类型\n内置的包括数字、字符串、布尔、列表、元组、字典、Bytes、集合这些常用的。 自定义数据类型\n自定义的，一般以类的形式，根据需要组合以上内置类型成为独特的数据类型。 疑问：大家有没有想过为什么编程语言要设置不同的数据类型吗？\n原因1： 更好的分配管理内存,节省不必要的开支，提高读取速度和运行效率。 原因2： 方便统一管理。这样，我们可以为同一数据类型，提供同样的操作，限制其它不允许的行为。也易于查找错误，定位问题。 原因3： 区分数据类型，更贴切人类对自然事物的分类管理习惯。我们人类对事物都进行了各种分类，植物是植物、动物是动物，书是书，笔是笔。分类了之后，我们很自然的知道书可以读，笔可以写。数据类型也一样，让我们对抽象的数据有了可分辨的行为和自然的记忆。 数字类型 数字类型用于存储和表示数学意义上的数值。\nPython 支持三种不同的数字类型，整数、浮点数和复数\n不可变类型\n数字类型是不可变类型。所谓的不可变类型，指的是类型的值一旦有不同了，那么它就是一个全新的对象。数字1和2分别代表两个不同的对象，对变量重新赋值一个数字类型，会新建一个数字对象。\n例如：\na = 1 #创建数字对象1 a = 2 #创建数字对象2，并将2赋值给变量a，a不再指向数字对象1 这里，发生了变化的是变量a的指向，而不是数字对象1变成了数字对象2。初学者可能会比较迷糊，但不要紧，可以先试着接受。 实验：使用id工具显示1,2,3的内存空间地址\na = 1 print(id(a)) a = 2 print(id(a)) 整数Int\n通常被称为整型，是正或负整数，不带小数点。例如：1，100，-8080，0，等等。 不同进制的整数 表示数字的时候，有时我们还会用八进制或十六进制来表示： 十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2。 八进制用0o前缀和0-7表示，例如0o12 浮点数\n浮点数也就是小数，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，一般用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\nsalary = 1.2e5 数字类型转换\n有时候，我们需要对数字的类型进行转换。Python为我们提供了方便的内置的数据类型转换函数。\nint(x)：\n将x转换为一个整数。如果x是个浮点数，则截取小数部分。\na = 10.5 b = int(a) print(b) float(x) ：\n将x转换到一个浮点数。\na = 10 b = float(a) print(b) 数学计算\n对于数学计算，除了前面提到过的简单的加减乘除等等，更多的科学计算需要导入math这个库，它包含了绝大多数我们可能需要的科学计算函数，如下表\n以及两个数学常量：\n布尔类型 真于假、0和1，都是传统意义上的布尔类型。\n但在Python语言中，布尔类型只有两个值，True与False。请注意，是英文单词的对与错，并且首字母要大写，不能其它花式变型。\n所有计算结果返回的结果是True或者False的过程都可以称为布尔运算，例如比较运算。\na = 1 \u0026lt; 2 print(a) False等同于0，True等同于1\na = True + True + False + True print(a) 字符串类型 字符串是由零个或多个字符组成的有限序列。字符串的内容可以包含字母、标点、特殊符号、中文、日文等全世界的所有字符。\n在python中字符串是通过单引号''或者双引号\u0026quot;\u0026quot;标识的。\nname = \u0026#34;bobo\u0026#34; addr = \u0026#39;BeiJing\u0026#39; 字符串特性\n字符串是不可变的序列数据类型，不能直接修改字符串本身，和数字类型一样！Python3全面支持Unicode编码，所有的字符串都是Unicode字符串，所以传统Python2存在的编码问题不再困扰我们，可以放心大胆的使用中文。\n字符串属于序列类型，所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。\ns = \u0026#34;hello yuan\u0026#34; 序列类型支持的操作：\n#1.索引取值 s = \u0026#39;hello yuan\u0026#39; print(s[3]) #2.切片取值：批量取出多个字符数据。s[start:end],只能取到start到end的前一位区间的字符数据 s = \u0026#39;hello yuan\u0026#39; print(s[0:5]) print(s[0:-1]) print(s[:-1]) print(s[0:]) #3.in运算符检查某一个元素是否存在于一个序列 s = \u0026#39;hello yuan\u0026#39; print(\u0026#39;h\u0026#39; in s) #4.支持加法运算:将两个字符串拼接到了一起 s1 = \u0026#39;hello \u0026#39; s2 = \u0026#39;bobo\u0026#39; s3 = s1 + s2 #字符串的拼接 print(s3) #5.*运算:将字符串叠放多次 s1 = \u0026#39;hello \u0026#39; s2 = s1 * 5 #字符串重叠拼接 print(s2) 字符串运算\n下表实例变量a值为字符串 \u0026ldquo;Hello\u0026rdquo;，b变量值为 \u0026ldquo;Python\u0026rdquo;： python转义字符\n多行字符串\n在字符串中，可以使用三引号（三单或三双引号都可以）编写跨行字符串，在其中可以包含换行符、制表符以及其他特殊字符。\ns = \u0026#39;\u0026#39;\u0026#39; djsfjds fhdjskhfjkds fdhjskdfh \u0026#39;\u0026#39;\u0026#39; print(s) 字符串内置方法\n内置方法有很多，但是我们主要记住如下几个即可： s1 = \u0026#39;hello bobo\u0026#39; s2 = \u0026#39;bobo\u0026#39; s1.find(s2) #返回子串在当前字符串中的位置 #使用Jay替换bobo s1_new = s1.replace(\u0026#39;bobo\u0026#39;,\u0026#39;Jay\u0026#39;) s = \u0026#39;hello-bobo-and-tom\u0026#39; result = s.split(\u0026#39;-\u0026#39;) result s = \u0026#39; hello bobo \\t\\t\\n \u0026#39; print(s.strip()) s = \u0026#39;www.123@qq.com\u0026#39; s.startswith(\u0026#39;www\u0026#39;),s.endswith(\u0026#39;com\u0026#39;) 字符编码\n计算机只能处理数字01，如果要处理文本，就必须先把文本转换为数字01二进制的形式，这种转换方式就称为字符编码。\n对于我们而言，你只需要简单记住下面几种编码就好：\nASCII编码：早期专门为英语语系编码，只有255个字符，每个字符需要8位也就是1个字节。不兼容汉字。 Unicode编码：又称万国码，国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。用2个字节来表示汉字。 UTF-8编码：为了节省字节数，在Unicode的基础上进行优化的编码。天生兼容ASCII编码，所以最为流行。 GB2312：我国早期自己制定的中文编码，世界范围内不通用。 GBK： 全称《汉字内码扩展规范》，向下与GB2312兼容，向上支持ISO10646.1国际标准，是前者向后者过渡过程中的一个承上启下的产物。windows中文版的汉字编码用的就是GBK。也非世界范围通用的编码 其它编码：非以上类型者的统称。属于能不用就不要碰的编码。 ","permalink":"https://canw0916.github.io/en/posts/tech/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"基本数据类型 引言 提问 前面我们说过，计算机的本质作用就是用来存储和运算二进制的数据。但是在实际应用中，我们看到计算机存储或者运算的数据并非只有","title":"基本数据类型"},{"content":"运算符 运算符：以1 + 2为例，1和2被称为操作数，“+” 称为运算符。 Python语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 算术运算符 a = 10 % 3 b = 2 ** 3 c = 10 // 3 print(c) 比较运算符 对于连续比较，Python是按这种机制解释的： 3\u0026gt;2\u0026gt;1 等于 (3\u0026gt;2) and (2\u0026gt;1) 赋值运算符 位运算符（忽略） 逻辑运算符 成员运算符 身份运算符（后面理解） 运算符优先级 下表列出了从最高到最低优先级的所有运算符。优先级高的运算符优先计算或处理，同级别的按从左往右的顺序计算（赋值运算符除外，它是按从右往左的顺序 输入输出 print输出 print用于将内容格式化显示在标准输出上，主要指的是屏幕显示器\na = 10 print(a) print可以接受多个字符串，字符串类型的变量。每个字符串用逗号“,”隔开，连成一串输出。print会依次打印每个字符串，同时，每遇到一个逗号“,”就输出一个空格。\na = 10 b = 20 name = \u0026#39;bobo\u0026#39; salary = 1000 print(a,b,name,salary) sep和end设置:\nsep表示分隔的符号，默认是一个空格 end表示打印后的结束方式，默认为换行符\\n a = \u0026#39;bobo\u0026#39; b = 20 c = 1.123 print(a,b,c,sep=\u0026#39;+++\u0026#39;) %百分号格式化输出方式\nname = \u0026#39;jay\u0026#39; print(\u0026#39;该名同学的姓名是：%s\u0026#39;%name) age = 20 print(\u0026#39;该名同学的年龄是：%d\u0026#39;%age) 格式化符号:\ninput输入 input可以获取用户输入，保存成一个字符串。一定要注意，input的返回值是一个字符串类型。哪怕你输入的是个数字1，返回给你的只会是字符串“1”，而不是 整数1。\nname = input(\u0026#39;enter your name:\u0026#39;) print(\u0026#39;该名同学的名字：%s\u0026#39;%name) age = input(\u0026#39;enter your age:\u0026#39;) print(\u0026#39;年龄：%s\u0026#39;%age) ","permalink":"https://canw0916.github.io/en/posts/tech/%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","summary":"运算符 运算符：以1 + 2为例，1和2被称为操作数，“+” 称为运算符。 Python语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算","title":"运算符和输入输出"},{"content":"变量\u0026amp;常量 思考：计算机的本质作用是什么？\n内存空间\n计算机内存，我们可以将其想象成是一个容器，容器中装载的是即将被计算机运算或者处理的数据。 如果想要将数据成功的加载到内存空间中，则需要确保计算机内存是有足够的空间，则表示数据的存储是需要占用一定大小的内存空间。 且不同的数据或者不同量级的数据占用计算机的内存空间的大小是不一样的。 内存空间大小的度量单位\nbit：位。只可以存储一位二进制的数据。 byte字节：1字节=8bit。 kb：1024字节 mb：1024kb 思考：如果想要计算1+2的结果，Python如何处理呢？\n计算机的本质作用是用来存储和运算二进制的数据，因此，先将1and2转换成二进制的值为0001，0010 在计算机内存空间中先找出两块内存空间用来存储0001和0010这两个数值数据（在内存中开辟指定的内存空间） Python的解释器会调用计算机的加法寄存器将0001和0010进行加法运算返回结果即可 计算机内存空间默认的两个属性\n内存空间大小 决定了该内存可以存储数据的范围 内存空间地址 让cpu进行寻址。 变量/引用：\n在程序运行过程中，值会发生变化的量（变量）\n变量是一段有名字的连续存储空间。我们通过定义变量来申请并命名这样的存储空间，并通过变量的名字来使用这段存储空间。\n在编程语言中，将数据放入变量的过程叫做赋值（Assignment）。Python 使用等号=作为赋值运算符，具体格式为：\n变量名 = 任意类型的值 例如：\nnum = 100 数学 = 200 常量：\n在程序运行过程中，值不会发生变化的量（常量） 具体的使用：\n无论是变量还是常量，在创建时都会在内存中开辟一块空间，用于保存它的值 因此所谓的变量其实表示的就是值（加载到内存中的数据）对应的内存空间的一个引用，因此变量也叫做引用 Python中的变量不需要声明类型 用“=”号来给变量赋值 这里的等号要理解并读作“赋值”，而不是“等于”，“赋值”是对变量的操作，而“等于”是对两个变量进行比较 每个变量在使用前都必须赋值，变量赋值以后才会被创建 在python中变量就是引用，引用就是变量。\n指向\n如果一个变量或者一个引用可以表示某一块具体的内存空间，则我们可以称为该变量指向该块内存。 标识符的命名规则\n简单地理解，标识符就是一个名字，就好像我们每个人都有属于自己的名字，它的主要作用就是作为变量、函数、类、模块以及其他对象的名称。Python中标识符的命名不是随意的，而是要遵守一定的命令规则\n标识符是由字符（A~Z 和 a~z）、下划线和数字组成，但第一个字符不能是数字。\n标识符不能和 Python 中的保留字相同。有关保留字，后续章节会详细介绍。\nPython中的标识符中，不能包含空格、@、% 以及 $ 等特殊字符。\n在 Python 中，标识符中的字母是严格区分大小写\nPython 语言中，以下划线开头的标识符有特殊含义\nPython 允许使用汉字作为标识符（不推荐）\nPython关键字\nand as assert break class continue def del elif else except finally for from False global if import in is lambda nonlocal not None or pass raise return try True while with yield 缩进\n和其它程序设计语言（如 Java、C 语言）采用大括号“{}”分隔代码块不同，Python 采用冒号（ : ）和代码缩进和来区分代码块之间的层次。在 Python 中，对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。\n注意，Python 中实现对代码的缩进，可以使用空格或者 Tab 键实现。但无论是手动敲空格，还是使用 Tab 键，通常情况下都是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。\n注释：\n注释就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。注释是编写程序时，写程序的人给一个语句、程序段、函数等的解释或提示，能提高程序代码的可读性。一般情况下，合理的代码注释应该占源代码的 1/3 左右。\n注释只是为了提高公认阅读，不会被解释器执行。\nPython 支持两种类型的注释，分别是单行注释和多行注释。\n# 单行注释 \u0026#34;\u0026#34;\u0026#34; 这是一个多行注释 三引号里面的任何内容不会被解释器执行 \u0026#34;\u0026#34;\u0026#34; 赋值符号的运算法则\n“=”号这个赋值运算符是从右往左的计算顺序\nPython允许同时为多个变量赋值\n也可以同时为多个变量赋值，用逗号分隔，逐一对应\n不要把赋值语句的等号等同于数学的等号\nname = \u0026#39;bobo\u0026#39; a = b = c = 1 a,b,c = 1,2,3 把一个变量a赋值给另一个变量b，这个操作实际上是将变量b指向变量a所指向的数据，例如下面的代码，思考结果输出的是什么？\na = \u0026#39;Jack\u0026#39; b = a a = \u0026#39;Tom\u0026#39; print(b) 最后变量b的内容到底是\u0026rsquo;Jack\u0026rsquo;还是\u0026rsquo;Tom\u0026rsquo;呢？如果从数学意义上理解，就会错误地得出b和a相同是‘Tom’，但实际上b的值还是\u0026rsquo;Jack ‘!why？如何理解呢？ 请牢记：Python中的一切都是对象，变量是对象的引用！所谓的对象我们在后面的面向对象环节中会详细讲解，现在我们就简单认为Python会把所有的数据都视为是不同的对象即可，数据就是对象，对象就是数据。 执行a = ‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象； 执行b = a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象； 执行a = ‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。 常量\n常量就是不变的变量，比如常用的数学常数圆周率就是一个常量。在Python中，通常用全部大写的变量名表示常量：PI = 3.14159265359 但事实上，从Python语法角度看，PI仍然是一个变量，因为Python根本没有任何机制保证PI不会被改变。你完全可以给PI赋值为10，不会弹出任何错误。所以，用全部大写的变量名表示常量只是一个习惯上的用法。 ","permalink":"https://canw0916.github.io/en/posts/tech/python%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","summary":"变量\u0026amp;常量 思考：计算机的本质作用是什么？ 内存空间 计算机内存，我们可以将其想象成是一个容器，容器中装载的是即将被计算机运算或者处理的数","title":"Python的变量和常量"},{"content":" 博客使用了由 Sulv 魔改的PaperMod主题,详细的配置方法可见 :Sulv\u0026rsquo;s Blog\nMac風格的code blocks 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為mac-code-blocks.css\npre { position: relative; padding: 30px 10px 10px 10px; } .post-content pre code { font-family: Consolas; } pre::after { display: block; content: \u0026#34; \u0026#34;; position: absolute; border-radius: 50%; background: #ff5f56; width: 12px; height: 12px; top: 0; left: 12px; margin-top: 12px; -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; } 添加utterances评论 在github创建一个公共仓库用于存储评论内容\n授权安装utterances\n进入utterances app 对自己所要保存评论的仓库授权 授权之后再进去则可以配置参数 编辑comments配置,建议在根目录layouts\\partials下创建comments.html文件并编辑：\n\u0026lt;!-- utterances comments--\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;pagination__title\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;pagination__title-h\u0026#34; style=\u0026#34;font-size: 20px;\u0026#34;\u0026gt;💬评论\u0026lt;/span\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;tcomment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;canw0916/utterances_comments\u0026#34; issue-term=\u0026#34;title\u0026#34; theme=\u0026#34;photon-dark\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; repo换成自己的仓库名称,格式:用户名/仓库名 theme换成自己选择的主题名字 编辑config.yml,在params参数下添加(repo和theme换成自己的):\nutteranc: enable: true repo: \u0026#34;canw0916/utterances_comments\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;photon-dark\u0026#34; [参考链接] 艾倫的程式之旅-Hugo PaperMod 優化 Hugo博客添加添加utterances评论 ","permalink":"https://canw0916.github.io/en/posts/blog/papermod%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/","summary":"博客使用了由 Sulv 魔改的PaperMod主题,详细的配置方法可见 :Sulv\u0026rsquo;s Blog Mac風格的code blocks 在\\themes\\PaperMod\\assets\\cs","title":"PaperMod主题美化"},{"content":" Was mich nicht umbringt, macht mich stärker. \u0026mdash;Friedrich Nietzsche\n","permalink":"https://canw0916.github.io/en/posts/life/%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/","summary":"Was mich nicht umbringt, macht mich stärker. \u0026mdash;Friedrich Nietzsche","title":"名人名言"},{"content":"\u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://canw0916.github.io/en/posts/read/%E4%B8%89%E4%BD%93/","summary":"\u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e","title":"短代码测试"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://canw0916.github.io/en/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文","title":"🤝友链"},{"content":"关于我\n网名: Felix 职业: 黑厂打螺丝的 运动: 跑步、网球、爬山 ","permalink":"https://canw0916.github.io/en/about/","summary":"关于我 网名: Felix 职业: 黑厂打螺丝的 运动: 跑步、网球、爬山","title":"🙋🏻‍♂️关于"}]