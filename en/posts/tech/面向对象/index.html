<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面向对象 | Felix's Blog</title>
<meta name=keywords content><meta name=description content="面向对象 面向过程VS面向对象 面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线"><meta name=author content="
作者:Felix"><link rel=canonical href=https://canw0916.github.io/en/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/><link crossorigin=anonymous href=/assets/css/stylesheet.b93dd213ece484c2198b1b6b8cb8d2248f9f93dda4c99f628a97f7e932ee21f8.css integrity="sha256-uT3SE+zkhMIZixtrjLjSJI+fk92kyZ9iipf36TLuIfg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://canw0916.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://canw0916.github.io/img/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://canw0916.github.io/img/favicon-32x32.png><link rel=apple-touch-icon href=https://canw0916.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://canw0916.github.io/img/android-chrome-512x512.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-7ENSZ7BS0C"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7ENSZ7BS0C",{anonymize_ip:!1})}</script><meta property="og:title" content="面向对象"><meta property="og:description" content="面向对象 面向过程VS面向对象 面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线"><meta property="og:type" content="article"><meta property="og:url" content="https://canw0916.github.io/en/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-10T11:12:31+08:00"><meta property="article:modified_time" content="2023-02-10T11:12:31+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="面向对象"><meta name=twitter:description content="面向对象 面向过程VS面向对象 面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://canw0916.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"🚀 技术","item":"https://canw0916.github.io/en/posts/tech/"},{"@type":"ListItem","position":3,"name":"面向对象","item":"https://canw0916.github.io/en/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面向对象","name":"面向对象","description":"面向对象 面向过程VS面向对象 面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线","keywords":[""],"articleBody":"面向对象 面向过程VS面向对象 面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线，考虑周全什么时候处理什么东西。\n优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。\n缺点是：一套流水线就是用来解决一个问题，代码牵一发而动全身。\n应用场景：\n一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。 面向对象OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，并且一个对象包含数据和操作数据的方法。\n面向对象的程序设计的核心是对象，要理解对象为何物，必须把自己当成上帝（上帝式思维）。上帝眼里世间存在的万物皆为对象。\n形象化场景设计：\n面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，“如来”想了想解决这个问题需要四个人（对象）：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法）。然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。“如来”根本不会管师徒四人按照什么流程去取，只关心最后结果是否可以实现。 因此面向对象的核心思想就是使用一个有一个的对象来完成某件具体是事件，且不用关心完成的具体过程！ 面向对象的优点：面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使他人更加容易理解你的代码逻辑，从而使团队开发变得更从容。\n应用场景：需求经常变化的软件，如互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。\n类和实例 类，英文名字Class，有“类别”，“分类”，“聚类”的意思。\n必须牢记类是抽象的模板，用来描述具有相同属性和方法的对象的集合，比如Animal类。\n而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\nPython使用class关键字来定义类，其基本结构如下：\nclass 类名(): #一般类名首字母是大写 pass 下面是一个学生类：\nclass Student(): #数据 classroom = '101' address = 'beijing' #构造方法 def __init__(self, name, age): self.name = name self.age = age #操作 def print_age(self): print('%s: %s' % (self.name, self.age)) 对象的创建\n可以通过调用类的实例化方法（有的语言中也叫初始化方法或构造函数）来创建一个类的实例（对象）。\nPython提供了一个def __init__(self):的实例化机制。任何一个类中，名字为__init__的方法就是类的实例化方法，具有__init__方法的类在实例化的时候，会自动调用该方法，并传递对应的参数。\nzhangsan = Student('zhangsan',20) lisi = Student('lisi',30) 实例变量和类变量 实例变量\n实例变量指的是实例（对象）本身拥有的变量。Student类中__init__方法里的name和age就是两个实例变量。\n通过实例名加圆点的方式调用实例变量（可以通过对象名打点的方式去调用/访问属于对象的成员）。\nclass Student(): #init称为构造方法 def __init__(self,i_name,i_age): #只要定义在init方法内部的变量就是【实例/对象变量】 self.name = i_name #self.name就是定义的实例变量，name是init方法的参数值 self.age = i_age #self.age就是定义的实例变量，age就是init方法的参数值 s1 = Student('zhangsan',20) #调用Student类中的init这个构造方法 s2 = Student('lisi',25) #根据对象的引用访问对象的实例变量 print(s1.name,s1.age) #访问s1对象的name和age这两个实例变量 print(s2.name,s2.age) #访问s2对象的name和age这两个实例变量 类变量\n定义在类中，方法之外的变量，称作类变量。类变量是所有实例公有的变量，每一个实例都可以访问类变量。\n在Student类中，classroom和address两个变量就是类变量。可以通过类名或者实例名加圆点的方式访问类变量，比如：\nclass Student(): #定义在方法外部的变量：类变量 address = 'Beijing' classroom = 167 #init称为构造方法 def __init__(self,i_name,i_age): #只要定义在init方法内部的变量就是【实例/对象变量】 self.name = i_name #self.name就是定义的实例变量，name是init方法的参数值 self.age = i_age #self.age就是定义的实例变量，age就是init方法的参数值 s1 = Student('zhangsan',20) #调用Student类中的init这个构造方法 s2 = Student('lisi',25) #根据对象的引用访问对象的实例变量 print(s1.name,s1.age) #访问s1对象的name和age这两个实例变量 print(s2.name,s2.age) #访问s2对象的name和age这两个实例变量 类变量的特性：\n所有的类变量是可以通过类名或者对象名打点的方式访问/调用的。\nprint(s1.address,s1.classroom) #通过对象名可以访问类变量（不推荐） #通过类名可以访问类变量（推荐） print(Student.address,Student.classroom) 类变量是可以被所有的对象公用的\nprint(s1.address,s1.classroom) #通过s1对象访问类变量 print(s2.address,s2.classroom) #通过s2对象访问类变量 思考：如何修改类变量中存储的数据？\n通过对象名访问类变量对其进行内容的修改？\nclass Student(): #定义在方法外部的变量：类变量 address = 'Beijing' classroom = 167 #init称为构造方法 def __init__(self,i_name,i_age): #只要定义在init方法内部的变量就是【实例/对象变量】 self.name = i_name #self.name就是定义的实例变量，name是init方法的参数值 self.age = i_age #self.age就是定义的实例变量，age就是init方法的参数值 s1 = Student('zhangsan',20) #调用Student类中的init这个构造方法 s2 = Student('lisi',25) #想要通过s1对象访问address类变量，且给其修改内容 s1.address = 'SH' print(s2.address) #思考：类变量是被所有的对象共享，因此通过s1对象修改了类变量，s2再次访问类变量，情况如何？ #s2访问的类变量address依然是beijing不是s1修改后的上海，Why？ #这种情况是说明类变量不是被所有对象共享的吗？一定不是这样！ 特别注意：建议大家使用类名访问类变量。如果通过对象名直接访问类变量是没有问题的。但是通过对象名访问类变量后给其进行赋值操作意图修改类变量实则发生的是通过对象打点的方式给对象动态的新增了一个实例变量，并不是在修改类变量。\ns1.address = 'SH' #动态的给s1这个变量新增了一个实例变量，这个实例变量叫做address。该操作执行完毕后，则s1这个对象内部多了一个实例变量叫做s1，且s1对象对应的类中也有一个address表示的类变量。 print(Student.address)#在访问类变量address，这个类变量依然还是Beijing。 通过实例名修改？\n#在访问类变量 print(s1.address,s2.address) #通过类名访问类变量且对其进行修改 Student.address = 'SH' #查看修改后的结果 print(s1.address,s2.address) #SH SH 注意：\n#对象创建好了之后，是可以通过对象名动态的给对象添加新的实例变量。对象添加了实例变量后，只会影响该对象本身，不会对类和其他对象造成影响。 #给s1对象动态添加了一个实例变量book s1.book = 'sanguo' #下述语句报错，因为s1动态增加的实例变量，只会影响它自己，不会影响到其他 print(s2.book,Student.book) 测试：\nclass Student(): address = 'Beijing' #构造方法：用来实例变量初始化赋值 def __init__(self,addr): #构造方法中也可以写入其他操作，但是一般情况下，只需要在构造方法中写给实例变量初始化赋值的操作。 self.address = addr #实例变量名和类变量名一致 s = Student('SH') #创建对象其实就是在调用类中的init方法 #如果实例变量和类变量同名，通过对象名访问，优先方位对象的实例变量 print(s.address) #输出：SH print(Student.address)#输出：Beijing 类的方法 Python的类中包含实例方法、静态方法和类方法三种方法。区别在于传入的参数和调用方式不同。\n在类的内部，使用def关键字来定义一个方法。\n实例方法 类的实例方法由实例调用，至少包含一个self参数，且为第一个参数。执行实例方法时，会自动将调用该方法的实例赋值给self。\nself代表的是类的实例，而非类本身。self不是关键字，而是Python约定成俗的命名，你完全可以取别的名字，但不建议这么做。\n例如，我们前面Student类中的print_age()就是实例方法：\nclass Student(): classroot = 167 #类变量 #构造方法 def __init__(self,name,age): #实例变量 self.name = name self.age = age #实例方法:self不是python的关键字，实例方法的第一个参数也可以叫其他的名字，但是约定俗成叫做self。 #注意：实例方法只可以通过对象调用。 def study(self,book):#self是不需要手动给其传值 print('正在学习的书籍是：',book) s = Student('zhangsan',20) #调用构造方法 #只给除了self其他的参数传值 s.study('高等数学') 实例方法中的第一个参数self到底是什么鬼？\n想要在一个实例方法内部调用另一个实例方法？ 核心：实例方法只可以被对象调用 class Student(): classroot = 167 #类变量 #构造方法 def __init__(self,name,age): #实例变量 self.name = name self.age = age #实例方法 def study(self,book): #self就是study方法的调用者（对象） #注意：在study方法内部调用play方法，如何实现？ self.play('足球') #实例方法必须使用对象调用 #self表示的就是调用该方法的对象的引用 print('正在学习的书籍是：',book) #实例方法 def play(self,b): print('正在玩的项目是:',b) s = Student('zhangsan',20) #调用构造方法 s.study('高等数学') self就是study方法的调用者（对象），self表示的就是调用该方法的对象的引用 对象之间的交互：设计人狗大战游戏，让他们真正的打一架。\nclass Person(): def __init__(self,name): self.name = name self.blood = 100 #人的初始血量 self.gjl = 10 #人的攻击力 def hitDog(self,dog): #dog参数表示的是狗对象 #人打狗后，需要让狗的血量减去人的攻击力 dog.blood -= self.gjl #展示剩余血量 def showBlood(self): print('%s，剩下的血量为：%d'%(self.name,self.blood)) class Dog(): def __init__(self,name): self.name = name self.blood = 50 #狗的初始血量 self.gjl = 5 #狗的攻击力 def hitPerson(self,p): #参数p就是狗攻击的人那个对象 p.blood -= self.gjl #展示剩余血量 def showBlood(self): print('%s，剩下的血量为：%d'%(self.name,self.blood)) p1 = Person('zhangsan') p2 = Person('lisi') d1 = Dog('doudou') d2 = Dog('huanghuang') p2.hitDog(d1) #lisi去攻击doudou这条狗 d1.showBlood() #查看被攻击后的狗还剩下多少血量 d2.hitPerson(p1) #huanghuang去攻击zhangsan p1.showBlood() #查看被攻击后的人还剩下多少血量 静态方法 静态方法由类调用，无默认参数。将实例方法参数中的self去掉，然后在方法定义上方加上@staticmethod，就成为静态方法。\n静态方法属于类，和实例无关。建议只使用类名.静态方法的调用方式。（虽然也可以使用实例名.静态方法的方式调用）\nclass Obj(): def __init__(self): pass #定义一个静态方法 @staticmethod def staticFunc(name):#静态方法不需要有任何的必要参数 print('我是静态方法！，我有一个普通参数：',name) Obj.staticFunc('bobo') #通过类名调用（推荐） o = Obj() o.staticFunc('bobo') #通过对象名调用（不推荐） #静态方法既不属于类也不属于对象，仅仅是写在类内部的一个普通函数而已 类方法 类方法由类调用，采用@classmethod装饰，至少传入一个cls（代指类本身，类似self）参数。\n执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用）\nclass Obj(): f = 'classVar' #类变量 def __init__(self): pass @classmethod def classFunc(cls): #类方法必须要有一个cls的参数，且作为第一个参数 #cls也不是python的关键字，cls也可以写作其他的形式，比如：name，self print('我是类方法！必要参数cls的值为：',cls) print('类变量的值为:',cls.f) #类名访问类变量 #cls表示的是当前类 o = Obj() o.classFunc() #通过对象名访问（不推荐） Obj.classFunc() #通过类名访问（推荐） 测试题：\n在类方法中是否可以调用实例方法和实例变量？ 不能，因为实例变量和实例方法只可以通过对象名访问，但是在类方法内部不存在对象名。 在实例方法中是否可以调用类方法和类变量？ 可以，但是不建议这么做！ 面向对象的组合用法 组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合\n思路设计：一个学生会有一步手机，学生使用手机看电影。\nclass Student(): def __init__(self): #将创建好的手机对象赋值给了phone这个实例变量 self.phone = Phone('霸王别姬') class Phone(): def __init__(self,movie_name): self.movie_name = movie_name def playMovie(self): print('手机正在播放的电影是：',self.movie_name) s1 = Student() s1.phone.playMovie() 封装、继承和多态 面向对象有三大特性：封装、继承和多态\n封装 封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现且不能通过任何形式修改对象内部实现，正是由于封装机制。\n作用：\n程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。 class Student: classroom = '101' address = 'beijing' def __init__(self, name, age): self.name = name self.age = age def print_age(self): print('%s: %s' % (self.name, self.age)) # 以下是错误的用法 # 类将它内部的变量和方法封装起来，阻止外部的直接访问 print(classroom) print(adress) print_age() 继承 继承来源于现实世界：\n一个最简单的例子就是孩子会具有父母的一些特征，即每个孩子都会继承父亲或者母亲的某些特征，当然这只是最基本的继承关系，现实世界中还存在着更复杂的继承。 在OOP程序设计中，当我们定义一个新类的时候，新的类称为子类（Subclass），而被继承的类称为基类、父类或超类（Base class、Super class）。\n继承最大的好处是子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展。其语法结构如下：\nclass Foo(superA, superB,superC....): pass Python支持多父类的继承机制。\n继承示例代码：子类可以继承到父类中所有的成员\nclass Father(): address = 'Beijing' #类变量 #构造方法 def __init__(self,fistName,hobby): #两个实例变量 self.firstName = fistName self.hobby = hobby def get_xxx(self): print('我是Father的实例方法') @classmethod def classFunc(cls): print('我是Father类的类方法') @staticmethod def staticFunc(): print('我是Father类的静态方法') #Son继承了Father这个类 #Son子类，Father父类 class Son(Father): pass #1.子类可以继承到父类的构造方法 s = Son('zhang','smoke') #调用子类的构造方法，子类是可以继承到父类的构造方法 #2.子类可以继承到父类的类变量 print(Son.address) #3.子类可以继承到父类的实例变量 print(s.firstName,s.hobby) #4.子类可以继承到父类的实例方法 s.get_xxx() #5.子类可以继承到父类的类方法 Son.classFunc() #6.子类可以继承到父类的静态方法 Son.staticFunc() 派生 子类添加自己独有的方法和或属性 class Father(): address = 'Beijing' #类变量 #构造方法 def __init__(self,fistName,hobby): #两个实例变量 self.firstName = fistName self.hobby = hobby def get_xxx(self): print('我是Father的实例方法') @classmethod def classFunc(cls): print('我是Father类的类方法') @staticmethod def staticFunc(): print('我是Father类的静态方法') class Son(Father): #子类自己派生出来的独有的方法 def sing(self): print('子类的实例方法sing') s = Son('zhang','smoke') s.sing() 方法的重写 重写:子类继承到父类的方法，如果满足不了子类的需求，则子类可以重写从父类中继承到的方法。重写父类方法有两种方式：1完全重写，2部分重写\n1.完全重写：完全重新将父类的方法进行的全新的定义/实现（毫无保留父类方法原始的功能）\nclass Father(): def __init__(self,firstName): self.firstName = firstName def hobby(self): print('我喜欢读书，运动和跳舞！') class Son(Father): #完全重写 def hobby(self): print('我喜欢吃鸡，王者！') s = Son('zhang') s.hobby() 2.部分重写：在父类方法功能实现的基础上新增了其他操作/功能\nclass Father(): def __init__(self,firstName): self.firstName = firstName def hobby(self): print('我喜欢读书，运动和跳舞！') class Son(Father1): #部分重写 def hobby(self): #调用一下父类的hobby方法 super().hobby() #调用父类的方法 print('我喜欢吃鸡，王者！') s = Son('zhang') s.hobby() super()只可以作用在类的内部，然后表示的是父类对象的引用。\nsuper函数\n如果你想强制调用父类的成员该如何实现呢？使用super()函数！这是一个非常重要的函数，最常见的就是通过super调用父类的实例化方法__init__！\n语法：super(子类名, self).方法名()，需要传入的是子类名和self，调用的是父类里的方法，按父类的方法需要传入参数。\nclass Father(): def __init__(self,firstName): self.firstName = firstName def hobby(self): print('我喜欢读书，运动和跳舞！') class Son(Father): #子类需要有属于自己的实例变量 def __init__(self,firstName,classroom,score): super().__init__(firstName) #子类自己派生出的独有的实例变量 self.classroom = classroom self.score = score #部分重写 def hobby(self): #调用一下父类的hobby方法 super().hobby() #调用父类的方法 print('我喜欢吃鸡，王者！') s = Son('zhang',102,100) s.hobby() 继承的作用：\n实现了程序的高复用，大大缩短程序的开发周期！ 在多继承中，继承关系的优先级\nclass Father1(): def hobby(self): print('我是Father1，我喜欢唱歌！') class Father2(): def hobby(self): print('我是Father2，我喜欢跳舞！') #注意：越靠前的父类越优先被继承 class Son(Father1,Father2): #方法的重写 def hobby(self): #思考：现在Son有两个父类，super()表示的是哪一个父类对象？ #输出结果显示super表示的是Father1对象 super().hobby() print('我是Son，我喜欢吃鸡！') s = Son() s.hobby() type和isinstance\nisinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。\nisinstance() 方法的语法:\nisinstance(object, classinfo) 参数： object -- 实例对象。 classinfo -- 可以是类名、基本类型或者有它们组成的元组。 返回值： 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。 class Father(): pass class Son(Father): pass s = Son() #子类对象 print(isinstance(s,Son)) #True #s这个对象是属于Son这个数据类型的。 #python的数据类型：内置类型（8中），自定义类型（类） class Father(): pass class Son(Father): pass s = Son() #子类对象 print(isinstance(s,Father)) #True #注意：子类对象可以被视为是一种父类类型 class Father(): pass class Son(Father): pass s = Son() #子类对象 print(type(s)) #","wordCount":"11608","inLanguage":"en","datePublished":"2023-02-10T11:12:31+08:00","dateModified":"2023-02-10T11:12:31+08:00","author":[{"@type":"Person","name":"Felix"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://canw0916.github.io/en/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},"publisher":{"@type":"Organization","name":"Felix's Blog","logo":{"@type":"ImageObject","url":"https://canw0916.github.io/img/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><header class=header><nav class=nav><div class=logo><a href=https://canw0916.github.io/en/ accesskey=h title="Felix's Blog (Alt + H)"><img src=https://canw0916.github.io/img/android-chrome-512x512.png alt=logo aria-label=logo height=35>Felix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://canw0916.github.io/en/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://canw0916.github.io/en/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://canw0916.github.io/en/posts title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://canw0916.github.io/en/tags title="💡 标签"><span>💡 标签</span></a></li><li><a href=https://canw0916.github.io/en/archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://canw0916.github.io/en/about title="👦 关于"><span>👦 关于</span></a></li><li><a href=https://canw0916.github.io/en/links title="😺 友链"><span>😺 友链</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://canw0916.github.io/en/>🏠主页</a>&nbsp;»&nbsp;<a href=https://canw0916.github.io/en/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://canw0916.github.io/en/posts/tech/>🚀 技术</a></div><h1 class=post-title>面向对象</h1><div class=post-meta>创建:2023-02-10|更新:2023-02-10|字数:11608字|时长: 24分钟|
作者:Felix
&nbsp;&nbsp;标签: &nbsp;<ul class=post-tags-meta><a href=https://canw0916.github.io/en/tags/python/>python</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>文章目录</span></summary><div class=inner><ul><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1 aria-label=面向对象>面向对象</a><ul><li><a href=#%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8bvs%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1 aria-label=面向过程VS面向对象>面向过程VS面向对象</a></li><li><a href=#%e7%b1%bb%e5%92%8c%e5%ae%9e%e4%be%8b aria-label=类和实例>类和实例</a></li><li><a href=#%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f%e5%92%8c%e7%b1%bb%e5%8f%98%e9%87%8f aria-label=实例变量和类变量>实例变量和类变量</a></li><li><a href=#%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=类的方法>类的方法</a><ul><li><a href=#%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95 aria-label=实例方法>实例方法</a></li><li><a href=#%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95 aria-label=静态方法>静态方法</a></li><li><a href=#%e7%b1%bb%e6%96%b9%e6%b3%95 aria-label=类方法>类方法</a></li></ul></li><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%bb%84%e5%90%88%e7%94%a8%e6%b3%95 aria-label=面向对象的组合用法>面向对象的组合用法</a></li><li><a href=#%e5%b0%81%e8%a3%85%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81 aria-label=封装、继承和多态>封装、继承和多态</a><ul><li><a href=#%e5%b0%81%e8%a3%85 aria-label=封装>封装</a></li><li><a href=#%e7%bb%a7%e6%89%bf aria-label=继承>继承</a></li><li><a href=#%e6%b4%be%e7%94%9f aria-label=派生>派生</a><ul><li><a href=#%e6%96%b9%e6%b3%95%e7%9a%84%e9%87%8d%e5%86%99 aria-label=方法的重写>方法的重写</a></li></ul></li><li><a href=#%e7%bb%a7%e6%89%bf%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label=继承注意事项>继承注意事项</a></li></ul></li><li><a href=#%e7%b1%bb%e6%96%b9%e6%b3%95%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=类方法的作用>类方法的作用</a><ul><li><a href=#%e7%b1%bb%e6%96%b9%e6%b3%95-1 aria-label=类方法>类方法</a></li></ul></li><li><a href=#%e6%88%90%e5%91%98%e4%bf%9d%e6%8a%a4%e5%92%8c%e8%ae%bf%e9%97%ae%e9%99%90%e5%88%b6 aria-label=成员保护和访问限制>成员保护和访问限制</a></li><li><a href=#reflect%e5%8f%8d%e5%b0%84 aria-label=reflect反射>reflect反射</a></li><li><a href=#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f aria-label=单例模式>单例模式</a></li></ul></li><li><a href=#%e9%93%be%e8%a1%a8 aria-label=链表>链表</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=面向对象>面向对象<a hidden class=anchor aria-hidden=true href=#面向对象>#</a></h3><h4 id=面向过程vs面向对象>面向过程VS面向对象<a hidden class=anchor aria-hidden=true href=#面向过程vs面向对象>#</a></h4><ul><li><p>面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线，考虑周全什么时候处理什么东西。</p></li><li><p><strong>优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。</strong></p></li><li><p><strong>缺点是：一套流水线就是用来解决一个问题，代码牵一发而动全身。</strong></p></li><li><p>应用场景：</p><ul><li>一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。</li></ul></li><li><p>面向对象OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，并且一个对象包含数据和操作数据的方法。</p></li><li><p>面向对象的程序设计的核心是对象，要理解对象为何物，必须把自己当成上帝（上帝式思维）。上帝眼里世间存在的万物皆为对象。</p></li><li><p>形象化场景设计：</p><ul><li>面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，&ldquo;如来”想了想解决这个问题需要四个人（对象）：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法）。然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。“如来”根本不会管师徒四人按照什么流程去取，只关心最后结果是否可以实现。</li><li>因此面向对象的核心思想就是使用一个有一个的对象来完成某件具体是事件，且不用关心完成的具体过程！</li></ul></li><li><p><strong>面向对象的优点：面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使他人更加容易理解你的代码逻辑，从而使团队开发变得更从容。</strong></p></li><li><p><strong>应用场景：需求经常变化的软件，如互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。</strong></p></li></ul><h4 id=类和实例>类和实例<a hidden class=anchor aria-hidden=true href=#类和实例>#</a></h4><p><strong>类</strong>，英文名字Class，有“类别”，“分类”，“聚类”的意思。</p><p>必须牢记类是抽象的模板，用来描述具有相同属性和方法的对象的集合，比如Animal类。</p><p>而<strong>实例</strong>是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p><ul><li><p>Python使用class关键字来定义类，其基本结构如下：</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>类名</span><span class=p>():</span> <span class=c1>#一般类名首字母是大写</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div></li><li><p>下面是一个学生类：</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  	<span class=c1>#数据</span>
</span></span><span class=line><span class=cl>    <span class=n>classroom</span> <span class=o>=</span> <span class=s1>&#39;101&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;beijing&#39;</span> 
</span></span><span class=line><span class=cl>		<span class=c1>#构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>age</span>
</span></span><span class=line><span class=cl>		<span class=c1>#操作</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_age</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%s</span><span class=s1>: </span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>age</span><span class=p>))</span>
</span></span></code></pre></div></li><li><p>对象的创建</p><ul><li><p>可以通过调用类的实例化方法（有的语言中也叫初始化方法或构造函数）来创建一个类的实例（对象）。</p></li><li><p>Python提供了一个<code>def __init__(self):</code>的实例化机制。任何一个类中，名字为<code>__init__</code>的方法就是类的实例化方法，具有<code>__init__</code>方法的类在实例化的时候，会自动调用该方法，并传递对应的参数。</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>zhangsan</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>,</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>lisi</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>,</span><span class=mi>30</span><span class=p>)</span>
</span></span></code></pre></div></li></ul></li></ul><h4 id=实例变量和类变量>实例变量和类变量<a hidden class=anchor aria-hidden=true href=#实例变量和类变量>#</a></h4><ul><li><p>实例变量</p><ul><li><p>实例变量指的是实例（对象）本身拥有的变量。Student类中<code>__init__</code>方法里的name和age就是两个实例变量。</p></li><li><p>通过实例名加圆点的方式调用实例变量（可以通过对象名打点的方式去调用/访问属于对象的成员）。</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#init称为构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>i_name</span><span class=p>,</span><span class=n>i_age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#只要定义在init方法内部的变量就是【实例/对象变量】</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>i_name</span> <span class=c1>#self.name就是定义的实例变量，name是init方法的参数值</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>i_age</span> <span class=c1>#self.age就是定义的实例变量，age就是init方法的参数值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>,</span><span class=mi>20</span><span class=p>)</span> <span class=c1>#调用Student类中的init这个构造方法</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>,</span><span class=mi>25</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#根据对象的引用访问对象的实例变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s1</span><span class=o>.</span><span class=n>name</span><span class=p>,</span><span class=n>s1</span><span class=o>.</span><span class=n>age</span><span class=p>)</span> <span class=c1>#访问s1对象的name和age这两个实例变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s2</span><span class=o>.</span><span class=n>name</span><span class=p>,</span><span class=n>s2</span><span class=o>.</span><span class=n>age</span><span class=p>)</span> <span class=c1>#访问s2对象的name和age这两个实例变量</span>
</span></span></code></pre></div></li></ul></li><li><p>类变量</p><ul><li><p>定义在类中，方法之外的变量，称作类变量。类变量是所有实例公有的变量，每一个实例都可以访问类变量。</p></li><li><p>在Student类中，classroom和address两个变量就是类变量。可以通过类名或者实例名加圆点的方式访问类变量，比如：</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#定义在方法外部的变量：类变量</span>
</span></span><span class=line><span class=cl>    <span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;Beijing&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>classroom</span> <span class=o>=</span> <span class=mi>167</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#init称为构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>i_name</span><span class=p>,</span><span class=n>i_age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#只要定义在init方法内部的变量就是【实例/对象变量】</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>i_name</span> <span class=c1>#self.name就是定义的实例变量，name是init方法的参数值</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>i_age</span> <span class=c1>#self.age就是定义的实例变量，age就是init方法的参数值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>,</span><span class=mi>20</span><span class=p>)</span> <span class=c1>#调用Student类中的init这个构造方法</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>,</span><span class=mi>25</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#根据对象的引用访问对象的实例变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s1</span><span class=o>.</span><span class=n>name</span><span class=p>,</span><span class=n>s1</span><span class=o>.</span><span class=n>age</span><span class=p>)</span> <span class=c1>#访问s1对象的name和age这两个实例变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s2</span><span class=o>.</span><span class=n>name</span><span class=p>,</span><span class=n>s2</span><span class=o>.</span><span class=n>age</span><span class=p>)</span> <span class=c1>#访问s2对象的name和age这两个实例变量</span>
</span></span></code></pre></div><ul><li><p>类变量的特性：</p><ul><li><p>所有的类变量是可以通过类名或者对象名打点的方式访问/调用的。</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s1</span><span class=o>.</span><span class=n>address</span><span class=p>,</span><span class=n>s1</span><span class=o>.</span><span class=n>classroom</span><span class=p>)</span> <span class=c1>#通过对象名可以访问类变量（不推荐）</span>
</span></span><span class=line><span class=cl><span class=c1>#通过类名可以访问类变量（推荐）</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Student</span><span class=o>.</span><span class=n>address</span><span class=p>,</span><span class=n>Student</span><span class=o>.</span><span class=n>classroom</span><span class=p>)</span>
</span></span></code></pre></div></li><li><p>类变量是可以被所有的对象公用的</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s1</span><span class=o>.</span><span class=n>address</span><span class=p>,</span><span class=n>s1</span><span class=o>.</span><span class=n>classroom</span><span class=p>)</span> <span class=c1>#通过s1对象访问类变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s2</span><span class=o>.</span><span class=n>address</span><span class=p>,</span><span class=n>s2</span><span class=o>.</span><span class=n>classroom</span><span class=p>)</span> <span class=c1>#通过s2对象访问类变量</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><p>思考：如何修改类变量中存储的数据？</p><ul><li><p>通过对象名访问类变量对其进行内容的修改？</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#定义在方法外部的变量：类变量</span>
</span></span><span class=line><span class=cl>    <span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;Beijing&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>classroom</span> <span class=o>=</span> <span class=mi>167</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#init称为构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>i_name</span><span class=p>,</span><span class=n>i_age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#只要定义在init方法内部的变量就是【实例/对象变量】</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>i_name</span> <span class=c1>#self.name就是定义的实例变量，name是init方法的参数值</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>i_age</span> <span class=c1>#self.age就是定义的实例变量，age就是init方法的参数值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>,</span><span class=mi>20</span><span class=p>)</span> <span class=c1>#调用Student类中的init这个构造方法</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>,</span><span class=mi>25</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#想要通过s1对象访问address类变量，且给其修改内容</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=o>.</span><span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;SH&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s2</span><span class=o>.</span><span class=n>address</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#思考：类变量是被所有的对象共享，因此通过s1对象修改了类变量，s2再次访问类变量，情况如何？</span>
</span></span><span class=line><span class=cl><span class=c1>#s2访问的类变量address依然是beijing不是s1修改后的上海，Why？</span>
</span></span><span class=line><span class=cl><span class=c1>#这种情况是说明类变量不是被所有对象共享的吗？一定不是这样！</span>
</span></span></code></pre></div><ul><li><p>特别注意：建议大家使用类名访问类变量。如果通过对象名直接访问类变量是没有问题的。但是通过对象名访问类变量后给其进行赋值操作意图修改类变量实则发生的是通过对象打点的方式给对象动态的新增了一个实例变量，并不是在修改类变量。</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>s1</span><span class=o>.</span><span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;SH&#39;</span> <span class=c1>#动态的给s1这个变量新增了一个实例变量，这个实例变量叫做address。该操作执行完毕后，则s1这个对象内部多了一个实例变量叫做s1，且s1对象对应的类中也有一个address表示的类变量。</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Student</span><span class=o>.</span><span class=n>address</span><span class=p>)</span><span class=c1>#在访问类变量address，这个类变量依然还是Beijing。</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><p>通过实例名修改？</p></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>#在访问类变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s1</span><span class=o>.</span><span class=n>address</span><span class=p>,</span><span class=n>s2</span><span class=o>.</span><span class=n>address</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#通过类名访问类变量且对其进行修改</span>
</span></span><span class=line><span class=cl><span class=n>Student</span><span class=o>.</span><span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;SH&#39;</span>
</span></span><span class=line><span class=cl><span class=c1>#查看修改后的结果</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s1</span><span class=o>.</span><span class=n>address</span><span class=p>,</span><span class=n>s2</span><span class=o>.</span><span class=n>address</span><span class=p>)</span> <span class=c1>#SH SH</span>
</span></span></code></pre></div><p>注意：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>#对象创建好了之后，是可以通过对象名动态的给对象添加新的实例变量。对象添加了实例变量后，只会影响该对象本身，不会对类和其他对象造成影响。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#给s1对象动态添加了一个实例变量book</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=o>.</span><span class=n>book</span> <span class=o>=</span> <span class=s1>&#39;sanguo&#39;</span>
</span></span><span class=line><span class=cl><span class=c1>#下述语句报错，因为s1动态增加的实例变量，只会影响它自己，不会影响到其他</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s2</span><span class=o>.</span><span class=n>book</span><span class=p>,</span><span class=n>Student</span><span class=o>.</span><span class=n>book</span><span class=p>)</span>
</span></span></code></pre></div></li><li><p>测试：</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;Beijing&#39;</span>
</span></span><span class=line><span class=cl>    <span class=c1>#构造方法：用来实例变量初始化赋值</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>addr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#构造方法中也可以写入其他操作，但是一般情况下，只需要在构造方法中写给实例变量初始化赋值的操作。</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>address</span> <span class=o>=</span> <span class=n>addr</span>
</span></span><span class=line><span class=cl>        <span class=c1>#实例变量名和类变量名一致</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;SH&#39;</span><span class=p>)</span> <span class=c1>#创建对象其实就是在调用类中的init方法</span>
</span></span><span class=line><span class=cl><span class=c1>#如果实例变量和类变量同名，通过对象名访问，优先方位对象的实例变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>address</span><span class=p>)</span> <span class=c1>#输出：SH</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Student</span><span class=o>.</span><span class=n>address</span><span class=p>)</span><span class=c1>#输出：Beijing</span>
</span></span></code></pre></div></li></ul><h4 id=类的方法>类的方法<a hidden class=anchor aria-hidden=true href=#类的方法>#</a></h4><p>Python的类中包含实例方法、静态方法和类方法三种方法。区别在于传入的参数和调用方式不同。</p><p>在类的内部，使用<code>def</code>关键字来定义一个方法。</p><h5 id=实例方法>实例方法<a hidden class=anchor aria-hidden=true href=#实例方法>#</a></h5><ul><li><p>类的实例方法由实例调用，至少包含一个self参数，且为第一个参数。执行实例方法时，会自动将调用该方法的实例赋值给self。</p><ul><li><p><code>self</code>代表的是类的实例，而非类本身。<code>self</code>不是关键字，而是Python约定成俗的命名，你完全可以取别的名字，但不建议这么做。</p></li><li><p>例如，我们前面Student类中的print_age()就是实例方法：</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>classroot</span> <span class=o>=</span> <span class=mi>167</span> <span class=c1>#类变量</span>
</span></span><span class=line><span class=cl>    <span class=c1>#构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#实例变量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>age</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#实例方法:self不是python的关键字，实例方法的第一个参数也可以叫其他的名字，但是约定俗成叫做self。</span>
</span></span><span class=line><span class=cl>    <span class=c1>#注意：实例方法只可以通过对象调用。</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>study</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>book</span><span class=p>):</span><span class=c1>#self是不需要手动给其传值</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;正在学习的书籍是：&#39;</span><span class=p>,</span><span class=n>book</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>,</span><span class=mi>20</span><span class=p>)</span> <span class=c1>#调用构造方法</span>
</span></span><span class=line><span class=cl><span class=c1>#只给除了self其他的参数传值</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>study</span><span class=p>(</span><span class=s1>&#39;高等数学&#39;</span><span class=p>)</span>
</span></span></code></pre></div></li><li><p>实例方法中的第一个参数self到底是什么鬼？</p><ul><li>想要在一个实例方法内部调用另一个实例方法？<ul><li>核心：实例方法只可以被对象调用</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>classroot</span> <span class=o>=</span> <span class=mi>167</span> <span class=c1>#类变量</span>
</span></span><span class=line><span class=cl>    <span class=c1>#构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#实例变量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>age</span>
</span></span><span class=line><span class=cl>    <span class=c1>#实例方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>study</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>book</span><span class=p>):</span> <span class=c1>#self就是study方法的调用者（对象）</span>
</span></span><span class=line><span class=cl>        <span class=c1>#注意：在study方法内部调用play方法，如何实现？</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>play</span><span class=p>(</span><span class=s1>&#39;足球&#39;</span><span class=p>)</span> <span class=c1>#实例方法必须使用对象调用</span>
</span></span><span class=line><span class=cl>        <span class=c1>#self表示的就是调用该方法的对象的引用</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;正在学习的书籍是：&#39;</span><span class=p>,</span><span class=n>book</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>#实例方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>play</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;正在玩的项目是:&#39;</span><span class=p>,</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>,</span><span class=mi>20</span><span class=p>)</span> <span class=c1>#调用构造方法</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>study</span><span class=p>(</span><span class=s1>&#39;高等数学&#39;</span><span class=p>)</span>
</span></span></code></pre></div><ul><li>self就是study方法的调用者（对象），self表示的就是调用该方法的对象的引用</li></ul></li></ul></li></ul><p><strong>对象之间的交互</strong>：设计人狗大战游戏，让他们真正的打一架。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>blood</span> <span class=o>=</span> <span class=mi>100</span> <span class=c1>#人的初始血量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>gjl</span> <span class=o>=</span> <span class=mi>10</span> <span class=c1>#人的攻击力</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hitDog</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>dog</span><span class=p>):</span> <span class=c1>#dog参数表示的是狗对象</span>
</span></span><span class=line><span class=cl>        <span class=c1>#人打狗后，需要让狗的血量减去人的攻击力</span>
</span></span><span class=line><span class=cl>        <span class=n>dog</span><span class=o>.</span><span class=n>blood</span> <span class=o>-=</span> <span class=bp>self</span><span class=o>.</span><span class=n>gjl</span>
</span></span><span class=line><span class=cl>    <span class=c1>#展示剩余血量</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>showBlood</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%s</span><span class=s1>，剩下的血量为：</span><span class=si>%d</span><span class=s1>&#39;</span><span class=o>%</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>,</span><span class=bp>self</span><span class=o>.</span><span class=n>blood</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dog</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>blood</span> <span class=o>=</span> <span class=mi>50</span> <span class=c1>#狗的初始血量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>gjl</span> <span class=o>=</span> <span class=mi>5</span> <span class=c1>#狗的攻击力</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hitPerson</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>p</span><span class=p>):</span> <span class=c1>#参数p就是狗攻击的人那个对象</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>.</span><span class=n>blood</span> <span class=o>-=</span> <span class=bp>self</span><span class=o>.</span><span class=n>gjl</span>
</span></span><span class=line><span class=cl>    <span class=c1>#展示剩余血量</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>showBlood</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%s</span><span class=s1>，剩下的血量为：</span><span class=si>%d</span><span class=s1>&#39;</span><span class=o>%</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>,</span><span class=bp>self</span><span class=o>.</span><span class=n>blood</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p1</span> <span class=o>=</span> <span class=n>Person</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>p2</span> <span class=o>=</span> <span class=n>Person</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>d1</span> <span class=o>=</span> <span class=n>Dog</span><span class=p>(</span><span class=s1>&#39;doudou&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>d2</span> <span class=o>=</span> <span class=n>Dog</span><span class=p>(</span><span class=s1>&#39;huanghuang&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p2</span><span class=o>.</span><span class=n>hitDog</span><span class=p>(</span><span class=n>d1</span><span class=p>)</span> <span class=c1>#lisi去攻击doudou这条狗</span>
</span></span><span class=line><span class=cl><span class=n>d1</span><span class=o>.</span><span class=n>showBlood</span><span class=p>()</span> <span class=c1>#查看被攻击后的狗还剩下多少血量</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>d2</span><span class=o>.</span><span class=n>hitPerson</span><span class=p>(</span><span class=n>p1</span><span class=p>)</span> <span class=c1>#huanghuang去攻击zhangsan</span>
</span></span><span class=line><span class=cl><span class=n>p1</span><span class=o>.</span><span class=n>showBlood</span><span class=p>()</span> <span class=c1>#查看被攻击后的人还剩下多少血量</span>
</span></span></code></pre></div><h5 id=静态方法>静态方法<a hidden class=anchor aria-hidden=true href=#静态方法>#</a></h5><ul><li><p>静态方法由类调用，无默认参数。将实例方法参数中的self去掉，然后在方法定义上方加上@staticmethod，就成为静态方法。</p></li><li><p>静态方法属于类，和实例无关。建议只使用类名.静态方法的调用方式。（虽然也可以使用实例名.静态方法的方式调用）</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Obj</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#定义一个静态方法</span>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>staticFunc</span><span class=p>(</span><span class=n>name</span><span class=p>):</span><span class=c1>#静态方法不需要有任何的必要参数</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是静态方法！，我有一个普通参数：&#39;</span><span class=p>,</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Obj</span><span class=o>.</span><span class=n>staticFunc</span><span class=p>(</span><span class=s1>&#39;bobo&#39;</span><span class=p>)</span> <span class=c1>#通过类名调用（推荐）</span>
</span></span><span class=line><span class=cl><span class=n>o</span> <span class=o>=</span> <span class=n>Obj</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>o</span><span class=o>.</span><span class=n>staticFunc</span><span class=p>(</span><span class=s1>&#39;bobo&#39;</span><span class=p>)</span> <span class=c1>#通过对象名调用（不推荐）</span>
</span></span><span class=line><span class=cl><span class=c1>#静态方法既不属于类也不属于对象，仅仅是写在类内部的一个普通函数而已</span>
</span></span></code></pre></div></li></ul><h5 id=类方法>类方法<a hidden class=anchor aria-hidden=true href=#类方法>#</a></h5><ul><li><p>类方法由类调用，采用@classmethod装饰，至少传入一个cls（代指类本身，类似self）参数。</p></li><li><p>执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用）</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Obj</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=o>=</span> <span class=s1>&#39;classVar&#39;</span> <span class=c1>#类变量</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>classFunc</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span> <span class=c1>#类方法必须要有一个cls的参数，且作为第一个参数</span>
</span></span><span class=line><span class=cl>        <span class=c1>#cls也不是python的关键字，cls也可以写作其他的形式，比如：name，self</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是类方法！必要参数cls的值为：&#39;</span><span class=p>,</span><span class=bp>cls</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;类变量的值为:&#39;</span><span class=p>,</span><span class=bp>cls</span><span class=o>.</span><span class=n>f</span><span class=p>)</span> <span class=c1>#类名访问类变量</span>
</span></span><span class=line><span class=cl>        <span class=c1>#cls表示的是当前类</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>o</span> <span class=o>=</span> <span class=n>Obj</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>o</span><span class=o>.</span><span class=n>classFunc</span><span class=p>()</span> <span class=c1>#通过对象名访问（不推荐）</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Obj</span><span class=o>.</span><span class=n>classFunc</span><span class=p>()</span> <span class=c1>#通过类名访问（推荐）</span>
</span></span></code></pre></div></li><li><p>测试题：</p><ul><li>在类方法中是否可以调用实例方法和实例变量？<ul><li>不能，因为实例变量和实例方法只可以通过对象名访问，但是在类方法内部不存在对象名。</li></ul></li><li>在实例方法中是否可以调用类方法和类变量？<ul><li>可以，但是不建议这么做！</li></ul></li></ul></li></ul><h4 id=面向对象的组合用法>面向对象的组合用法<a hidden class=anchor aria-hidden=true href=#面向对象的组合用法>#</a></h4><ul><li><p><strong>组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合</strong></p></li><li><p>思路设计：一个学生会有一步手机，学生使用手机看电影。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#将创建好的手机对象赋值给了phone这个实例变量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>phone</span> <span class=o>=</span> <span class=n>Phone</span><span class=p>(</span><span class=s1>&#39;霸王别姬&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Phone</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>movie_name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>movie_name</span> <span class=o>=</span> <span class=n>movie_name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>playMovie</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;手机正在播放的电影是：&#39;</span><span class=p>,</span><span class=bp>self</span><span class=o>.</span><span class=n>movie_name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=n>Student</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=o>.</span><span class=n>phone</span><span class=o>.</span><span class=n>playMovie</span><span class=p>()</span>
</span></span></code></pre></div><h4 id=封装继承和多态>封装、继承和多态<a hidden class=anchor aria-hidden=true href=#封装继承和多态>#</a></h4><p>面向对象有三大特性：封装、继承和多态</p><h5 id=封装>封装<a hidden class=anchor aria-hidden=true href=#封装>#</a></h5><ul><li><p>封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现且不能通过任何形式修改对象内部实现，正是由于封装机制。</p></li><li><p>作用：</p><ul><li>程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。</li></ul></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>classroom</span> <span class=o>=</span> <span class=s1>&#39;101&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;beijing&#39;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>age</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_age</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%s</span><span class=s1>: </span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>age</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 以下是错误的用法</span>
</span></span><span class=line><span class=cl><span class=c1># 类将它内部的变量和方法封装起来，阻止外部的直接访问</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>classroom</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>adress</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>print_age</span><span class=p>()</span>
</span></span></code></pre></div></li></ul><h5 id=继承>继承<a hidden class=anchor aria-hidden=true href=#继承>#</a></h5><ul><li><p>继承来源于现实世界：</p><ul><li>一个最简单的例子就是孩子会具有父母的一些特征，即每个孩子都会继承父亲或者母亲的某些特征，当然这只是最基本的继承关系，现实世界中还存在着更复杂的继承。</li></ul></li><li><p>在OOP程序设计中，当我们定义一个新类的时候，新的类称为子类（Subclass），而被继承的类称为基类、父类或超类（Base class、Super class）。</p><ul><li><p>继承最大的好处是子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展。其语法结构如下：</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>(</span><span class=n>superA</span><span class=p>,</span> <span class=n>superB</span><span class=p>,</span><span class=n>superC</span><span class=o>....</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=k>pass</span>
</span></span></code></pre></div></li><li><p>Python支持多父类的继承机制。</p></li></ul></li></ul><p>继承示例代码：子类可以继承到父类中所有的成员</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;Beijing&#39;</span> <span class=c1>#类变量</span>
</span></span><span class=line><span class=cl>    <span class=c1>#构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>fistName</span><span class=p>,</span><span class=n>hobby</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#两个实例变量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>firstName</span> <span class=o>=</span> <span class=n>fistName</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>hobby</span> <span class=o>=</span> <span class=n>hobby</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_xxx</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father的实例方法&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>classFunc</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father类的类方法&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>staticFunc</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father类的静态方法&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#Son继承了Father这个类</span>
</span></span><span class=line><span class=cl><span class=c1>#Son子类，Father父类</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#1.子类可以继承到父类的构造方法</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>(</span><span class=s1>&#39;zhang&#39;</span><span class=p>,</span><span class=s1>&#39;smoke&#39;</span><span class=p>)</span> <span class=c1>#调用子类的构造方法，子类是可以继承到父类的构造方法</span>
</span></span><span class=line><span class=cl><span class=c1>#2.子类可以继承到父类的类变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>Son</span><span class=o>.</span><span class=n>address</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#3.子类可以继承到父类的实例变量</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>firstName</span><span class=p>,</span><span class=n>s</span><span class=o>.</span><span class=n>hobby</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#4.子类可以继承到父类的实例方法</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>get_xxx</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>#5.子类可以继承到父类的类方法</span>
</span></span><span class=line><span class=cl><span class=n>Son</span><span class=o>.</span><span class=n>classFunc</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>#6.子类可以继承到父类的静态方法</span>
</span></span><span class=line><span class=cl><span class=n>Son</span><span class=o>.</span><span class=n>staticFunc</span><span class=p>()</span>
</span></span></code></pre></div><h5 id=派生>派生<a hidden class=anchor aria-hidden=true href=#派生>#</a></h5><ul><li>子类添加自己独有的方法和或属性</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;Beijing&#39;</span> <span class=c1>#类变量</span>
</span></span><span class=line><span class=cl>    <span class=c1>#构造方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>fistName</span><span class=p>,</span><span class=n>hobby</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#两个实例变量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>firstName</span> <span class=o>=</span> <span class=n>fistName</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>hobby</span> <span class=o>=</span> <span class=n>hobby</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_xxx</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father的实例方法&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>classFunc</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father类的类方法&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>staticFunc</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father类的静态方法&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#子类自己派生出来的独有的方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>sing</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;子类的实例方法sing&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>(</span><span class=s1>&#39;zhang&#39;</span><span class=p>,</span><span class=s1>&#39;smoke&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>sing</span><span class=p>()</span>
</span></span></code></pre></div><h6 id=方法的重写>方法的重写<a hidden class=anchor aria-hidden=true href=#方法的重写>#</a></h6><ul><li><p>重写:子类继承到父类的方法，如果满足不了子类的需求，则子类可以重写从父类中继承到的方法。重写父类方法有两种方式：1完全重写，2部分重写</p><ul><li><p>1.完全重写：完全重新将父类的方法进行的全新的定义/实现（毫无保留父类方法原始的功能）</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>      <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>firstName</span><span class=p>):</span>
</span></span><span class=line><span class=cl>          <span class=bp>self</span><span class=o>.</span><span class=n>firstName</span> <span class=o>=</span> <span class=n>firstName</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>          <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我喜欢读书，运动和跳舞！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=c1>#完全重写</span>
</span></span><span class=line><span class=cl>      <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>          <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我喜欢吃鸡，王者！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>(</span><span class=s1>&#39;zhang&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span><span class=o>.</span><span class=n>hobby</span><span class=p>()</span>
</span></span></code></pre></div></li></ul></li><li><p>2.部分重写：在父类方法功能实现的基础上新增了其他操作/功能</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>firstName</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>firstName</span> <span class=o>=</span> <span class=n>firstName</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我喜欢读书，运动和跳舞！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#部分重写</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#调用一下父类的hobby方法</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>hobby</span><span class=p>()</span> <span class=c1>#调用父类的方法</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我喜欢吃鸡，王者！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>(</span><span class=s1>&#39;zhang&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>hobby</span><span class=p>()</span>
</span></span></code></pre></div></li></ul></li><li><p>super()只可以作用在类的内部，然后表示的是父类对象的引用。</p></li></ul></li><li><p>super函数</p><ul><li><p>如果你想强制调用父类的成员该如何实现呢？使用super()函数！这是一个非常重要的函数，最常见的就是通过super调用父类的实例化方法<code>__init__</code>！</p><ul><li><p>语法：<code>super(子类名, self).方法名()</code>，需要传入的是子类名和self，调用的是父类里的方法，按父类的方法需要传入参数。</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>firstName</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>firstName</span> <span class=o>=</span> <span class=n>firstName</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我喜欢读书，运动和跳舞！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#子类需要有属于自己的实例变量</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>firstName</span><span class=p>,</span><span class=n>classroom</span><span class=p>,</span><span class=n>score</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>firstName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>#子类自己派生出的独有的实例变量</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>classroom</span> <span class=o>=</span> <span class=n>classroom</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>score</span> <span class=o>=</span> <span class=n>score</span>
</span></span><span class=line><span class=cl>    <span class=c1>#部分重写</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#调用一下父类的hobby方法</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>hobby</span><span class=p>()</span> <span class=c1>#调用父类的方法</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我喜欢吃鸡，王者！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>(</span><span class=s1>&#39;zhang&#39;</span><span class=p>,</span><span class=mi>102</span><span class=p>,</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>hobby</span><span class=p>()</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><p>继承的作用：</p><ul><li>实现了程序的高复用，大大缩短程序的开发周期！</li></ul></li><li><p>在多继承中，继承关系的优先级</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Father1</span><span class=p>():</span>
</span></span><span class=line><span class=cl>      <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>          <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father1，我喜欢唱歌！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Father2</span><span class=p>():</span>
</span></span><span class=line><span class=cl>      <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>          <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Father2，我喜欢跳舞！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>#注意：越靠前的父类越优先被继承</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father1</span><span class=p>,</span><span class=n>Father2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=c1>#方法的重写</span>
</span></span><span class=line><span class=cl>      <span class=k>def</span> <span class=nf>hobby</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>          <span class=c1>#思考：现在Son有两个父类，super()表示的是哪一个父类对象？</span>
</span></span><span class=line><span class=cl>          <span class=c1>#输出结果显示super表示的是Father1对象</span>
</span></span><span class=line><span class=cl>          <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>hobby</span><span class=p>()</span>
</span></span><span class=line><span class=cl>          <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;我是Son，我喜欢吃鸡！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span><span class=o>.</span><span class=n>hobby</span><span class=p>()</span>
</span></span></code></pre></div></li></ul></li></ul><p><strong>type和isinstance</strong></p><ul><li><p>isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</p></li><li><p>isinstance() 方法的语法:</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>isinstance</span><span class=p>(</span><span class=nb>object</span><span class=p>,</span> <span class=n>classinfo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>参数</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    <span class=nb>object</span> <span class=o>--</span> <span class=n>实例对象</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    <span class=n>classinfo</span> <span class=o>--</span> <span class=n>可以是类名</span><span class=err>、</span><span class=n>基本类型或者有它们组成的元组</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=n>返回值</span><span class=err>：</span>
</span></span><span class=line><span class=cl>		<span class=n>如果对象的类型与参数二的类型</span><span class=err>（</span><span class=n>classinfo</span><span class=err>）</span><span class=n>相同则返回</span> <span class=kc>True</span><span class=err>，</span><span class=n>否则返回</span> <span class=kc>False</span><span class=err>。</span>
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>()</span> <span class=c1>#子类对象</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>isinstance</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=n>Son</span><span class=p>))</span> <span class=c1>#True</span>
</span></span><span class=line><span class=cl><span class=c1>#s这个对象是属于Son这个数据类型的。</span>
</span></span><span class=line><span class=cl><span class=c1>#python的数据类型：内置类型（8中），自定义类型（类）</span>
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>()</span> <span class=c1>#子类对象</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>isinstance</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=n>Father</span><span class=p>))</span> <span class=c1>#True</span>
</span></span><span class=line><span class=cl><span class=c1>#注意：子类对象可以被视为是一种父类类型</span>
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>()</span> <span class=c1>#子类对象</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>s</span><span class=p>))</span> <span class=c1>#&lt;class &#39;__main__.Son&#39;&gt;</span>
</span></span></code></pre></div></li></ul></li><li><p>type：返回对象的类型</p></li><li><p>isinstance() 与 type() 区别：</p><ul><li><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p></li><li><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p></li></ul></li></ul><h5 id=继承注意事项>继承注意事项<a hidden class=anchor aria-hidden=true href=#继承注意事项>#</a></h5><ul><li><p>实例方法中的self参数是一个相对的值？</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_xxx</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=n>Father</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=o>.</span><span class=n>get_xxx</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>#输出：&lt;__main__.Father object at 0x103536580&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#说明self表示的是父类类型的对象</span>
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_xxx</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Son</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>#是子类对象从父类中继承过来，self原本是写在父类的实例方法中的</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>get_xxx</span><span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=c1>#输出结果：&lt;__main__.Son object at 0x100e2a880&gt;</span>
</span></span></code></pre></div><ul><li>self所处的位置不同，表示的对象类型也是不同的！</li></ul></li></ul></li><li><p>类方法中的cls参数是一个相对的值？</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#类变量</span>
</span></span><span class=line><span class=cl>    <span class=n>class_var</span> <span class=o>=</span> <span class=s1>&#39;father var&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>getVar</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>Father</span><span class=o>.</span><span class=n>class_var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#类变量：和父类的类变量同名，子类同名的类变量就会覆盖从父类中继承过来的类变量</span>
</span></span><span class=line><span class=cl>    <span class=n>class_var</span> <span class=o>=</span> <span class=s1>&#39;son var&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Son</span><span class=o>.</span><span class=n>getVar</span><span class=p>()</span> <span class=c1>#输出：father var</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Father</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#类变量</span>
</span></span><span class=line><span class=cl>    <span class=n>class_var</span> <span class=o>=</span> <span class=s1>&#39;father var&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>getVar</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=bp>cls</span><span class=o>.</span><span class=n>class_var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Son</span><span class=p>(</span><span class=n>Father</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#类变量：和父类的类变量同名，子类同名的类变量就会覆盖从父类中继承过来的类变量</span>
</span></span><span class=line><span class=cl>    <span class=n>class_var</span> <span class=o>=</span> <span class=s1>&#39;son var&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Son</span><span class=o>.</span><span class=n>getVar</span><span class=p>()</span> <span class=c1>#输出：son var</span>
</span></span></code></pre></div><ul><li>注意：cls存在哪个类中，就表示的是当前的类。</li></ul></li></ul></li></ul><h4 id=类方法的作用>类方法的作用<a hidden class=anchor aria-hidden=true href=#类方法的作用>#</a></h4><p>思考：实例方法中的self参数的值是从哪来的？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Python 中的__new__和__init__的区别:
</span></span><span class=line><span class=cl>【同】
</span></span><span class=line><span class=cl>　　二者均是Python面向对象语言中的函数，__new__比较少用，__init__则用的比较多。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>【异】
</span></span><span class=line><span class=cl>		__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象。
</span></span><span class=line><span class=cl>		__init__是在对象创建好之后被调用的，init给对象的实例变量赋值，说明得事先存在实例变量，实例变量属于对象，实例变量存在则对象肯定也已经存在了。所以说对象存在了，则实例变量存在，实例变量存在则才可使用/调用init给实例变量赋值。
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>也就是： __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。
</span></span></code></pre></div><h5 id=类方法-1>类方法<a hidden class=anchor aria-hidden=true href=#类方法-1>#</a></h5><ul><li><p>如下场景：</p><p>假设我有一个学生类和一个班级类，想要实现的功能为：
学生类继承自班级类，每实例化一个学生对象，班级人数都能增加；
最后，我想定义一些学生，获得班级中的总人数。</p><ul><li>要求：<ul><li>必须通过班级类获取所有的学生对象的个数</li><li>不能创建班级对象，只能创建学生对象</li></ul></li><li>思路：<ul><li>需要在班级类中定义一个变量，让该变量记录学生的人数（每创建好一个学生对象则让班级类中的该变量进行加1操作），那么该变量如何创建（类变量or实例变量）？<ul><li>应该创建类变量：上述要求明确指明了，不可以创建班级对象，因此无法访问实例变量，所以应该创建一个类变量。</li></ul></li><li>如果班级类中有一个类变量，该类变量记录学生的个数，需要给该类变量提供一个访问的接口，该接口应该使用类方法getNum来实现。类方法可以直接被班级类名访问。</li><li>当每创建好一个学生对象，如何同步使得班级类中的类变量num进行加一操作呢？<ul><li>在班级类中提供一个类方法addNum，该类方法可以给num类变量进行加一操作。该方法必须保证，当创建好一个学生对象的时候被调用一次。</li><li>如何保证每创建好一个学生对象让addNum这个类方法调用一次呢？<ul><li>需要在班级类中重写new方法（该new方法是可以继承给学生这个子类）,该new方法可以继承给Student子类，因此每创建一个子类对象，就会调用一次new方法，则在new方法中就可以执行给num类变量进行加一操作。</li></ul></li></ul></li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>ClassRoom</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1>#记录学生对象的个数</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#类方法是用来显示计数器num的数值</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>getNum</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=bp>cls</span><span class=o>.</span><span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>#是用来给num进行加一操作，该方法必须保证，当创建好一个学生对象的时候被调用一次</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>addNum</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>cls</span><span class=o>.</span><span class=n>num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=c1>#new最终是可以被继承给Student这个子类</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>ClassRoom</span><span class=o>.</span><span class=n>addNum</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>(</span><span class=n>ClassRoom</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;zhangsan&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s3</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;wangwu&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s4</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;bobo&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ClassRoom</span><span class=o>.</span><span class=n>getNum</span><span class=p>()</span>
</span></span></code></pre></div></li></ul><h4 id=成员保护和访问限制>成员保护和访问限制<a hidden class=anchor aria-hidden=true href=#成员保护和访问限制>#</a></h4><p>在类的内部，有各种变量和方法。这些数据成员，可以在类的外部通过实例或者类名进行调用，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>study</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;正在学习！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>study</span><span class=p>()</span>
</span></span></code></pre></div><p>上面的调用方式是我们大多数情况下都需要的，但是往往我们也不希望所有的变量和方法能被外部访问，需要针对性地保护某些成员，限制对这些成员的访问。这样的程序才是健壮、可靠的，也符合业务的逻辑。</p><p>在Python中，如果要让内部成员不被外部访问，可以<strong>在成员的名字前加上两个下划线__，这个成员就变成了一个私有成员（private）</strong>。私有成员只能在类的内部访问，外部无法访问。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#name属性就变成了私有属性</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>__name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>study</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#可以访问私有成员属性</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;正在学习！学习的人员是:&#39;</span><span class=p>,</span><span class=bp>self</span><span class=o>.</span><span class=n>__name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=s1>&#39;lisi&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>study</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>__name</span><span class=p>)</span> <span class=c1>#无法访问私有成员</span>
</span></span></code></pre></div><ul><li><p>思考：私有成员是否可以被子类继承？</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>p</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#私有成员</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>__p</span> <span class=o>=</span> <span class=n>p</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span><span class=p>(</span><span class=n>Person</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_p</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>__p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Student</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>get_p</span><span class=p>())</span> <span class=c1>#无法访问私有成员</span>
</span></span><span class=line><span class=cl><span class=c1>#程序执行会报错！</span>
</span></span></code></pre></div><ul><li>注意：私有成员是无法被继承的。</li></ul></li></ul><p>那么，以双下划线开头的数据成员是不是一定就无法从外部访问呢？其实也不是！本质上，从内部机制原理讲，外部不能直接访问<code>__age</code>是因为Python解释器对外把<code>__age</code>变量改成了<code>_People__age</code>，也就是<code>_类名__age</code>（类名前是一个下划线）。因此，投机取巧的话，你可以通过<code>_ People__age</code>在类的外部访问<code>__age</code>变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>p</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#私有成员</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>__p</span> <span class=o>=</span> <span class=n>p</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>Person</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>_Person__p</span><span class=p>)</span> <span class=c1>#无法访问私有成员</span>
</span></span></code></pre></div><p>也就是说：Python的私有成员和访问限制机制是“假”的，没有从语法层面彻底限制对私有成员的访问。这一点和常量的尴尬地位很相似。</p><h4 id=reflect反射>reflect反射<a hidden class=anchor aria-hidden=true href=#reflect反射>#</a></h4><p>首先，我们要区分两个概念——“标识名”和“字符串”。两者字面上看起来一样，却是两种东西，比如下面的func函数和字符串“func”：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=s2>&#34;func()&#34;</span> <span class=c1>#字符串，不是函数调用</span>
</span></span></code></pre></div><p>前者是函数func的函数名，后者只是一个叫“func”的字符串，两者是不同的事物。我们可以用func()的方式调用函数func，但我们不能用"func&rdquo;()的方式调用函数。说白了就是，不能通过字符串来调用名字看起来相同的函数！</p><p><strong>实例分析</strong></p><p>考虑有这么一个场景：需要根据用户输入url的不同，调用不同的函数，实现不同的操作，也就是一个WEB框架的url路由功能。</p><p>首先，有一个commons.py文件，它里面有几个函数，分别用于展示不同的页面。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># commons.py</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>login</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;这是登录页面！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>logout</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;这是退出页面&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>home</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;这是主页面&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>其次，有一个visit.py文件，作为程序入口，接收用户输入，并根据输入展示相应的页面</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># visit.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>commons</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>run</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>inp</span> <span class=o>=</span> <span class=nb>input</span><span class=p>(</span><span class=s1>&#39;请输入您要访问的网址:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>inp</span> <span class=o>==</span> <span class=s1>&#39;login&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>commons</span><span class=o>.</span><span class=n>login</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>inp</span> <span class=o>==</span> <span class=s1>&#39;logout&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>commons</span><span class=o>.</span><span class=n>logout</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>inp</span> <span class=o>==</span> <span class=s1>&#39;home&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>commons</span><span class=o>.</span><span class=n>home</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;404&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>run</span><span class=p>()</span>
</span></span></code></pre></div><p>运行visit.py，输入home，页面结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>请输入您想访问页面的url：  home
</span></span><span class=line><span class=cl>这是网站主页面！
</span></span></code></pre></div><p>这就实现了一个简单的url路由功能，根据不同的url，执行不同的函数，获得不同的页面。</p><p>然而，让我们思考一个问题，如果commons文件里有成百上千个函数呢(这很常见)？难道在visit模块里写上成百上千个elif？显然这是不可能的！那么怎么办？</p><p>仔细观察visit.py中的代码，会发现用户输入的url字符串和相应调用的函数名好像！</p><p>如果能用这个字符串直接调用函数就好了！但是，前面已经说了字符串是不能用来调用函数的。为了解决这个问题，Python提供了反射机制，帮助我们实现这一想法!</p><p>现在将前面的visit.py修改一下，代码如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># visit.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>commons</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>run</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>inp</span> <span class=o>=</span> <span class=nb>input</span><span class=p>(</span><span class=s1>&#39;请输入您要访问的网址:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>#inp == &#34;login&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span> <span class=o>=</span> <span class=nb>getattr</span><span class=p>(</span><span class=n>commons</span><span class=p>,</span><span class=n>inp</span><span class=p>)</span> <span class=c1>#func == login</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>()</span> <span class=c1>#login()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>run</span><span class=p>()</span>
</span></span></code></pre></div><p><code>func = getattr(commons,inp)</code>语句是关键，通过getattr()函数，从commons模块里，查找到和inp字符串“外形”相同的函数名，并将其返回，然后赋值给func变量。变量func此时就指向那个函数，func()就可以调用该函数。</p><p><strong>getattr()函数的使用方法：接收2个参数，前面的是一个类或者模块，后面的是一个字符串，注意了！是个字符串！</strong></p><p>这个过程就相当于把一个字符串变成一个函数名的过程。这是一个动态访问的过程，一切都不写死，全部根据用户输入来变化。</p><p><strong>瑕疵</strong>：前面的代码还有个小瑕疵，那就是如果用户输入一个非法的url，比如jpg，由于在commons里没有同名的函数，肯定会产生运行错误</p><p>那怎么办呢？python提供了一个hasattr()的内置函数，用法和getattr()基本类似，它可以判断commons中是否具有某个成员，返回True或False。现在将代码修改一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># visit.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>commons</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>run</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>inp</span> <span class=o>=</span> <span class=nb>input</span><span class=p>(</span><span class=s1>&#39;请输入您要访问的网址:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>hasattr</span><span class=p>(</span><span class=n>commons</span><span class=p>,</span><span class=n>inp</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>func</span> <span class=o>=</span> <span class=nb>getattr</span><span class=p>(</span><span class=n>commons</span><span class=p>,</span><span class=n>inp</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>func</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;404&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>run</span><span class=p>()</span>
</span></span></code></pre></div><p>这下就没有问题了！通过hasattr()的判断，可以防止非法输入导致的错误，并将其统一定位到错误页面。</p><h4 id=单例模式>单例模式<a hidden class=anchor aria-hidden=true href=#单例模式>#</a></h4><ul><li><p>单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于被外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p></li><li><p>单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p></li></ul><p><strong>应用场景</strong></p><p>比如,某个服务器的配置信息存在在一个文件中,客户端通过AppConfig类来读取配置文件的信息.如果程序的运行的过程中,很多地方都会用到配置文件信息,则就需要创建很多的AppConfig实例,这样就导致内存中有很多AppConfig对象的实例,造成资源的浪费.其实这个时候AppConfig我们希望它只有一份,就可以使用单例模式.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Singleton</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=nb>hasattr</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span><span class=s1>&#39;instance&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>Singleton</span><span class=o>.</span><span class=n>instance</span> <span class=o>=</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Singleton</span><span class=o>.</span><span class=n>instance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=n>Singleton</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>Singleton</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>id</span><span class=p>(</span><span class=n>s1</span><span class=p>),</span><span class=nb>id</span><span class=p>(</span><span class=n>s2</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=链表>链表<a hidden class=anchor aria-hidden=true href=#链表>#</a></h3><ul><li><p>链表就是用来修正/优化列表存在的某一个弊端的。</p></li><li><p>列表存在的弊端：</p><ul><li>列表开启的内存空间是连续的,导致如果向列表中增加或者删除元素，需要将增加或者删除元素后面的所有元素批量移动，该行为会严重影响列表元素添加或者删除的性能。</li><li>列表是不适合进行高频的元素添加和删除操作的。</li></ul></li><li><p>分析：</p><ul><li>链表如何进行列表弊端的优化？<ul><li>优化核心在于，元素的内存空间不可以连续开辟，因此链表的内存空间不是连续开辟，则意味着链表就丧失了索引的机制。</li></ul></li><li>链表的作用：<ul><li>如果需求需要进行高频的元素增加和删除，则使用链表最合适。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>item</span> <span class=o>=</span> <span class=n>item</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Link</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#head指向第一个节点</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>addHead</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>item</span><span class=p>):</span> <span class=c1>#向链表头部插入新的节点</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>travel</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span> <span class=c1>#遍历链表中节点的item</span>
</span></span><span class=line><span class=cl><span class=c1>#         print(self.head.item)</span>
</span></span><span class=line><span class=cl><span class=c1>#         print(self.head.next.item)</span>
</span></span><span class=line><span class=cl><span class=c1>#         print(self.head.next.next.item)</span>
</span></span><span class=line><span class=cl><span class=c1>#         print(self.head.next.next.next.item)</span>
</span></span><span class=line><span class=cl><span class=c1>#         print(self.head.next.next.next.next.item)</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>cur</span> <span class=o>!=</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>cur</span><span class=o>.</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>isEmpty</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#判定链表是否为空，空返回True，否则返回False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>==</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>length</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1>#返回链表中节点的个数</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1>#记录节点的个数</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>cur</span> <span class=o>!=</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>    <span class=c1>#向链表尾部添加新的节点</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>append</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>isEmpty</span><span class=p>():</span><span class=c1>#如果链表为空</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span><span class=c1>#链表为非空的情况</span>
</span></span><span class=line><span class=cl>            <span class=n>pre</span> <span class=o>=</span> <span class=kc>None</span> <span class=c1>#pre要指向cur前面的一个节点</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>cur</span> <span class=o>!=</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>pre</span> <span class=o>=</span> <span class=n>cur</span>
</span></span><span class=line><span class=cl>                <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>            <span class=c1>#循环结束后cur指向了None而pre指向了最后一个节点</span>
</span></span><span class=line><span class=cl>            <span class=n>pre</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#将新的节点插入到pos表示的位置中</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insertNode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>item</span><span class=p>,</span><span class=n>pos</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>pos</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>addHead</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>pos</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>pre</span> <span class=o>=</span> <span class=n>cur</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>cur</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#从链表中删除item表示的节点</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>removeNode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span><span class=o>.</span><span class=n>item</span> <span class=o>==</span> <span class=n>item</span><span class=p>:</span><span class=c1>#删除的是第一个节点</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>cur</span> <span class=o>!=</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>cur</span><span class=o>.</span><span class=n>item</span> <span class=o>==</span> <span class=n>item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1>#条件成立则cur就是我们要删除的节点</span>
</span></span><span class=line><span class=cl>                <span class=n>pre</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>pre</span> <span class=o>=</span> <span class=n>cur</span>
</span></span><span class=line><span class=cl>                <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>link</span> <span class=o>=</span> <span class=n>Link</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>addHead</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>addHead</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>addHead</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>addHead</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>addHead</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>removeNode</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>link</span><span class=o>.</span><span class=n>travel</span><span class=p>()</span>
</span></span></code></pre></div></li></ul></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://canw0916.github.io/img/wxPay.jpg alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://canw0916.github.io/img/aliPay.jpg alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://canw0916.github.io/en/posts/tech/python%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/><span class=title>« 上一页</span><br><span>Python高级语法</span>
</a><a class=next href=https://canw0916.github.io/en/posts/tech/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/><span class=title>下一页 »</span><br><span>模块与包</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://utteranc.es/client.js repo=canw0916/utterances_comments issue-term=title theme=photon-dark crossorigin=anonymous async></script></div></article></main><script async src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
2023-2023
<a href=https://canw0916.github.io/en/ style=color:#939393>Felix's Blog</a>
All Rights Reserved
</span><a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;
<span><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style=display:inline-block;text-decoration:none;height:20px;color:#939393><img src style="float:left;margin:0 5px 0 0">
</a></span><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>总访客数: <span id=busuanzi_value_site_uv></span>
总访问量: <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>400||document.documentElement.scrollTop>400?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="📄复制";function s(){t.innerText="👌🏻已复制!",setTimeout(()=>{t.innerText="📄复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`
————————————————
版权声明：本文为「Felix's Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;navigator.clipboard.writeText(t),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild===n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName==="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%")})</script></body></html>