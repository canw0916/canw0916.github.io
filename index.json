[{"categories":null,"content":"火山's friends","date":"2023-01-30","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Base info - nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note ","date":"2023-01-30","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder Notice If you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only)  Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2023-01-30","objectID":"/friends/:2:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["编程"],"content":" this is test! This is a right-aligned paragraph. FixIt Theme https://github.com/hugo-fixit/FixIt 或者 FixIt Theme https://github.com/hugo-fixit/FixIt Wavelength Wavelength.mp3 /music/Wavelength.mp3 This is a tip 一个 技巧 横幅 或者 title 内容 ","date":"2023-01-29","objectID":"/posts/2023/01/test/:0:0","tags":["其他"],"title":"Test","uri":"/posts/2023/01/test/"},{"categories":["语言"],"content":"时下最in的话对应的英语口语表达，无论是日常交谈还是网友聊天中出现频率都可以称得上一级高的句子们，对应上英语了，潮人们说话当然也要潮咯。 我了个去：holy crap； 额滴个神啊：oh my god； 我的天哪：jesus christ； 太牛b了：freaking awesome； 神马东西：what the hell； 傻了吧唧：stupid ass； 闭嘴吧你：shut the fuck up； 臭不要脸：you’ve got such a nerve； 胡说八道：totally nonsense； 我看行：it will work 从口头语看个性，口头语可以反映出一个人的性格。由此，你可以加深对说话者的了解。绝对经典，选两句作为你的个性口头禅吧。 thousand times no! 绝对办不到！ easy does it. 慢慢来。 don’t push me. 别逼我。 have a good of it.玩的很高兴。 what is the fuss？吵什么？ still up？还没睡呀？ it doesn’t make any differences. 没关系。 don’t let me down. 别让我失望。 god works. 上帝的安排。 don’t take ill of me. 别生我气 does it serve your purpose？对你有用吗？ don’t flatter me. 过奖了。 big mouth! 多嘴驴！ sure thing! 当然！ don’t over do it. 别太过分了。 can you dig it？你搞明白了吗？ you want a bet？你想打赌吗？ what if i go for you？我替你去怎么样who wants？谁稀罕？ follow my nose. 凭直觉做某事 作者：比格尔英语 链接：https://www.jianshu.com/p/2c4f11f8b9b1 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2023-01-29","objectID":"/posts/2023/01/%E7%BD%91%E7%BB%9C%E6%B5%81%E8%A1%8C%E5%8F%A3%E5%A4%B4%E7%A6%85%E5%AF%B9%E5%BA%94%E7%9A%84%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%E8%A1%A8%E8%BE%BE/:0:0","tags":["英语","口语"],"title":"网络流行口头禅对应的英语口语表达!","uri":"/posts/2023/01/%E7%BD%91%E7%BB%9C%E6%B5%81%E8%A1%8C%E5%8F%A3%E5%A4%B4%E7%A6%85%E5%AF%B9%E5%BA%94%E7%9A%84%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%E8%A1%A8%E8%BE%BE/"},{"categories":["语言"],"content":" “格”在德语学习的过程中，地位十分重要。或者说，“格”应当被视为德语学习的灵魂所在。要精准地掌握德语，就必须先弄清楚“格”的不同用法。首先，我们得定义一下“格”，也就是什么是“格”。我的理解是，德语中的“格”代表了名词、代词和一些相关词类 ( 比如形容词等 ) 在句子中的功能，或是一种具体的搭配要求关系 ( 比如介词和动词等 )。我们明确了一点，“格”通常代表了一种功能，因此我们就从这个角度切入来粗略地为大家总结和剖析一下德语的“格”。 现代德语中一共有4个格：第一、二、三、四格，对应的德语名称是Nominativ、Genitiv、Dativ、Akkusativ，简写分别就是NGDA。我们今天先来看看第一格Nominativ。 ","date":"2023-01-29","objectID":"/posts/2023/01/%E5%BE%B7%E8%AF%AD%E5%B9%B2%E8%B4%A7-%E5%BE%B7%E8%AF%AD%E7%AC%AC%E4%B8%80%E6%A0%BC%E6%80%BB%E7%BB%93/:0:0","tags":["德语","第一格","语法"],"title":"德语干货 | 德语第一格总结","uri":"/posts/2023/01/%E5%BE%B7%E8%AF%AD%E5%B9%B2%E8%B4%A7-%E5%BE%B7%E8%AF%AD%E7%AC%AC%E4%B8%80%E6%A0%BC%E6%80%BB%E7%BB%93/"},{"categories":["语言"],"content":"Nominativ 第一格 应该说第一格属于德语中最简单的一种格了，那么刚才提到功能的问题，第一格有哪些功能呢？ ( 1 ) 第一格充当句子的主语，这是它最主要的功能。 比如，举一个很简单的例子，大家每天学德语在背的名词词性der/das/die，其实它就是最原始的第一格。也就是说，你把一个名词的词性记住了，就记住了它的第一格。 比如：der Tisch 桌子。那么桌子的第一格定冠词就是der，以后其他的格变化都是从这个der演变而来，这也就是我们经常强调的，德语学习第一关就是记住大量名词的词性，这是德语学习的源头。大家想想，如果你把Tisch记成了die Tisch，那么后面就会乱套了。因此第一格从理解上可以说很简单，但是核心问题是对我们来说记住大量名词词性本身就不简单。只有在不断总结规律中，不断花功夫。 言归正传，我们拿Tisch举一个例子，很简单：Der Tisch ist neu. 这个句子里Tisch作主语，因此就是第一格。再看第二个句子：Der Tisch steht an der Wand. 桌子靠在墙边。这句话也很简单，Tisch是主语，没有任何悬念。再看：An der Wand steht der Tisch. 换了个位置，很多同学就会误认为Tisch变成其他格了。其实不然，后面这句中Tisch仍然是主语，因为不管它怎么换语序主语仍然是Tisch，因此始终是第一格。这里要给大家展示的就是德语中主语不一定就是句子的第一个单词，所以我们要是始终以功能为核心出发点，而不能看位置，所以请牢记：看功能，不单看位置。这个很重要很重要！ ( 2 ) 第一格充当句子的表语。 其实，简单的讲，表语就是主语的另一面，跟在系动词之后的就叫表语。比如，德语中的最著名系动词是sein，它相当于英语中的be，那么在它之后我们就要用第一格。 例如：Das ist mein Tisch. 这里面就是第一格，那么很多同学问，这个第一格体现在哪里呢？其实，就体现在了这个物主代词mein身上。因为Tisch是der，所以用mein；又因为这里是第一格，所以还是用mein，不用变化。德语中类似与sein的系动词还有werden ( 成为 )和 bleiben ( 仍然 )。这三个动词我们可以把他们称为“一格动词”，也就是说他们后面跟第一格，比如： Das ist meine Katze. 这是我的猫。 Er wird Lehrer. 他成为一名老师。 Sie bleibt eine Lehrerin. 她依旧是一位老师。 ( 3 ) 人称代词的第一格要背诵出来 这个基本常识大家一定要知道，德语中一共有9大人称代词： ich 我 du 你 er 他 or 某个阳性名词单数 es 某个中性名词单数 sie 她 or 某个阴性名词单数 wir 我们 ihr 你们 sie 他们；她们；它们 Sie 您；您们 关键在于er/es/sie三个，这三个称为第三人称单数，简称为“三单”。这里面，er除了表示一个男性以外，还可以指代一个阳性名词单数，也就是说，er不仅可以指人，也可以代物。 这是为什么呢？很好理解，因为德语名词有词性，那么阳性的der就要用er来代替，大家仔细看看，der和er是不是超级相似，所以不用背，很好记忆。 比如：Der Tisch ist neu. Er ist auch billig. ​ 这张桌子是新的，它也便宜。 这时候人称代词要跟着词性走，绝对不是跟着感觉走。桌子是阳性的，那当然就用er毫无悬念，如果去用es或者sie就词性错乱了。 es也是同样道理 比如： Das Mdchen ist sehr nett. Es ist drei Jahre alt. 这个小姑娘很可爱，她3岁了。 请大家务必注意，德语中小姑娘这个词是中性的。 再比如：Ich habe eine Maus. Sie ist klein. ​ 我有一只老鼠，它很小。 因为老鼠是die Maus，所以用sie。请记住：要跟着词性走，所以大家现在应该感觉到了，词性错了，后面步步都有可能错了。 der - er das - es die - sie 请注意这个对应关系和词尾，仔细看！ ( 4 ) 记住了名词词性，也就等于记住了一大串第一格形式。 此话怎样，因为后面很多内容都是从der/das/die的基本形式演变而来。比如，welcher/welches/welche，就是德语版的which，大家仔细看词尾，同原来保持高度相似；在比如：dieser/dieses/diese，就是德语版的these，也是高度相似。我们可以将他们放在一起。 der - welcher - dieser ( 词尾都是er ) das - welches - dieses ( 词尾都是es ) die - welche - diese ( 词尾都是e ) 作者：嘟嘟小语种小柒老师 链接：https://www.jianshu.com/p/f120399a1c83 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2023-01-29","objectID":"/posts/2023/01/%E5%BE%B7%E8%AF%AD%E5%B9%B2%E8%B4%A7-%E5%BE%B7%E8%AF%AD%E7%AC%AC%E4%B8%80%E6%A0%BC%E6%80%BB%E7%BB%93/:0:1","tags":["德语","第一格","语法"],"title":"德语干货 | 德语第一格总结","uri":"/posts/2023/01/%E5%BE%B7%E8%AF%AD%E5%B9%B2%E8%B4%A7-%E5%BE%B7%E8%AF%AD%E7%AC%AC%E4%B8%80%E6%A0%BC%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"C# 特殊集合 C#中的特殊集合主要有： 不可变的集合 并发的集合 位数组合位矢量 可观察的集合 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/:1:0","tags":["C#","特殊集合"],"title":"C#基础提升系列——C#特殊集合","uri":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"不变的集合 如果对象可以改变其状态，就很难在多个同时运行的任务中使用。这些集合必须同步。如果对象不能改变其状态，就很容易在多个线程中使用。不能改变的对象称为不变的对象；不能改变的集合称为不变的集合。 为了使用不可变的集合，需要添加NuGget包System.Collections.Immutalbe，关于此命名空间下的详细介绍，请点击此处进行查看，本文只对其进行简单的示例说明。 ImmutableArray 该类提供创建不可变数组的方法。例如： ImmutableArray\u003cstring\u003e a1= ImmutableArray.Create\u003cstring\u003e(); 上述语句用于创建一个string类型的不可变数组，注意，上述虽然都是ImmutableArray，但是却是两种不同的类型：非泛型类ImmutableArray调用Create()静态方法返回泛型ImmutableArray结构。其中，Create方法被重载，这个方法的其他变体允许传送任意数量的元素。 可以使用Add()方法添加新的元素，Add()方法不会改变不变集合本身，而是返回一个新的不变集合。 ImmutableArray\u003cstring\u003e a2= a1.Add(\"java\"); 上述语句执行之后，a1仍然是一个空集合，a2是包含一个元素的不变集合。可以链式的重复调用Add()方法，最终返回一个集合： ImmutableArray\u003cstring\u003e a3 = a2.Add(\"c#\").Add(\"python\").Add(\"php\"); 在使用不变数组的每个阶段，都没有复制完整的集合。相反，不变类型使用了共享状态，仅在需要时复制集合。 通常，先填充集合，再将它变成不变的数组会更高效。当需要进行一些处理时，可以再次使用可变的集合。 ImmutableList 表示不可变列表，它是可由索引访问的强类型对象列表。 示例说明，先定义一个简单的类： internal class Account { public string Name { get; } public decimal Amount { get; } public Account(string name, decimal amount) { this.Name = name; this.Amount = amount; } } 接着创建List\u003cAccount\u003e集合，使用ToImmutableList方法将其转换为不变的集合。 var accounts = new List\u003cAccount\u003e { new Account(\"图书\",424.2m), new Account(\"文具\",1243.5m), new Account(\"篮球\",243.3m) }; //将List转换为不可变集合 ImmutableList\u003cAccount\u003e immutableAccounts = accounts.ToImmutableList(); //输出每一项的内容 immutableAccounts.ForEach(a =\u003e Console.WriteLine(a.Name + \"--\" + a.Amount)); 如果需要更改不变集合的内容，可以使用不变集合的Add、AddRange、Remove、RemoveAt、RemoveRange、Replace以及Sort等方法，这些方法都不是直接改变了原来的不变集合，而是返回一个新的不可变集合。虽然上述这些方法可以创建新的不变集合，但是如果对集合频繁的进行多次修改和删除元素，这就不是非常高效。可以使用ImmutableList\u003cT\u003e的ToBuilder() 方法，创建一个构建器，该方法返回一个可以改变的集合。例如： var accounts = new List\u003cAccount\u003e { new Account(\"图书\",424.2m), new Account(\"文具\",1243.5m), new Account(\"篮球\",243.3m) }; //先得到不可变集合 ImmutableList\u003cAccount\u003e immutableAccounts = accounts.ToImmutableList(); //调用ToBuilder()方法将不可变集合创建为可变集合 ImmutableList\u003cAccount\u003e.Builder builder = immutableAccounts.ToBuilder(); for (int i = 0; i \u003c builder.Count; i++) { Account a = builder[i]; if (a.Amount \u003e 1000) { builder.Remove(a); } } //将新创建的可变集合调用ToImmutable()方法得到不可变集合 ImmutableList\u003cAccount\u003e overdrawnAccounts = builder.ToImmutable(); overdrawnAccounts.ForEach(b =\u003e Console.WriteLine(b.Name + \"=\" + b.Amount)); 除了ImmutableArray和ImmutableList之外，该命名空间下还提供了其他一些不变的集合类型。如： ImmutableArray ：ImmutableArray\u003cT\u003e是一个结构，它在内部使用数组类型，当不允许更改底层类型，这个结构实现了接口IImmutableList\u003cT\u003e。 ImmutableList：ImmutableList\u003cT\u003e在内部使用一个二叉树来映射对象，以实现接口IImmutableList\u003cT\u003e。 ImmutableQueue ：ImmutableQueue\u003cT\u003e 实现了接口IImmutableQueue\u003cT\u003e ，允许使用Enqueue、Dequeue和Peek以先进先出的方式访问元素。 ImmutableStack ：ImmutableStack\u003cT\u003e 实现了接口IImmutableStack\u003cT\u003e，允许使用Push、Pop和Peek以先进后出的方式访问元素。 ImmutableDictionary ：ImmutableDictionary\u003cTKey,TValue\u003e 是一个键和值不可变的集合，其无序的键/值对元素实现了接口IImmutableDictionary\u003cTKey,TValue\u003e 。 ImmutableSortedDictionary ：ImmutableSortedDictionary\u003cTKey,TValue\u003e是一个不可变的排序字典。其实现了接口IImmutableDictionary\u003cTKey,TValue\u003e 。 ImmutableHashSet ：表示不可变的无序哈希集 ，实现了接口IImmutableSet\u003cT\u003e 。 ImmutableSortedSet ：表示不可变的有序集合，实现了接口IImmutableSet\u003cT\u003e 。 上述的这些不变的集合都实现了对应的接口，与正常集合相比，这些不变接口的最大区别是所有改变集合的方法都返回一个新的集合。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/:1:1","tags":["C#","特殊集合"],"title":"C#基础提升系列——C#特殊集合","uri":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"并发集合 在命名空间System.Collections.Concurrent 中，提供了几个线程安全的集合类，线程安全的集合可以防止多个线程以相互冲突的方式访问集合。下面列出了System.Collections.Concurrent命名空间中常用的类及其功能。 ConcurrentQueue :表示线程安全的先进先出（FIFO）集合。 这个集合类用一种免锁定的算法实现，使用在内部合并到一个链表中的32项数组。访问队列元素的方法有Enqueue(T) 、TryDequeue(T) 和TryPeek(T) 。这些方法的命名和前面的Queue\u003cT\u003e类的方法很像，只是给可能调用失败的方法加上了前缀Try。因为这个类实现了IProducerConsumerCollection\u003cT\u003e接口，所以TryAdd()和TryTake()方法仅调用Enqueue()和TryDequeue()方法。 ConcurrentStack ：表示线程安全的后进先出（LIFO）集合。 和ConcurrentQueue\u003cT\u003e类似，只是访问元素的方法不同。ConcurrentStack\u003cT\u003e类定义了Push(T) 、PushRange()、TryPeek(T) 、TryPop(T) 和TryPopRange(T[])方法。该类也实现了IProducerConsumerCollection\u003cT\u003e接口。 ConcurrentBag ：表示线程安全，无序的对象集合。 该类没有定义添加或提取项的任何顺序。这个类使用一个把线程映射到内部使用的数组上的概念，因此尝试减少锁定。访问元素的方法有Add(T) 、TryPeek(T) 和TryTake(T) 。该类也实现了IProducerConsumerCollection\u003cT\u003e 接口。 ConcurrentDictionary ：表示可以由多个线程同时访问的键/值对的线程安全集合。TryAdd(TKey, TValue) 、 TryGetValue(TKey, TValue) 、TryRemove(TKey, TValue) 和TryUpdate(TKey, TValue, TValue) 方法以非阻塞的方式访问成员。因为元素基于键和值，所以ConcurrentDictionary\u003cTKey,TValue\u003e 类没有实现IProducerConsumerCollection\u003cT\u003e 接口。 BlockingCollection ：为实现IProducerConsumerCollection 的线程安全集合提供阻塞和绑定功能。这个集合可以在添加或提取元素之前，会阻塞线程并一直等待。 BlockingCollection\u003cT\u003e集合提供了一个接口，以使用Add(T) 和Take() 方法来添加和删除元素。这些方法会阻塞线程，一直等到任务可以执行为止。Add()方法有一个重载版本，其中可以给该重载版本传递一个cancellationToken令牌，这个令牌允许取消被阻塞的调用。如果不希望线程无限期的等待下去，且不希望从外部取消调用，就可以使用TryAdd(T) 和TryTake(T) 方法，在这些方法中，也可以指定一个超时值，它表示在调用失败之前应阻塞线程和等待的最长时间。 上述类中，有的实现了IProducerConsumerCollection\u003cT\u003e接口，IProducerConsumerCollection\u003cT\u003e接口提供了TryAdd(T) 和TryTake(T) 方法。TryAdd()方法尝试给集合添加一项，返回布尔值；TryTake()方法尝试从集合中删除并返回一个项。 以ConcurrentXXX形式的集合是线程安全的，如果某个动作不适用于线程的当前状态，它们就返回false。在继续之前，总是需要确认添加或提取元素是否成功。不能相信集合 会完成任务。 BlockingCollection\u003cT\u003e是对实现了IProducerConsumerCollection\u003cT\u003e接口的任意类的修饰器 ，它默认使用ConcurrentQueue\u003cT\u003e类。还可以给构造函数传递任何其他实现了IProducerConsumerCollection\u003cT\u003e接口的类，例如，ConcurrentBag\u003cT\u003e和ConcurrentStack\u003cT\u003e。 下面将使用一个完整的示例说明并发集合的应用。该示例基于管道，即一个任务向一个集合类写入一些内容，同时另一个任务从该集合中读取内容。首先定义一个基本类： public class Info { public string Word { get; set; } public int Count { get; set; } public string Color { get; set; } public override string ToString() { return $\"Word:{Word},Count:{Count},Color:{Color}\"; } } 定义向控制台输出的类，使用同步来避免返回颜色错误的输出： public static class ColoredConsole { private static object syncOutput = new object(); public static void WriteLine(string message) { lock (syncOutput) { Console.WriteLine(message); } } public static void WriteLine(string message, string color) { lock (syncOutput) { Console.ForegroundColor = (ConsoleColor)Enum.Parse( typeof(ConsoleColor), color); Console.WriteLine(message); Console.ResetColor(); } } } 接着定义具体的管道实现，详细说明请参加代码中的注释： public static class PipeLineStages { public static Task ReadFilenamesAsync(string path, BlockingCollection\u003cstring\u003e output) { //第一个阶段 return Task.Factory.StartNew(() =\u003e { //读取文件名，并把它们添加到队列中 foreach (string filename in Directory.EnumerateFiles( path, \"*.cs\", SearchOption.AllDirectories)) { //添加到BlockingCollection\u003cT\u003e中 output.Add(filename); ColoredConsole.WriteLine($\"stage 1: added {filename}\"); } //通知所有读取器不应再等待集合中的任何额外项 output.CompleteAdding(); //该方法必不可少 },TaskCreationOptions.LongRunning); } public static async Task LoadContentAsync(BlockingCollection\u003cstring\u003e input, BlockingCollection\u003cstring\u003e output) { //第二个阶段：从队列中读取文件名并加载它们的内容，并把内容写入到另一个队列 //如果不调用GetConsumingEnumerable()方法，而是直接迭代集合，将不会迭代之后添加的项 foreach (var filename in input.GetConsumingEnumerable()) { using (FileStream stream = File.OpenRead(filename)) { var reader = new StreamReader(stream); string line = null; while ((line = await reader.ReadLineAsync()) != null) { output.Add(line); ColoredConsole.WriteLine(\"stage 2: added \" + line); } } } output.CompleteAdding(); } public static Task ProcessContentAsync(BlockingCollection\u003cstring\u003e input, ConcurrentDictionary\u003cstring, int\u003e output) { return Task.Factory.StartNew(() =\u003e { //第三个阶段：读取第二个阶段中写入内容的队列，并将结果写入到一个字典中 foreach (var line in input.GetConsumingEnumerable()) { string[] words = line?.Split(' ', ';', '\\t', '{', '}', '(', ')', ':', ',', '\"'); if (words == null) continue; foreach (var word in words?.Where(w =\u003e !string.IsNullOrEmpty(w))) { //如果键没有添","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/:1:2","tags":["C#","特殊集合"],"title":"C#基础提升系列——C#特殊集合","uri":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"处理位的集合 如果需要处理的数字有许多位，可以使用 BitArray类和BitVector32结构。这两种类型最重要的区别是：BitArray类可以重新设置大小，如果事先不知道需要的位数，可以使用BitArray类，它可以包含非常多的位。BitVector32结构是基于栈的，因此比较快。BitVector32结构仅包含32位，它们存储在一个整数中。 BitArray类 BitArray 类是一个引用类型，当它的构造函数传入的是int[]时，每一个int类型的整数都将使用32个连续位进行表示。 public static void Run() { //创建一个包含8位的数组，其索引是0~7 var bits1 = new BitArray(8); //把8位都设置为true bits1.SetAll(true); //把对应于1的位设置为false bits1.Set(1, false); bits1[5] = false; bits1[7] = false; DisplayBits(bits1); Console.WriteLine(); //Not()方法对所有的位取反 bits1.Not(); DisplayBits(bits1); Console.WriteLine(); var bits2 = new BitArray(bits1); bits2[0] = true; bits2[1] = false; bits2[4] = true; DisplayBits(bits1); Console.Write (\" Or \"); DisplayBits(bits2); Console.Write (\" = \"); //比较两个数组上的同一个位置上的位，如果有一个为true，结果就为true bits1.Or(bits2); DisplayBits(bits1); Console.WriteLine(); DisplayBits(bits2); Console.Write(\" and \"); DisplayBits(bits1); Console.Write (\" = \" ); //如果两个数组上的同一个位置的位都为true，结果才为true bits2.And(bits1); DisplayBits(bits2); Console.WriteLine(); DisplayBits(bits1); Console.Write (\" xor \"); DisplayBits(bits2); //比较两个数组上的同一个位置上的位，只有一个（不能是二个）设置为1，结果才是1 bits1.Xor(bits2); Console.Write(\" = \"); DisplayBits(bits1); Console.WriteLine(); } public static void DisplayBits(BitArray bits) { foreach (bool bit in bits) { Console.Write(bit ? 1 : 0); } } BitVector32结构 如果事先知道需要的位数，留可以使用BitVector32 结构代替BitArray类。BitVector32结构效率较高，因为它是一个值类型，在整数栈上存储位。一个整数可以存储32位，如果需要更多的位，就可以使用多个BitVector32值或BitArray类。BitArray类可以根据需要增大，但BitVector32结构不能。 BitVector32结构中常用成员： Data ：以整数形式获取BitVector32的值。Data属性把BitVector32结构中的数据返回为整数。 Item[]：BitVector32的值可以使用索引器设置，索引器是重载的——可以使用掩码或BitVector32.Section类型的片段来获取和设置值。 CreateMask() ：该方法有多个重载版本，它是以静态方法，用于为访问BitVector32结构中的特定位创建掩码。 CreateSection(Int16, BitVector32+Section) ：该方法有多个重载版本，也是一个静态方法，用于创建32位中的几个片段。 public static void Run() { //使用默认构造函数创建一个BitVactor32结构，默认每一位都是false。 var bits1 = new BitVector32(); //调用CreateMask()方法创建用来访问第一位的一个掩码，bit1被设置为1 int bit1 = BitVector32.CreateMask(); //再次调用CreateMask()方法，并将一个掩码作为参数进行传递，返回第二位掩码 int bit2 = BitVector32.CreateMask(bit1); int bit3 = BitVector32.CreateMask(bit2); int bit4 = BitVector32.CreateMask(bit3); int bit5 = BitVector32.CreateMask(bit4); //使用掩码和索引器访问位矢量中的位，并设置值 bits1[bit1] = true; bits1[bit2] = false; bits1[bit3] = true; bits1[bit4] = true; bits1[bit5] = true; Console.WriteLine(bits1); bits1[0xabcdef] = true; Console.WriteLine(bits1); int received = 0x79abcdef; //直接传入十六进制数来创建掩码 BitVector32 bits2 = new BitVector32(received); Console.WriteLine(bits2); //分割片段 BitVector32.Section sectionA = BitVector32.CreateSection(0xfff); BitVector32.Section sectionB = BitVector32.CreateSection(0xff, sectionA); BitVector32.Section sectionC = BitVector32.CreateSection(0xf, sectionB); BitVector32.Section sectionD = BitVector32.CreateSection(0x7, sectionC); BitVector32.Section sectionE = BitVector32.CreateSection(0x7, sectionD); BitVector32.Section sectionF = BitVector32.CreateSection(0x3, sectionE); Console.WriteLine(\"Section A:\" + IntToBinaryString(bits2[sectionA], true)); Console.WriteLine(\"Section B:\" + IntToBinaryString(bits2[sectionB], true)); Console.WriteLine(\"Section C:\" + IntToBinaryString(bits2[sectionC], true)); Console.WriteLine(\"Section D:\" + IntToBinaryString(bits2[sectionD], true)); Console.WriteLine(\"Section E:\" + IntToBinaryString(bits2[sectionE], true)); Console.WriteLine(\"Section F:\" + IntToBinaryString(bits2[sectionF], true)); } public static string IntToBinaryString(int bits, bool removeTrailingZero) { var sb = new StringBuilder(32); for (int i = 0; i \u003c 32; i++) { if ((bits \u0026 0x80000000) != 0) { sb.Append(\"1\"); } else { sb.Append(\"0\"); } bits = bits \u003c\u003c 1; } string s = sb.ToString(); if (removeTrailingZero) { return s.TrimStart('0'); } else { return s; } } ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/:1:3","tags":["C#","特殊集合"],"title":"C#基础提升系列——C#特殊集合","uri":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"可观察的集合 使用ObservableCollection 集合类，可以在集合元素进行添加、删除、移动、修改等操作时，提供通知信息。它可以触发CollectionChanged 事件，可以在该事件中，进行相关的操作。 public static void Run() { var data = new ObservableCollection\u003cstring\u003e(); data.CollectionChanged += Data_CollectionChanged; data.Add(\"one\"); data.Add(\"tow\"); data.Insert(1, \"Three\"); data.Remove(\"one\"); } private static void Data_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) { Console.WriteLine(\"action\" + e.Action.ToString()); if (e.OldItems != null) { Console.WriteLine(\"OldStartingIndex:\" + e.OldStartingIndex); Console.WriteLine(\"old item(s):\"); foreach (var item in e.OldItems) { Console.WriteLine(item); } } if (e.NewItems != null) { Console.WriteLine(\"NewStartingIndex:\" + e.NewStartingIndex); Console.WriteLine(\"new items:\"); foreach (var item in e.NewItems) { Console.WriteLine(item); } } Console.WriteLine(); } 参考资源 《C#高级编程（第10版）》 C#不变集合 C#并发集合 C#可观察集合 C#位数组 C# BitVector32结构 作者：OctOcean 链接：https://www.jianshu.com/p/abbeb5d06a2c 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/:1:4","tags":["C#","特殊集合"],"title":"C#基础提升系列——C#特殊集合","uri":"/posts/2023/01/csharp%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"C#集合 有两种主要的集合类型：泛型集合和非泛型集合。 泛型集合被添加在 .NET Framework 2.0 中，并提供编译时类型安全的集合。 因此，泛型集合通常能提供更好的性能。 构造泛型集合时，它们接受类型形参；并在向该集合添加项或从该集合删除项时无需在Object类型间来回转换。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:0:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"集合接口和类型 System.Array ：用于数组，提供创建，操作，搜索和排序数组的方法，是所有数组的基类。 System.Collections ：是ArrayList、Queue、Hashtable等基类，包含定义对象的各种集合。 System.Collections.Concurrent ：提供了线程安全的集合类。 System.Collections.Generic ：包含接口和定义泛型集合，它允许用户创建强类型集合能提供比非泛型强类型集合更好的类型安全和性能等级。 System.Collections.Specialized：包含强类型集合。专用于特定类型的集合类。 System.Collections.Immutable ：包含了定义不可变的集合接口和类 。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:1:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"列表List\u003cT\u003e 该类派生自如下接口和类： public class List\u003cT\u003e : System.Collections.Generic.ICollection\u003cT\u003e, System.Collections.Generic.IEnumerable\u003cT\u003e, System.Collections.Generic.IList\u003cT\u003e, System.Collections.Generic.IReadOnlyCollection\u003cT\u003e, System.Collections.Generic.IReadOnlyList\u003cT\u003e, System.Collections.IList,System.Collections.IEnumerable,System.Collections.ICollection 创建列表 可以调用默认的构造函数创建列表对象。 List\u003cint\u003e intList = new List\u003cint\u003e(); 使用构造函数创建一个空列表，当元素添加到列表中后，列表的容量就会扩大为可接纳4个元素，当添加第5个元素时，列表的容量大小就会被重新设置为包含8个元素，如果8个元素还不够 ，列表的容量大小就会被设置为16个元素，每次超出已有的容量大小后，都会将列表的容量重新设置为原来的2倍。 使用Capacity属性可以获取该列表的容量大小。下面将使用一个示例来说明添加元素后，Capacity的值是如何变化的。 List\u003cint\u003e intList = new List\u003cint\u003e(); //获取初始容量大小 Console.WriteLine(\"初始容量大小：\" + intList.Capacity); intList.Add(1); Console.WriteLine($\"添加了一个元素后，容量大小为：{intList.Capacity}\"); //获取或设置该内部数据结构在不调整大小的情况下能够容纳的元素总数 intList.Capacity = 5; Console.WriteLine(\"设置了指定的容量大小为5后：\" + intList.Capacity); intList.AddRange(new[] { 2, 3, 4, 5, 6 }); Console.WriteLine($\"添加了{intList.Count}个元素后，容量大小为：{intList.Capacity}\"); 上述的输出结果依次为： 初始容量大小：0 添加了一个元素后，容量大小为：4 设置了指定的容量大小为5后：5 添加了6个元素后，容量大小为：10 \u003e 如果元素添加到列表后，还有多余的容量大小，可以调用TrimExcess()方法，去除不需要的容量。 注意：如果未使用的容量小于总容量的10％，则列表不会调整大小 。 接着上述示例执行下述代码： Console.WriteLine($\"原来的元素个数为：{intList.Count} 容量大小为：\" + intList.Capacity); intList.TrimExcess(); Console.WriteLine(\"调用了TrimExcess()方法后，容量大小为：\" + intList.Capacity); //重新调整容量大小，未使用容量小于总容量10% intList.Capacity = 7; intList.TrimExcess(); Console.WriteLine($\"最终元素个数为：{intList.Count} 容量大小为：\" + intList.Capacity); 输出结果为： 原来的元素个数为：6 容量大小为：10 调用了TrimExcess()方法后，容量大小为：6 最终元素个数为：6 容量大小为：7 初始化集合并设定值 intList = new List\u003cint\u003e() { 1, 2, 3 }; intList = new List\u003cint\u003e { 4, 5, 6 }; 添加或插入元素 使用Add()方法可以给列表添加一个元素，使用AddRange()方法可以一次给集合添加多个元素。使用Insert()方法可以在指定位置插入元素： intList.Add(7); intList.AddRange(new int [] { 7, 8, 9 }); intList.Insert(2, 0); //4 5 0 6 7 7 8 9 访问元素 实现了IList和IList\u003cT\u003e接口的所有类都提供了一个索引器，因此可以使用索引下标的形式进行访问指定索引位置的元素。索引下标从0开始。 \u003e Console.Write(intList[2]); 0 因为List\u003cT\u003e集合类实现了IEnumerate接口，所以可以使用foreach语句进行遍历集合中的元素。 删除元素 使用RemoveAt()方法移除指定索引位置的元素，使用Remove()方法移除指定元素。使用RemoveRange()方法可以从集合中删除多个元素。使用RemoveAll()方法可以删除集合中的所有的元素。 注意：推荐使用RemoveAt()方法按索引删除元素，因为它比Remove()方法执行的要快，Remove()方法会先在集合中搜索元素，搜索的过程中会调用Equals()方法，然后使用IndexOf()方法获取元素的索引，再使用该索引删除元素。 intList.RemoveAt(2);//删除索引2的元素 intList.Remove(7);//删除元素7 intList.RemoveRange(4, 2);//删除索引为4及之后的2个元素 intList.RemoveAll(a =\u003e a \u003e 5); //删除值大于5的元素 搜索元素 可以通过索引或元素本身搜索元素。可以使用的方法有：IndexOf()、LastIndexOf()、FindIndex()、FindLastIndex()、Find()、FindLast()等。判断元素是否存在可以使用Exists()方法。除了这些方法，实际应用中还包括Linq可以使用的方法。具体使用，请查看官方文档。 排序 List\u003cT\u003e类可以使用Sort()方法对元素进行排序。Sort()方法有如下几个重载方法： public void Sort(int index, int count, IComparer\u003cT\u003e comparer); public void Sort(Comparison\u003cT\u003e comparison); public void Sort(); public void Sort(IComparer\u003cT\u003e comparer); 只有集合中的元素实现了IComparable接口，才能使用不带参数的Sort()方法。 如果需要按照元素类型 不 默认支持的方式排序，就需要使用其他重载方法，比如传递一个实现了IComparer\u003cT\u003e接口的对象。 下面将用一个具体的示例进行说明： public class Racer : IComparable\u003cRacer\u003e { public int Id { get; } public string FirstName { get; set; } public string LastName { get; set; } public string Country { get; set; } public int Wins { get; set; } //实现接口中的方法 public int CompareTo(Racer other) { int compare = LastName?.CompareTo(other?.LastName) ?? -1; if (compare == 0) { return FirstName?.CompareTo(other?.FirstName) ?? -1; } return compare; } //定义构造函数 public Racer(int id, string firstName, string lastName, string country, int wins) { this.Id = id; this.FirstName = firstName; this.LastName = lastName; this.Country = country; this.Wins = wins; } //定义另一个构造函数，并调用上述构造函数 public Racer(int id, string firstName, string lastName, string country) : this(id, firstName, lastName, country, wins: 0) { } //重写object的Tostring()方法 public override string ToString() { return $\"{FirstName} {LastName}\"; } } 上述的类直接实现了IComparable\u003cT\u003e泛型接口，所以可以直接使用不带参数的Sort()方法进行排序，排序的依据基于重写的CompareTo()方法。 var racers = new List\u003cRacer\u003e { new Racer(1,\"zhang\",\"bsan\",\"中国\"), new Racer(3,\"li\",\"asi\",\"中国\"), new Racer(2,\"wang\",\"dwu\",\"中国\") }; racers.Sort(); 执行上述语句，将会按照LastName进行排序后输出，依次为li asi、zhang bsan、wang dwu","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:2:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"队列Queue\u003cT\u003e 队列是其元素以先进先出（Firstin，Firstout，FIFO）的方式来处理的集合，先放入队列中的元素会先读取。队列使用System.Collections.Generic命名空间中的泛型类Queue\u003cT\u003e实现，它的声明如下： [System.Runtime.InteropServices.ComVisible(false)] public class Queue\u003cT\u003e : System.Collections.Generic.IEnumerable\u003cT\u003e, System.Collections.Generic.IReadOnlyCollection\u003cT\u003e, System.Collections.ICollection 由于Queue\u003cT\u003e没有实现ICollection\u003cT\u003e泛型接口，所以不能使用这个接口中定义的Add()和Remove()方法操作元素。也因为Queue\u003cT\u003e没有实现IList\u003cT\u003e泛型接口，所以也不能使用索引下标的方式访问队列。 Queue\u003cT\u003e常用方法和属性说明： Dequeue() ：删除并返回队列开头的元素。如果队列中没有元素，在调用该方法时，将会抛出一个InvalidOperationException类型的异常。 Enqueue(T) ：将元素添加到队列的末尾。 Peek() ：返回但不删除队列开头的元素。 TrimExcess() ：如果该数量小于当前容量的90％，则将容量设置为队列的实际元素数。 Count ：获取队列中的元素的个数 可以使用默认的构造函数创建一个空队列，也可以使用构造函数指定容量。在把元素添加到队列中时，如果没有指定容量，将会类似于List\u003cT\u003e类，队列的容量也总是根据需要成倍增加，从而包含4、8、16和32个元素等。 下面将使用一个复杂的示例说明队列是如何使用的。首先定义一个简单的类： public class Document { public string Title { get; } public string Content { get; } public Document(string title, string content) { this.Title = title; this.Content = content; } } 接着为这个类进行队列写入和读取操作： public class DocumentManager { private readonly Queue\u003cDocument\u003e _documentQueue = new Queue\u003cDocument\u003e(); //向队列中添加元素 public void AddDocument(Document doc) { //因为后面将要使用多线程，为了避免死锁，进行lock语句限制 lock (this) { _documentQueue.Enqueue(doc); } } //获取队列中的元素 public Document GetDocument() { Document doc = null; lock (this) { doc = _documentQueue.Dequeue(); } return doc; } //队列中是否还有元素未读出 public bool IsDocumentAvailable =\u003e _documentQueue.Count \u003e 0; } 然后定义一个操作此类的对外开放的类： public class ProcessDocuments { private DocumentManager _documentManager; protected ProcessDocuments(DocumentManager dm) { _documentManager = dm ?? throw new ArgumentNullException(nameof(dm)); } protected async Task Run() { while (true) { if (_documentManager.IsDocumentAvailable) { Document doc = _documentManager.GetDocument(); Console.WriteLine(doc.Title + \":\" + doc.Content); } //显式的指定间隔时间，将会在此等待，从而执行该方法之外的代码部分 await Task.Delay(new Random().Next(1000)); } } //对外开放的调用方法 public static void Start(DocumentManager dm) { //启动一个新的任务 Task.Run(new ProcessDocuments(dm).Run); } } 调用代码如下： public static void Run() { var dm = new DocumentManager(); ProcessDocuments.Start(dm); for (int i = 0; i \u003c 1000; i++) { var doc = new Document(\"Doc_\" + i, \"Content_\" + i); dm.AddDocument(doc); Console.WriteLine(\"添加了document:Doc_\" + i); System.Threading.Thread.Sleep(new Random().Next(1000)); } } ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:3:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"栈Stack\u003cT\u003e 栈是一个后进先出（Lastin，Firstout，LIFO）的集合，最后添加到栈中的元素会最先读取。它和队列非常的类似，只是读取元素的方法不同。栈在.NET中的声明如下： [System.Runtime.InteropServices.ComVisible(false)] public class Stack\u003cT\u003e : System.Collections.Generic.IEnumerable\u003cT\u003e, System.Collections.Generic.IReadOnlyCollection\u003cT\u003e, System.Collections.ICollection 常用的方法和属性有 ： Pop() ：删除并返回栈的顶部的一元素。如果栈没有元素，调用该方法将会抛出InvalidOperationException异常。 Push(T) :在栈的顶部插入一个元素。 Peek() ：返回但不删除栈的顶部的一个元素。 Contains(T) ：判断一个元素是否在栈中。 Count ：返回栈中元素的个数。 下面使用一个简单的示例来说明栈的相关操作： var mystacks = new Stack\u003cint\u003e(); mystacks.Push(1); mystacks.Push(2); mystacks.Push(3); foreach(var num in mystacks) { Console.Write(num+\"\\t\"); //将会输出：3 2 1 } Console.WriteLine(); while (mystacks.Count \u003e 0) { Console.Write(mystacks.Pop() + \"\\t\"); } ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:4:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"链表LinkedList\u003cT\u003e LinkedList\u003cT\u003e是一个双向链表，其元素指向它前面和后面的元素。 链表的优点是，如果将元素插入列表的中间位置，使用链表就会非常快。在往链表插入一个新的元素时，只需要修改上一个元素的Next引用和下一个元素的Previous引用，使它们的引用指向新插入的元素。【删除原因：表述不准确，Next和Previous都是获取值不能设置值】 链表的缺点是，链表的元素只能一个接一个地访问，这需要较长的时间来查找位于链表中间或尾部的元素。 LinkedList\u003cT\u003e在.NET中的定义： [System.Runtime.InteropServices.ComVisible(false)] public class LinkedList\u003cT\u003e : System.Collections.Generic.ICollection\u003cT\u003e, System.Collections.Generic.IEnumerable\u003cT\u003e, System.Collections.Generic.IReadOnlyCollection\u003cT\u003e, System.Collections.ICollection, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable 操作链表时，离不开泛型类LinkedListNode\u003cT\u003e，它表示LinkedList\u003cT\u003e中的节点。LinkedListNode\u003cT\u003e是一个独立定义的类，并不继承自LinkedList\u003cT\u003e，但是链表LinkedList\u003cT\u003e包含的元素节点均来自于LinkedListNode\u003cT\u003e，以下为链表LinkedList\u003cT\u003e部分常用方法和属性： public LinkedListNode\u003cT\u003e Last { get; } public LinkedListNode\u003cT\u003e First { get; } public LinkedListNode\u003cT\u003e AddAfter(LinkedListNode\u003cT\u003e node, T value); public void AddAfter(LinkedListNode\u003cT\u003e node, LinkedListNode\u003cT\u003e newNode); public LinkedListNode\u003cT\u003e AddBefore(LinkedListNode\u003cT\u003e node, T value); public void AddBefore(LinkedListNode\u003cT\u003e node, LinkedListNode\u003cT\u003e newNode); public LinkedListNode\u003cT\u003e AddFirst(T value); public void AddFirst(LinkedListNode\u003cT\u003e node); public LinkedListNode\u003cT\u003e AddLast(T value); public void AddLast(LinkedListNode\u003cT\u003e node); public LinkedListNode\u003cT\u003e Find(T value); public LinkedListNode\u003cT\u003e FindLast(T value); 上述大多数都与LinkedListNode\u003cT\u003e紧密相关： [System.Runtime.InteropServices.ComVisible(false)] public sealed class LinkedListNode\u003cT\u003e { public LinkedListNode(T value); public LinkedList\u003cT\u003e List { get; } public LinkedListNode\u003cT\u003e Next { get; } public LinkedListNode\u003cT\u003e Previous { get; } public T Value { get; set; } } 通过定义可以知道，使用LinkedListNode\u003cT\u003e类，可以获得列表中的下一个元素和上一个元素。LinkedListNode\u003cT\u003e定义了属性List（返回对应的LinkedList\u003cT\u003e对象）、Next、Previous和Value（返回与节点相关的元素，其类型是T）。并且它提供的属性大多数都是可读不可写。 注：LinkedListNode\u003cT\u003e的成员很少，几乎提供的全是读取的操作，因此实际操作元素比如添加、删除等，还是通过LinkedList\u003cT\u003e的成员方法（如上述展示的方法）进行调用。 下面将使用一个完整的示例说明如何使用链表进行操作，该示例使用链表让文档按照优先级进行排序显示，并且在链表中添加新文档时，新添加的文档应该放在优先级相同的最后一个文档的后面。 首先定义一个简单的类Document_V2，它包括基本的文档信息已经优先级： public class Document_V2 { public string Title { get; private set; } public string Content { get; private set; } public byte Priority { get; private set; } public Document_V2(string title,string content,byte priority) { this.Title = title; this.Content = content; this.Priority = priority; } } 接着定义一个操作该类链表的类： public class PriorityDocumentManager { //集合LinkedList\u003cDocument_V2\u003e包含多个LinkedListNode\u003cDocument_V2\u003e类型的元素 private readonly LinkedList\u003cDocument_V2\u003e _documentList; //定义包含LinkedListNode\u003cDocument_V2\u003e类型的List集合，便于后续使用Next和Previous属性进行遍历 private readonly List\u003cLinkedListNode\u003cDocument_V2\u003e\u003e _priorityNodes; public PriorityDocumentManager() { _documentList = new LinkedList\u003cDocument_V2\u003e(); _priorityNodes = new List\u003cLinkedListNode\u003cDocument_V2\u003e\u003e(10); for (int i = 0; i \u003c 10; i++) { //添加10个类型为Document_V2的空节点（节点的Value及其他属性均为null） _priorityNodes.Add(new LinkedListNode\u003cDocument_V2\u003e(null)); } } public void AddDocument(Document_V2 d) { if (d == null) throw new ArgumentNullException(\"d\"); AddDocumentToPriorityNode(d, d.Priority); } private void AddDocumentToPriorityNode(Document_V2 doc, int priority) { if (priority \u003e 9 || priority \u003c 0) { throw new ArgumentException(\"等级必须为0~9\"); } if (_priorityNodes[priority].Value == null) { --priority; if (priority \u003e= 0) { //递归调用该方法 AddDocumentToPriorityNode(doc, priority); } else { _documentList.AddLast(doc); _priorityNodes[doc.Priority] = _documentList.Last; } return; } else { LinkedListNode\u003cDocument_V2\u003e prioNode = _priorityNodes[priority]; //判断优先级是否相同 if (priority == doc.Priority) { _documentList.AddAfter(prioNode, doc); _priorityNodes[doc.Priority] = prioNode.Next; } else { LinkedListNode\u003cDocument_V2\u003e firstPrioNode = prioNode; //循环遍历所有链接节点 while (firstPrioNode.Previous != null \u0026\u0026 firstPrioNode.Previous.Value.Priority == prioNode.Value.Priority) { firstPrioNode = prioNode.Previous; prioNode = firstPrioNode; } _documentList.AddBefore(firstPrioNode, doc); _priorityNodes[doc.","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:5:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"有序列表SortedList\u003cTKey, TValue\u003e 使用SortedList\u003cTKey, TValue\u003e类可以基于键对集合排序。 使用一个简单的示例对其进行操作说明： var mysortedlist = new SortedList\u003cstring, string\u003e(); mysortedlist.Add(\"one\", \"一\"); mysortedlist.Add(\"two\", \"二\"); mysortedlist.Add(\"three\", \"三\"); mysortedlist.Add(\"four\", \"四\"); //还可以使用索引的形式添加元素，索引参数是键 mysortedlist[\"five\"] = \"五\"; //修改值 mysortedlist[\"three\"] = \"3\"; foreach (var item in mysortedlist) { Console.WriteLine($\"{item.Key}:{item.Value}\"); } 上述将会按照键自动的进行排序显示，显示结果： five:五 four:四 one:一 three:3 two:二 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:6:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"字典Dictionary\u003cTKey, TValue\u003e 字典表示一种非常复杂的数据结构，由键和值组成，这种数据结构允许按照某个键来访问元素。字典也被称为映射或散列表。 字典初始化 之前只能先实例一个字典对象，然后使用Add()方法添加元素，在C#6定义了一个新的语法，可以在声明的同时初始化字典，例如： var dic = new Dictionary\u003cint, string\u003e() { //第一元素的键是100 [100] = \"第一个元素\", [200] = \"第二个元素\" }; 键的类型 字典类要确定元素的位置，它就要调用GetHashCode()方法，GetHashCode()方法返回的int由字典用于计算在对应位置放置元素的索引，因此用作字典中的键的类型必须重写Object类的GetHashCode()方法。GetHashCode()方法的实现代码必须满足如下要求： 相同的对象应该总是返回相同的值。 不同的对象可以返回相同的值。 不能抛出异常。 至少使用一个实例字段。 散列代码（调用GetHashCode方法得到的值）在对象的生存期中不发生变化。 除了必须要满足的要求外，最好还满足如下要求： 它应该执行的比较快，计算开销不大。 散列代码值应平均分布在int可以存储的整个数字范围内。 注意：字典的性能 取决于GetHashCode()方法的实现代码。 通过GetHashCode得到的散列代码值的范围应该尽可能的分布在int可以存储的整个数字范围内，避免两个键返回的散列代码值得到相同的索引（字典中的索引包含一个到值的链接，一个索引项可以关联多个值，此处的索引不是指索引下标），这会降低性能，因为字典类需要寻找最近的可用空闲位置来存储第二个数据项，这需要进行一定的搜索，如果在排序时许多键都有相同的索引，这类冲突就更可能出现，所以，当计算出来的散列代码值平均分布在int.MinValue和int.MaxValue之间时，这种风险会降低到最小。 除了实现GetHashCode()方法之外，键类型还必须实现IEquatable\u003cT\u003e.EQuals()方法，或重写Object类的Equals()方法。因为不同的键对象可能返回相同的散列代码，所以字典使用Equals()方法来比较键。字典检查两个键A和B是否相等，并调用A.Equals(B)方法。这说明必须确保下述条件总是成立： 如果A.Equals(B)方法返回true，则A.GetHashCode()和B.GetHashCode()方法必须总是返回相同的散列代码。 注意：如果为Equals()方法提供了重写版本，但没有提供GetHashCode()方法的重写版本，C#编译器就会显示一个编译警告。 综上所述，应用在字典中的键，必须实现或重写GetHashCode()和IEquatable\u003cT\u003e.EQuals()方法。如果这两个方法都没有实现， 可以创建一个实现IEqualityComparer\u003cT\u003e接口的比较器，IEqualityComparer\u003cT\u003e接口定义了GetHashCode()和Equals()方法，并将传递的对象作为参数，因此可以提供与对象类型不同的实现方式。Dictionary\u003cTKey,TValue\u003e构造函数的一个重载版本允许传递一个实现了IEqualityComparer\u003cT\u003e接口的对象。如果把这个对象赋予字典，该类就用于生成散列代码并比较键。 下面通过一个示例进行说明。首先创建字典中的键将要使用到的类型： public struct EmployeeId : IEquatable\u003cEmployeeId\u003e { private readonly char prefix; private readonly int number; public EmployeeId(string id) { //System.Diagnostics.Contracts.Contract.Requires\u003cArgumentNullException\u003e(id != null); prefix = (id.ToUpper())[0]; int numLength = id.Length - 1; try { number = int.Parse(id.Substring(1, numLength \u003e 6 ? 6 : numLength)); } catch (Exception) { throw new Exception(\"EmployeeId格式错误\"); } } public override string ToString() { return prefix.ToString() + $\"{number,6:000000}\"; } //重写GetHashCode()方法 public override int GetHashCode() { //此条语句只是为了使得到的值能够尽可能的平均到int范围 //将数字向左移动16位，再与原数字进行异或操作，得到的结果乘以16进制数15051505 return (number ^ number \u003c\u003c 16) * 0x15051505; } //必须实现Equals()方法 public bool Equals(EmployeeId other) { //return (_prefix == other?._prefix \u0026\u0026 _number == other?._number); return (prefix == other.prefix \u0026\u0026 number == other.number); } public override bool Equals(object obj) { return Equals((EmployeeId)obj); } //使用 operator 关键字重载内置运算符== public static bool operator ==(EmployeeId left, EmployeeId right) { return left.Equals(right); } //使用 operator 关键字重载内置运算符!= public static bool operator !=(EmployeeId left, EmployeeId right) =\u003e !(left == right); } 接着创建字典中的值对应的类型： public class Employee { private string name; private decimal salary; private readonly EmployeeId id; public Employee(EmployeeId id, string name, decimal salary) { this.id = id; this.name = name; this.salary = salary; } public override string ToString() { return $\"{id.ToString()}:{name,-20} {salary:C}\"; } } 定义字典，并调用： public static void Run() { var idTony = new EmployeeId(\"C3755\"); var tony = new Employee(idTony, \"Tony Stewart\", 379025.00m); var idCarl = new EmployeeId(\"F3547\"); var carl = new Employee(idCarl, \"Carl Edwards\", 403466.00m); var idKevin = new EmployeeId(\"C3386\"); var kevin = new Employee(idKevin, \"kevin Harwick\", 415261.00m); //字典使用EmployeeId对象来索引 var employees = new Dictionary\u003cEmployeeId, Employee\u003e(5) { [idTony] = tony, [idCarl] = carl, [idKevin] = kevin }; foreach (var employee in employees.Values) { Console.WriteLine(employee); } } Lookup\u003cTKey,TElement\u003e Lookup\u003cTKey,TElement\u003e类非常类似于Dictionary\u003cTKey,TValue\u003e类，但是Lookup\u003cTKey,TElement\u003e表示每个映射到一个或多个值的键集合，也就是它的键可以映射到一个或多个值，Lookup\u003cTKey,TElement\u003e中的TElement表示的是Lookup\u003cTKey,TElement\u003e中每个IEnumerable\u003cT\u003e值的元素类型。所以要获取其中的每个元素，可以使用循环进行遍历： var racers = new List\u003cRacer\u003e(); racers.Add(new Racer(1, \"zhang\", \"san\", \"zhongguo\")); racers.Add(new Racer(2, \"li\", \"si\", \"riben\")); racers.Add(new Racer(3, \"wang\", \"wu\", \"zhongguo\")); racers.Add(new Racer(4, \"zhao\", \"liu\", \"meiguo\")); va","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:7:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"集Set 集（set）是包含不重复的元素的集合。主要有两个集，HashSet\u003cT\u003e和SortedSet\u003cT\u003e，它们都实现ISet\u003cT\u003e接口，其中，HashSet\u003cT\u003e集包含不重复元素的无序列表，SortedSet\u003cT\u003e集包含不重复元素的有序列表。 ISet\u003cT\u003e常用方法： bool Add(T item)：向当前集添加元素并返回一个值以指示元素是否已成功添加。 void ExceptWith(IEnumerable\u003cT\u003e other)：从当前集中删除指定集合中的所有元素。 bool IsSubsetOf(IEnumerable\u003cT\u003e other)：确定集合是否是指定集合的子集。 bool IsSupersetOf(IEnumerable\u003cT\u003e other)：确定当前集是否是指定集合的超集。 bool Overlaps(IEnumerable\u003cT\u003e other)：确定当前集是否与指定集合重叠。 void UnionWith(IEnumerable\u003cT\u003e other)：修改当前集，使其包含当前集，指定集合或两者中存在的所有元素。 var hsA = new HashSet\u003cstring\u003e() { \"one\", \"two\", \"three\" }; var hsB = new HashSet\u003cstring\u003e() { \"two\", \"three\", \"four\" }; if (hsA.Add(\"five\")) { Console.WriteLine(\"添加了five\"); } if (!hsA.Add(\"two\")) { Console.WriteLine(\"已经存在了two\"); } var hsM = new HashSet\u003cstring\u003e() { \"one\", \"two\", \"three\", \"four\", \"five\", \"six\" }; //hsA的每个元素是否都包含在hsB中 if (hsA.IsSubsetOf(hsB))//false { Console.WriteLine(\"hsA是hsB的子集\"); } if (hsA.IsSubsetOf(hsM))//true { Console.WriteLine(\"hsA是hsM的子集\"); } //hsA是否是hsB的超集 if (hsA.IsSupersetOf(hsB))//false { Console.WriteLine(\"hsA是hsB的超集\"); } if (hsM.IsSupersetOf(hsB))//true { Console.WriteLine(\"hsM是hsB的超集\"); } //判断hsA是否与hsB有公共元素 if (hsA.Overlaps(hsB))//true { Console.WriteLine(\"hsA与hsB包含共同元素\"); } var allhs = new SortedSet\u003cstring\u003e(hsA); allhs.UnionWith(hsB); allhs.UnionWith(hsM); foreach (var n in allhs) { Console.Write(n + \"\\t\"); } var ex = new HashSet\u003cstring\u003e() { \"five\", \"three\" }; //删除ex包含的元素 allhs.ExceptWith(ex); Console.WriteLine(); Console.WriteLine(\"删除后：\"); foreach (var n in allhs) { Console.Write(n + \"\\t\"); } ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:8:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"性能 集合的性能决定了操作时应该选择哪种集合。在MSDN文档中，集合的方法常常有性能提示，给出了以大写O记号表示的操作时间： O(1)：表示无论集合中有多少数据项，这个操作需要的时间都不变。 O(n)：表示对于集合执行一个操作需要的时间在最坏情况下是N。 O(log n)：表示操作需要的时间随着集合中元素的增加而增加，但每个元素需要增加的时间不是线性的，而是成对数曲线。 下表列出了集合类执行不同操作的性能，如果单元格中有多个大O值，表示若集合需要重置大小，该操作就需要一定的时间。一般重置大小出现在集合的容量不足以满足需要添加的元素总个数，因此最好避免重置集合的大小，而应把集合的容量设置为一个可以包含所有元素的值。 如果表单元格的内容是n/a（代表not applicable），就表示这个操作不能应用于这个集合类型。 集合 Add Insert Remove Item Sort Find List\u003cT\u003e 如果集合必须重置大小，就是O(1)或O(n) O(n) O(n) O(1) O(n log n)，最坏的情况是O(n^2) O(n) Stack\u003cT\u003e Push()，如果栈必须重置大小，就是O(1)或O(n) n/a Pop，O(1) n/a n/a n/a Queue\u003cT\u003e Enqueue(),如果队列必须重置大小，就是O(1)或O(n) n/a Dequeue, O(1) n/a n/a n/a HashSet\u003cT\u003e 如果集必须重置大小，就是O(1)或O(n) Add,O(1)或O(n) O(1) n/a n/a n/a SortedSet\u003cT\u003e 如果集必须重置大小，就是O(1)或O(n) Add,O(1)或O(n) O(1) n/a n/a n/a LinkedList\u003cT\u003e AddLast，O(1) AddAfter, O(1) O(1) n/a n/a O(n) Dictionary \u003cTKey,TValue\u003e O(1)或O(n) n/a O(1) O(1) n/a n/a SortedDictionary \u003cTkey,TValue\u003e O(log n) n/a O(log n) O(log n) n/a n/a SortedList \u003cTKey,TValue\u003e 无序数据为O(n)；如果必须重置大小，就是O(n)；到列表的尾部，就是O(log n) n/a O(n) 读/写是O(log n);如果键在列表中，就是O(log n)；如果键不在列表中，就是O(n) n/a n/a ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:9:0","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"参考资源 《C#高级编程（第10版）》 C#集合和数据结构 作者：OctOcean 链接：https://www.jianshu.com/p/c654991806e9 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/:9:1","tags":["C#","集合"],"title":"C#基础提升系列——C#集合","uri":"/posts/2023/01/csharp%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"C# 泛型(Generics) ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/:0:0","tags":["C#","泛型"],"title":"C#基础提升系列——C#泛型","uri":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/"},{"categories":["编程"],"content":"泛型概述 泛型是C#编程语言的一部分，它与程序集中的IL(Intermediate Language，中间语言)代码紧密的集成。通过泛型，我们不必给不同的类型编写功能相同的许多方法和类，而是可以创建独立于被包含类型的一个类或方法。 例如，通过使用泛型类型参数 T，可以编写其他客户端代码能够使用的单个类，而不会产生运行时转换或装箱操作的成本或风险。使用泛型类型可以最大限度地重用代码、保护类型安全性以及提高性能。 泛型性能 泛型的一个主要优点是性能。值类型存储在栈上，引用类型存储在堆上。从值类型转换为引用类型称为装箱；从引用类型转换为值类型称为拆箱。对值类型使用非泛型集合类，常常需要将值类型和引用类型互相转换，进行装箱和拆箱操作，性能损失比较大。而使用了泛型，可以很好的解决这一问题，泛型可以不再进行装箱和拆箱操作。 泛型类型安全 泛型的另一个特性是类型安全。例如，在泛型类List\u003cT\u003e中，泛型类型T定义了允许使用的类型。假设有一个泛型实例为List\u003cint\u003e，它在添加元素时，就只会添加类型为int的数值到集合中。 泛型允许二进制代码重用 泛型允许更好的重用二进制代码，泛型类可以定义一次，使用许多不同的类型实例化。例如，泛型类List\u003cT\u003e可以实例化为List\u003cint\u003e、List\u003cstring\u003e、List\u003cMyClass\u003e等。 泛型实例化时代码生成 泛型类的定义会放在程序集 中，所以用特定类型实例化泛型类不会在中间语言（IL）代码中复制这些类。但是，在JIT编译器把泛型类编译为本地代码时，会给每个值类型创建一个新类。而引用类型共享同一个本地类的所有相同的实现代码。这是因为引用类型在实例化泛型类中只需要4个字节的内存地址（32位系统），就可以引用一个引用类型。值类型包含在实例化的泛型类的内存中，同时因为每个值类型对内存的要求都不同，所以要为每个值类型实例化一个新类。 注：【本段文字来自于《C#高级编程（第10版）》中的”不同的特定类型实例化泛型时创建了多少代码“相关描述】 泛型类型命名约定 泛型类型的名称用字母T作为前缀。 如果没有特殊的要求，泛型类型允许用任意类替代，且只使用了一个泛型类型，就可以用字符T作为泛型类型的名称。例如：public class List\u003cT\u003e{} 如果泛型类型有特定的要求（例如，它必须实现一个接口或派生自基类），或者使用了两个或多个泛型类型，就应给泛型类型使用描述性的 名称。例如：public class SortedList\u003cTkey,TValue\u003e{} ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/:1:0","tags":["C#","泛型"],"title":"C#基础提升系列——C#泛型","uri":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/"},{"categories":["编程"],"content":"泛型类 泛型类型：也被称为泛型类型参数，它是在实例化泛型类的一个变量时，泛型声明中指定的特定类型的占位符，即泛型类中指定的T。 泛型类：定义泛型类型的类，例如List\u003cT\u003e，它无法按原样使用，因为它不是真正的类型；它更像是类型的蓝图。 若要使用 List\u003cT\u003e，客户端代码必须通过指定尖括号内的类型参数来声明并实例化构造类型。 创建泛型类 通常，创建泛型类是从现有具体类开始，然后每次逐个将类型更改为类型参数，直到泛化和可用性达到最佳平衡。 在创建泛型类之前，先建立一个简单的普通类，然后再把这个类转化为泛型类。 定义一个一般的、非泛型的简化链表类： public class LinkedListNode { public object Value { get; private set; } public LinkedListNode(object value) { Value = value; } public LinkedListNode Prev { get; internal set; } public LinkedListNode Next { get; internal set; } } public class LinkedList : IEnumerable { public LinkedListNode First { get; private set; } public LinkedListNode Last { get; private set; } //在链表尾部添加一个新元素 public LinkedListNode AddLast(object node) { var newNode = new LinkedListNode(node); if (First == null) { First = newNode; Last = First; } else { LinkedListNode previous = Last; Last.Next = newNode; Last = newNode; Last.Prev = previous; } return newNode; } //实现GetEnumerator()方法 public IEnumerator GetEnumerator() { LinkedListNode current = First; while (current != null) { //使用yield语句创建一个枚举器类型 yield return current.Value; current = current.Next; } } } 当调用上述LinkedList类的AddLast()方法传入任意类型的值时，会进行一系列的装箱和拆箱的操作 var list1 = new LinkedList(); list1.AddLast(2); list1.AddLast(3); list1.AddLast(\"4\"); foreach (var i in list1) { Console.WriteLine(i); } 使用泛型定义上述类 public class LinkedListNode\u003cT\u003e { public LinkedListNode(T value) { Value = value; } public LinkedListNode\u003cT\u003e Next { get; internal set; } public LinkedListNode\u003cT\u003e Prev { get; internal set; } public T Value { get; private set; } } public class LinkedList\u003cT\u003e : IEnumerable\u003cT\u003e { public LinkedListNode\u003cT\u003e First { get; private set; } public LinkedListNode\u003cT\u003e Last { get; private set; } public LinkedListNode\u003cT\u003e AddLast(T node) { var newNode = new LinkedListNode\u003cT\u003e(node); if (First == null) { First = newNode; Last = First; } else { LinkedListNode\u003cT\u003e previous = Last; Last.Next = newNode; Last = newNode; Last.Prev = previous; } return newNode; } public IEnumerator\u003cT\u003e GetEnumerator() { LinkedListNode\u003cT\u003e current = First; while (current != null) { yield return current.Value; current = current.Next; } } IEnumerator IEnumerable.GetEnumerator() =\u003e GetEnumerator(); } 泛型类的定义与一般类类似，只是要使用泛型类型声明。声明后的泛型类型可以在类中用作方法或字段成员的参数类型。 调用上述中声明的方法用例如下，此时添加元素和遍历元素时都不用频繁的装箱和拆箱： var list2 = new LinkedList\u003cstring\u003e(); list2.AddLast(\"java\"); list2.AddLast(\"c#\"); list2.AddLast(\"python\"); foreach (string i in list2) { Console.WriteLine(i); } 泛型类功能 在创建泛型类时，可以为泛型类型指定默认值、约束、继承和静态成员等。 创建如下一个简单泛型类 ，用于从队列中读写文档。 public class DocumentManager\u003cT\u003e { private readonly Queue\u003cT\u003e documentQueue = new Queue\u003cT\u003e(); public bool IsDocumentAvailable =\u003e documentQueue.Count \u003e 0; public void AddDocument(T doc) { lock (this) { documentQueue.Enqueue(doc); } } } //定义一个简单的接口 public interface IDocument { string Title { get; set; } string Content { get; set; } } //实现该接口 public class Document : IDocument { public Document(string title, string content) { this.Title = title; this.Content = content; } public string Content { get; set; } public string Title { get; set; } } 泛型类型默认值 在上述类DocumentManager\u003cT\u003e中添加如下方法： public T GetDocument() { //default将泛型类型的值初始化为null或者0，取决于泛型类型是引用类型还是值类型。 T doc = default(T); lock (this) { doc = documentQueue.Dequeue(); } return doc; } 该方法直接返回类型T的值，由于不能把null赋予泛型类型，原因是泛型类型可以实例化为值类型，而null只能用于引用类型，因此为了解决这个问题，使用了default关键字来代替T doc=null; 通过default关键字，可以自动的将null赋予引用类型，将0赋予值类型，而不用管T具体是哪种类型。 泛型类型约束 如果泛型类（定义泛型类型的类，如DocumentManager）需要调用泛型类型（T）中的方法，就必须添加约束。 例如，在泛型类DocumentManager\u003cT\u003e中添加DisplayAllDocuments()方法用于显示泛型类型T对应的Title值，需要强制进行类型转换，如下： public void DisplayAllDocuments() { foreach (T doc in documentQueue) { Console.WriteLine(((IDocument)doc).Title); } } 一旦类型T没有实现IDocument接口，上述类型转换就会存在错误，此时最好的做法就是为泛型类添加一个约束：T必须实现IDocument接口。 public class DocumentManager\u003cTDocument\u003e where TDocument : IDocument { private readonly Queue\u003cTDocument\u003e documentQueue = new Queue\u003cTDocument\u003e(); public bool IsDocumentAvailable =\u003e documentQueue.Count \u003e 0; public void AddDocument(TDocument doc) { lock (this) { documentQueue.Enqueue(doc","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/:2:0","tags":["C#","泛型"],"title":"C#基础提升系列——C#泛型","uri":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/"},{"categories":["编程"],"content":"泛型接口 使用泛型可以定义接口，在接口中定义的方法可以带泛型参数。.NET提供了许多泛型接口，同一个接口常常存在比较老的非泛型版本，建议在实际使用中，优先采用泛型版本去解决问题。 泛型接口中的协变和逆变 为了更好的解释协变和逆变的概念，我们使用List、IList、IEnumerable三者做一个简单的测验。首先我们定义一个List\u003cstring\u003e 实例变量listA，并将listA的值指向IList\u003cstring\u003e的变量iListA，同时分别使用IEnumerable\u003cstring\u003e去引用这两个变量。 List\u003cstring\u003e listA = new List\u003cstring\u003e(); IList\u003cstring\u003e iListA = listA; IEnumerable\u003cstring\u003e iEnumerableA = listA; IEnumerable\u003cstring\u003e iEnumerableB = iListA; 此时代码不会产生错误，能够正常编译。因为List\u003cT\u003e派生自IList\u003cT\u003e和IEnumerable\u003cT\u003e，IList\u003cT\u003e派生自IEnumerable\u003cT\u003e，父类引用指向子类对象，所以代码可以通过编译。 注意：IEnumerable\u003cT\u003e实际上是一个变体，查看定义的源码如下： public interface IEnumerable\u003cout T\u003e : IEnumerable { IEnumerator\u003cT\u003e GetEnumerator(); } 特别需要注意的是泛型类型T前面的out关键字，它代表的就是协变。它的作用是什么？ C#中的string派生自Object类型，假设我们也想通过object的集合直接去引用string的List，类似于如下代码： List\u003cobject\u003e listB = new List\u003cstring\u003e(); //报错，不会通过编译 IList\u003cobject\u003e iListB = new List\u003cstring\u003e(); //报错，不会通过编译 上述的两条语句均会编译失败，因为List\u003cT\u003e和IList\u003cT\u003e在泛型定义时均没有指定out关键字。而使用IEnumerable\u003cT\u003e可以通过编译： IEnumerable\u003cobject\u003e iEnumerableB = new List\u003cstring\u003e();//代码可以正常编译 上述语句可以通过编译。 注意：只有引用类型才支持使用泛型接口中的变体。 值类型不支持变体。 如下语句将会编译报错： IEnumerable\u003cobject\u003e integers = new List\u003cint\u003e();//编译错误，值类型不支持变体 下面将用具体的示例对协变和逆变做详细说明。首先定义两个简单的类，其中Rectangle继承自父类Shape。 public class Shape { public double Width { get; set; } public double Height { get; set; } //重写Object的ToString方法 public override string ToString() =\u003e $\"Width:{Width},Height:{Height}\"; } //定义子类Rectangle public class Rectangle : Shape { } 泛型接口的协变 如果泛型类型使用out关键字标注，该泛型接口就是协变的。 public interface IIndex\u003cout T\u003e { //定义一个索引器 T this[int index] { get; } int Count { get; } } public class RectangleCollection : IIndex\u003cRectangle\u003e { private Rectangle[] data = new Rectangle[3] { new Rectangle{Height=2,Width=5}, new Rectangle{ Height=3, Width=7}, new Rectangle{ Height=4.5, Width=2.9} }; public int Count =\u003e data.Length; public Rectangle this[int index] { get { if (index \u003c 0 || index \u003e data.Length) { throw new ArgumentOutOfRangeException(\"index\"); } return data[index]; } } } 上述定义了一个泛型接口IIndex，并使用out标注为协变，接着定义类RectangleCollection实现该接口，调用上述代码如下： IIndex\u003cRectangle\u003e rectangles = new RectangleCollection(); //由于采用了协变，此处可以直接使用父类Shape相关的引用指向子类Rectangle相关的对象 IIndex\u003cShape\u003e shapes = rectangles; IIndex\u003cShape\u003e shapes2 = new RectangleCollection(); for (int i = 0; i \u003c shapes.Count; i++) { Console.WriteLine(shapes[i]); } 泛型接口的逆变 使用in关键字标注泛型类型的接口就是逆变的。 public interface IDisplay\u003cin T\u003e { void Show(T item); } public class ShapeDisplay : IDisplay\u003cShape\u003e { public void Show(Shape item) { Console.WriteLine($\"{item.GetType().Name} Width:{item.Width},Height:{item.Height}\"); } } 上述定义了一个逆变的泛型接口IDisplay，并使用ShapeDisplay实现它，注意实现时指定的类型是Shape，并且定义了Show方法，显示对应Type名。调用代码如下： IDisplay\u003cShape\u003e sd = new ShapeDisplay(); //由于采用了逆变，可以使用Rectangle相关的引用指向父类Shape相关的对象 IDisplay\u003cRectangle\u003e rectangleDisplay = sd; rectangleDisplay.Show(rectangles[0]); //Type将会输出为Rectangle 下面是我自己的理解做的一个总结 协变：使用out关键字标注，协助变换，既然是协助就说明是客观存在的，也就是顺应\"父类引用指向子类对象\"这一原则所做的转换，协变会保留分配兼容性。协变允许方法具有的返回类型比接口的泛型类型参数定义的返回类型的派生程度更大。 在.net中，大多数的参数类型类似于协变 ，比如定义了一个方法，参数为object，调用该方法时，可以为参数传入所有object派生出的子类对象。 逆变：逆反变换，违背”父类引用指向子类对象“这一原则所做的转换，和协变相反，类似于“子类引用父类相关的对象”。逆变允许方法具有的实参类型比接口的泛型形参定义的类型的派生程度更小。比如定义一个方法，方法的参数为object，返回的类型为object的子类，此时不能直接返回传入的参数，必须进行类型转换，而逆变可以很好的解决此类问题。 变体：如果泛型接口或委托的泛型参数被声明为协变或逆变，该泛型接口或委托则被称为“变体”。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/:3:0","tags":["C#","泛型"],"title":"C#基础提升系列——C#泛型","uri":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/"},{"categories":["编程"],"content":"泛型方法 在泛型方法中，泛型类型用方法声明来定义。泛型方法可以在非泛型类中定义。如下，定义一个简单的泛型方法： void Swap\u003cT\u003e(ref T x,ref T y) { T temp; temp = x; x = y; y = temp; } 注意定义的形式，泛型类型T需要在方法声明中（方法名的后面）指定。调用上述方法代码： int a = 1, b = 2; Swap\u003cint\u003e(ref a, ref b); //C#编译器会通过调用该方法来获取参数的类型，所以不需要把泛型类型赋予方法调用，可简化为下述语句 Swap(ref a, ref b); //上述语句的简化写法 在调用泛型方法时，C#编译器会根据传入的参数自动获取类型，因此不需要把泛型类型赋予方法调用，即Swap\u003cint\u003e中的\u003cint\u003e可以不用指定（实际编码中，可以借助VS智能编码助手进行简化，使用ctrl+.快捷键进行调用） 带约束的泛型方法 在泛型类中，泛型类型可以用where子句来限制，同样，在泛型方法，也可以使用where子句来限制泛型类型。 public interface IAccount { decimal Balance { get; } string Name { get; } } public class Account : IAccount { public Account(string name, decimal balance) { Name = name; Balance = balance; } public decimal Balance { get; private set; } public string Name { get; } } 上述定义一个简单的接口和实现的类，接着定义一个泛型方法，并且添加where子句约束，让泛型类型TAccount对应的传入参数必须实现接口IAccount。 //静态类不能被实例化 public static class Algorithms { public static decimal Accumulate\u003cTAccount\u003e(IEnumerable\u003cTAccount\u003e source) where TAccount : IAccount { decimal sum = 0; foreach (TAccount a in source) { sum += a.Balance; } return sum; } } 调用上述方法的代码： var accounts = new List\u003cAccount\u003e { new Account(\"书籍\",234), new Account(\"文具\",56), new Account(\"手机\",2300) }; //decimal amount = Algorithms.Accumulate\u003cAccount\u003e(accounts); //编译器会从方法的参数类型中自动推断出泛型类型参数，可以简化为下述代码进行调用 decimal amount = Algorithms.Accumulate(accounts); 注意：并不是所有的方法调用都不需要指定泛型参数类型，当编译器无法自动推断出类型时，需要显式的进行指定，比如带委托的泛型方法。 泛型委托 这里我们用一个简单的例子来说明一下泛型委托的调用。关于委托，后续我会单独进行总结。 public static TSum Accumulate\u003cTAccount, TSum\u003e( IEnumerable\u003cTAccount\u003e source, //方法第一个参数 Func\u003cTAccount, TSum, TSum\u003e action //方法第二个参数是一个委托 ) where TAccount : IAccount where TSum : struct { TSum sum = default(TSum); foreach (TAccount item in source) { sum = action(item, sum); } return sum; } 该方法在声明时，指定了两个泛型类型TSum和TAccount，其中一个约束是值类型，一个约束是实现接口IAccount，传入的第一个参数是IEnumerable\u003cTAccount\u003e类型的，第二个参数是一个委托。在调用该方法时，编译器不能自动推断出参数类型，需要显式的指定泛型参数类型，调用该方法代码如下： var accounts = new List\u003cAccount\u003e { new Account(\"书籍\",234), new Account(\"文具\",56), new Account(\"手机\",2300) }; decimal amount = Algorithms.Accumulate\u003cAccount, decimal\u003e( accounts, //传入的参数1 (item, sum) =\u003e sum += item.Balance //传入的参数2 ); 本文后续会随着知识的积累不断补充和更新，内容如有错误，欢迎指正。 最后一次更新时间：2018-06-28 参考资源： 《C#高级编程（第10版）》 C#编程指南——泛型 C#泛型中的协变和逆变 .NET中的泛型 作者：OctOcean 链接：https://www.jianshu.com/p/c654991806e9 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/:4:0","tags":["C#","泛型"],"title":"C#基础提升系列——C#泛型","uri":"/posts/2023/01/csharp%E6%B3%9B%E5%9E%8B/"},{"categories":["编程"],"content":"委托是类型安全的类，它定义了返回类型和参数的类型，委托类可以包含一个或多个方法的引用。可以使用lambda表达式实现参数是委托类型的方法。 ","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E5%A7%94%E6%89%98/:0:0","tags":["委托","C#"],"title":"C#基础提升系列——C#委托","uri":"/posts/2023/01/csharp%E5%A7%94%E6%89%98/"},{"categories":["编程"],"content":"委托 当需要把一个方法作为参数传递给另一个方法时，就需要使用委托。委托是一种特殊类型的对象，其特殊之处在于，我们以前定义的所有对象都包含数据，而委托包含的只是一个或多个方法的地址。 声明委托类型 声明委托类型就是告诉编译器，这种类型的委托表示的是哪种类型的方法。语法如下： delegate void delegateTypeName[\u003cT\u003e]([参数列表]); 声明委托类型时指定的参数，就是该委托类型引用的方法对应的参数。 //声明一个委托类型 private delegate void IntMethodInvoker(int x); //该委托表示的方法有两个long型参数，返回类型为double protected delegate double TwoLongsOp(double first, double second); //方法不带参数的委托，返回string public delegate string GetString(); public delegate int Comparison\u003cin T\u003e(T left, T right); （注：我们把上述定义的Comparison\u003cin T\u003e、IntMethodInvoker等统称为委托类型。） 在定义委托类型时，必须给出它要引用的方法的参数信息和返回类型等全部细节。声明委托类型的语法和声明方法的语法类似，但没有方法体，并且需要指定delegate关键字。 委托实现为派生自基类System.MulticastDelegate的类，System.MulticastDelegate有派生自基类System.Delegate。因此定义委托类型基本上是定义一个新类，所以可以在定义类的任何相同地方定义委托类型。（可以在类的内部定义委托类型，也可以在任何类的外部定义，还可以在命名空间中把委托定义为顶层对象）。 我们从“delegate”关键字开始，因为这是你在使用委托时会使用的主要方法。 编译器在你使用 delegate 关键字时生成的代码会映射到调用 Delegate 和 MulticastDelegate 类的成员的方法调用。 可以在类中、直接在命名空间中、甚至是在全局命名空间中定义委托类型。 建议不要直接在全局命名空间中声明委托类型（或其他类型）。 使用委托 定义委托类型之后，可以创建该类型的实例。 为了便于说明委托是如何将方法进行传递的，针对上述的三个委托类型，分别定义三个方法： static void ShowInt(int x) { Console.WriteLine(\"这是一个数字：\"+x); } static double ShowSum(double first,double second) { return first + second; } //最后一个委托，直接可以使用int.ToString()方法，所以此处不再定义 调用委托有两种形式，一种形式是实例化委托，并在委托的构造函数中传入要引用的方法名（注意仅仅是方法名，不需要带参数），另一种形式是使用委托推断，即不需要显式的实例化委托，而是直接指向要引用的方法名即可，编译器将会自动把委托实例解析为特定的类型。具体示例如下： public static void Run() { int a = 10; //调用委托形式一 IntMethodInvoker showIntMethod = new IntMethodInvoker(ShowInt); showIntMethod(a); //调用委托形式二 TwoLongsOp showSumMethod = ShowSum; double sum= showSumMethod.Invoke(1.23, 2.33); Console.WriteLine(\"两数之和：\"+sum); //由于int.Tostring()不是静态方法，所以需要指定实例a和方法名ToString GetString showString = a.ToString; string str=showString(); Console.WriteLine(\"使用委托调用a.ToString()方法：\"+str); } 在使用委托调用引用的方法时，委托实例名称后面的小括号需要传入要调用的方法的参数信息。实际上，给委托实例提供圆括号的调用和使用委托类的Invoke()方法完全相同。委托实例showSumMethod最终会被解析为委托类型的一个变量，所以C#编译器会用showSumMethod.Invoke()代替showSumMethod()。 委托实例可以引用任何类型的任何对象上的实例方法或静态方法，只要方法的签名匹配委托的签名即可。（所谓签名，指的是定义方法或委托时，指定的参数列表和返回类型） 简单的委托示例 后面的内容将会基于此示例进行扩展，首先定义一个简单的数字操作类MathOperations，代码如下： internal class MathOperations { //显示数值的2倍结果 public static double MultiplyByTwo(double value) { double result = value * 2; Console.WriteLine($\"{value}*2={result}\"); return result; } //显示数值的乘方结果 public static double Square(double value) { double result = value * value; Console.WriteLine($\"{value}*{value}={result}\"); return result; } } 然后定义一个引用上述方法的委托： delegate double DoubleOp(double x); 如果要使用该委托的话，对应的代码为： DoubleOp op = MathOperations.MultiplyByTwo; op(double_num);// 假设double_num为一个double类型的变量 但是很多时候，我们并不是直接这样使用，而是将委托实例作为一个方法（假设该方法为A）的参数进行传入，并且将委托实例引用的方法的参数 作为另一个参数传递给该方法A。将上述代码进行封装转换： static void ShowDouble(DoubleOp op, double double_num) { double result = op(double_num); Console.WriteLine(\"值为：\"+result); } 调用该方法： ShowDouble(MathOperations.MultiplyByTwo, 3); 使用委托一个好的思路就是，先定义普通方法，然后针对该方法定义一个引用该方法的委托，然后写出对应的委托使用代码，接着再将使用的代码用一个新定义的方法进行封装转换，在新的方法参数中，需要指明委托实例和将要为委托实例引用的方法传入的参数（也就是上述示例中的op和double_num），接着就可以在其他地方调用该方法了。 完整的实例代码如下： delegate double DoubleOp(double x); static void ProcessAndDisplayNumber(DoubleOp action, double value) { double result = action(value); Console.WriteLine($\"Value is {value },result of operation is {result}\"); } public static void Run() { DoubleOp[] operations = { MathOperations.MultiplyByTwo, MathOperations.Square }; for (int i = 0; i \u003c operations.Length; i++) { Console.WriteLine($\"Using operations[{i}]:\"); ProcessAndDisplayNumber(operations[i], 2); ProcessAndDisplayNumber(operations[i], 3); ProcessAndDisplayNumber(operations[i], 4); } } Action\u003cT\u003e、Func\u003cT\u003e、Predicate\u003cT\u003e委托 泛型Action\u003cT\u003e委托表示引用一个void返回类型的方法。 该委托类最多可以为将要引用的方法传递16种不同的参数类型。 泛型Func\u003cT\u003e委托表示引用一个带有返回值类型的方法。该委托类最多可以为将要引用的方法传递16中不同的参数类型，其中最后一个参数代表的是将要引用的方法的返回值类型。 泛型Predicate\u003cT\u003e 用于需要确定参数是否满足委托条件的情况。 也可将其写作 Func\u003cT, bool\u003e 。例如： Predicate\u003cint\u003e pre = b =\u003e b \u003e 5; 此处只对Action\u003cT\u003e和Func\u003cT\u003e做详细说明。 有了这两个委托类，在定义委托时，就可以省略delegate关键字，采用新的形式声明委托。 Func\u003cdouble,double\u003e operations = MathOperations.MultiplyByTwo; Func\u003cdouble, double\u003e[] operations2 ={ MathOperat","date":"2023-01-29","objectID":"/posts/2023/01/csharp%E5%A7%94%E6%89%98/:1:0","tags":["委托","C#"],"title":"C#基础提升系列——C#委托","uri":"/posts/2023/01/csharp%E5%A7%94%E6%89%98/"},{"categories":["编程"],"content":"有时候我们需要将一个项目上传到另一个远程仓库，那么就需要解除原来的仓库关联。 1.首先切换到项目的根目录，查看项目原有的remote。 git remote -v 2.接下来就是接触与原来远程仓库的关联。 git remote rm “remote名称” 3.取消git初始化。 rm -rf .git ","date":"2023-01-29","objectID":"/posts/2023/01/git%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%8E%9F%E6%9D%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%85%B3%E8%81%94/:0:0","tags":["Git"],"title":"Git如何解除项目原来远程仓库的关联","uri":"/posts/2023/01/git%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%8E%9F%E6%9D%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%85%B3%E8%81%94/"},{"categories":["编程"],"content":"1.字符流 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:0","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.1为什么会出现字符流【理解】 字符流的介绍 由于字节流操作中文不是特别的方便，所以Java就提供字符流 字符流 = 字节流 + 编码表 中文的字节存储方式 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？ 汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:1","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.2编码表【理解】 什么是字符集 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 常见的字符集 ASCII字符集： lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 GBXXX字符集： GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 Unicode字符集： UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用三个字节编码 其他极少使用的Unicode辅助字符，使用四字节编码 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:2","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.3字符串中的编码解码问题【应用】 相关方法 方法名 说明 byte[] getBytes() 使用平台的默认字符集将该 String编码为一系列字节 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节 String(byte[] bytes) 使用平台的默认字符集解码指定的字节数组来创建字符串 String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来创建字符串 代码演示 public class StringDemo { public static void main(String[] args) throws UnsupportedEncodingException { //定义一个字符串 String s = \"中国\"; //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67] //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67] byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6] System.out.println(Arrays.toString(bys)); //String ss = new String(bys); //String ss = new String(bys,\"UTF-8\"); String ss = new String(bys,\"GBK\"); System.out.println(ss); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:3","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.4字符流写数据【应用】 介绍 Writer: 用于写入字符流的抽象父类 FileWriter: 用于写入字符流的常用子类 构造方法 方法名 说明 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 成员方法 方法名 说明 void write(int c) 写一个字符 void write(char[] cbuf) 写入一个字符数组 void write(char[] cbuf, int off, int len) 写入字符数组的一部分 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 刷新和关闭的方法 方法名 说明 flush() 刷新流，之后还可以继续写数据 close() 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 代码演示 public class OutputStreamWriterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"myCharStream\\\\a.txt\"); //void write(int c)：写一个字符 // fw.write(97); // fw.write(98); // fw.write(99); //void writ(char[] cbuf)：写入一个字符数组 char[] chs = {'a', 'b', 'c', 'd', 'e'}; // fw.write(chs); //void write(char[] cbuf, int off, int len)：写入字符数组的一部分 // fw.write(chs, 0, chs.length); // fw.write(chs, 1, 3); //void write(String str)：写一个字符串 // fw.write(\"abcde\"); //void write(String str, int off, int len)：写一个字符串的一部分 // fw.write(\"abcde\", 0, \"abcde\".length()); fw.write(\"abcde\", 1, 3); //释放资源 fw.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:4","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.5字符流读数据【应用】 介绍 Reader: 用于读取字符流的抽象父类 FileReader: 用于读取字符流的常用子类 构造方法 方法名 说明 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader 成员方法 方法名 说明 int read() 一次读一个字符数据 int read(char[] cbuf) 一次读一个字符数组数据 代码演示 public class InputStreamReaderDemo { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(\"myCharStream\\\\b.txt\"); //int read()：一次读一个字符数据 // int ch; // while ((ch=fr.read())!=-1) { // System.out.print((char)ch); // } //int read(char[] cbuf)：一次读一个字符数组数据 char[] chs = new char[1024]; int len; while ((len = fr.read(chs)) != -1) { System.out.print(new String(chs, 0, len)); } //释放资源 fr.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:5","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.6字符流用户注册案例【应用】 案例需求 将键盘录入的用户名和密码保存到本地实现永久化存储 实现步骤 获取用户输入的用户名和密码 将用户输入的用户名和密码写入到本地文件中 关流,释放资源 代码实现 public class CharStreamDemo8 { public static void main(String[] args) throws IOException { //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储 //要求：用户名独占一行，密码独占一行 //分析： //1，实现键盘录入，把用户名和密码录入进来 Scanner sc = new Scanner(System.in); System.out.println(\"请录入用户名\"); String username = sc.next(); System.out.println(\"请录入密码\"); String password = sc.next(); //2.分别把用户名和密码写到本地文件。 FileWriter fw = new FileWriter(\"charstream\\\\a.txt\"); //将用户名和密码写到文件中 fw.write(username); //表示写出一个回车换行符 windows \\r\\n MacOS \\r Linux \\n fw.write(\"\\r\\n\"); fw.write(password); //刷新流 fw.flush(); //3.关流,释放资源 fw.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:6","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.7字符缓冲流【应用】 字符缓冲流介绍 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途 构造方法 方法名 说明 BufferedWriter(Writer out) 创建字符缓冲输出流对象 BufferedReader(Reader in) 创建字符缓冲输入流对象 代码演示 public class BufferedStreamDemo01 { public static void main(String[] args) throws IOException { //BufferedWriter(Writer out) BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); bw.write(\"hello\\r\\n\"); bw.write(\"world\\r\\n\"); bw.close(); //BufferedReader(Reader in) BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); //一次读取一个字符数据 // int ch; // while ((ch=br.read())!=-1) { // System.out.print((char)ch); // } //一次读取一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) { System.out.print(new String(chs,0,len)); } br.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:7","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.8字符缓冲流特有功能【应用】 方法介绍 BufferedWriter： 方法名 说明 void newLine() 写一行行分隔符，行分隔符字符串由系统属性定义 BufferedReader: 方法名 说明 String readLine() 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null 代码演示 public class BufferedStreamDemo02 { public static void main(String[] args) throws IOException { //创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); //写数据 for (int i = 0; i \u003c 10; i++) { bw.write(\"hello\" + i); //bw.write(\"\\r\\n\"); bw.newLine(); bw.flush(); } //释放资源 bw.close(); //创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); String line; while ((line=br.readLine())!=null) { System.out.println(line); } br.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:8","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.9字符缓冲流操作文件中数据排序案例【应用】 案例需求 使用字符缓冲流读取文件中的数据，排序后再次写到本地文件 实现步骤 将文件中的数据读取到程序中 对读取到的数据进行处理 将处理后的数据添加到集合中 对集合中的数据进行排序 将排序后的集合中的数据写入到文件中 代码实现 public class CharStreamDemo14 { public static void main(String[] args) throws IOException { //需求：读取文件中的数据，排序后再次写到本地文件 //分析： //1.要把文件中的数据读取进来。 BufferedReader br = new BufferedReader(new FileReader(\"charstream\\\\sort.txt\")); //输出流一定不能写在这里，因为会清空文件中的内容 //BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); String line = br.readLine(); System.out.println(\"读取到的数据为\" + line); br.close(); //2.按照空格进行切割 String[] split = line.split(\" \");//9 1 2 5 3 10 4 6 7 8 //3.把字符串类型的数组变成int类型 int [] arr = new int[split.length]; //遍历split数组，可以进行类型转换。 for (int i = 0; i \u003c split.length; i++) { String smallStr = split[i]; //类型转换 int number = Integer.parseInt(smallStr); //把转换后的结果存入到arr中 arr[i] = number; } //4.排序 Arrays.sort(arr); System.out.println(Arrays.toString(arr)); //5.把排序之后结果写回到本地 1 2 3 4... BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); //写出 for (int i = 0; i \u003c arr.length; i++) { bw.write(arr[i] + \" \"); bw.flush(); } //释放资源 bw.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:9","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.10IO流小结【理解】 IO流小结 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:1:10","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"2.转换流 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:2:0","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"2.1字符流中和编码解码问题相关的两个类【理解】 InputStreamReader：是从字节流到字符流的桥梁,父类是Reader ​ 它读取字节，并使用指定的编码将其解码为字符 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer ​ 是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:2:1","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"2.2转换流读写数据【应用】 构造方法 方法名 说明 InputStreamReader(InputStream in) 使用默认字符编码创建InputStreamReader对象 InputStreamReader(InputStream in,String chatset) 使用指定的字符编码创建InputStreamReader对象 OutputStreamWriter(OutputStream out) 使用默认字符编码创建OutputStreamWriter对象 OutputStreamWriter(OutputStream out,String charset) 使用指定的字符编码创建OutputStreamWriter对象 代码演示 public class ConversionStreamDemo { public static void main(String[] args) throws IOException { //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); osw.write(\"中国\"); osw.close(); //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\")); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); //一次读取一个字符数据 int ch; while ((ch=isr.read())!=-1) { System.out.print((char)ch); } isr.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:2:2","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"3.对象操作流 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:3:0","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"3.1对象序列化流【应用】 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 方法名 说明 ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream 序列化对象的方法 方法名 说明 void writeObject(Object obj) 将指定的对象写入ObjectOutputStream 示例代码 学生类 public class Student implements Serializable { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class ObjectOutputStreamDemo { public static void main(String[] args) throws IOException { //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); //创建对象 Student s = new Student(\"佟丽娅\",30); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); } } 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:3:1","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"3.2对象反序列化流【应用】 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 方法名 说明 ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream 反序列化对象的方法 方法名 说明 Object readObject() 从ObjectInputStream读取一个对象 示例代码 public class ObjectInputStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:3:2","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"3.3serialVersionUID\u0026transient【应用】 serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 public class Student implements Serializable { private static final long serialVersionUID = 42L; private String name; // private int age; private transient int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } // @Override // public String toString() { // return \"Student{\" + // \"name='\" + name + '\\'' + // \", age=\" + age + // '}'; // } } 测试类 public class ObjectStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // write(); read(); } //反序列化 private static void read() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } //序列化 private static void write() throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); Student s = new Student(\"佟丽娅\", 30); oos.writeObject(s); oos.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:3:3","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"3.4对象操作流练习【应用】 案例需求 创建多个学生类对象写到文件中,再次读取到内存中 实现步骤 创建序列化流对象 创建多个学生对象 将学生对象添加到集合中 将集合对象序列化到文件中 创建反序列化流对象 将文件中的对象数据,读取到内存中 代码实现 学生类 public class Student implements Serializable{ private static final long serialVersionUID = 2L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 测试类 public class Demo03 { /** * read(): * 读取到文件末尾返回值是 -1 * readLine(): * 读取到文件的末尾返回值 null * readObject(): * 读取到文件的末尾 直接抛出异常 * 如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常 * 建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中 */ public static void main(String[] args) throws Exception { /*// 序列化 //1.创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myCode\\\\oos.txt\")); ArrayList\u003cStudent\u003e arrayList = new ArrayList\u003c\u003e(); //2.创建多个学生对象 Student s = new Student(\"佟丽娅\",30); Student s01 = new Student(\"佟丽娅\",30); //3.将学生对象添加到集合中 arrayList.add(s); arrayList.add(s01); //4.将集合对象序列化到文件中 oos.writeObject(arrayList); oos.close();*/ // 反序列化 //5.创建反序列化流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myCode\\\\oos.txt\")); //6.将文件中的对象数据,读取到内存中 Object obj = ois.readObject(); ArrayList\u003cStudent\u003e arrayList = (ArrayList\u003cStudent\u003e)obj; ois.close(); for (Student s : arrayList) { System.out.println(s.getName() + \",\" + s.getAge()); } } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:3:4","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"4.Properties集合 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:4:0","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"4.1Properties作为Map集合的使用【应用】 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 public class PropertiesDemo01 { public static void main(String[] args) { //创建集合对象 // Properties\u003cString,String\u003e prop = new Properties\u003cString,String\u003e(); //错误 Properties prop = new Properties(); //存储元素 prop.put(\"itheima001\", \"佟丽娅\"); prop.put(\"itheima002\", \"赵丽颖\"); prop.put(\"itheima003\", \"刘诗诗\"); //遍历集合 Set\u003cObject\u003e keySet = prop.keySet(); for (Object key : keySet) { Object value = prop.get(key); System.out.println(key + \",\" + value); } } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:4:1","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"4.2Properties作为Map集合的特有方法【应用】 特有方法 方法名 说明 Object setProperty(String key, String value) 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put String getProperty(String key) 使用此属性列表中指定的键搜索属性 Set stringPropertyNames() 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 示例代码 public class PropertiesDemo02 { public static void main(String[] args) { //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型 prop.setProperty(\"itheima001\", \"佟丽娅\"); prop.setProperty(\"itheima002\", \"赵丽颖\"); prop.setProperty(\"itheima003\", \"刘诗诗\"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性 // System.out.println(prop.getProperty(\"itheima001\")); // System.out.println(prop.getProperty(\"itheima0011\")); // System.out.println(prop); //Set\u003cString\u003e stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set\u003cString\u003e names = prop.stringPropertyNames(); for (String key : names) { // System.out.println(key); String value = prop.getProperty(key); System.out.println(key + \",\" + value); } } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:4:2","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"4.3Properties和IO流相结合的方法【应用】 和IO流结合的方法 方法名 说明 void load(Reader reader) 从输入字符流读取属性列表（键和元素对） void store(Writer writer, String comments) 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 示例代码 public class PropertiesDemo03 { public static void main(String[] args) throws IOException { //把集合中的数据保存到文件 // myStore(); //把文件中的数据加载到集合 myLoad(); } private static void myLoad() throws IOException { Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\"); prop.load(fr); fr.close(); System.out.println(prop); } private static void myStore() throws IOException { Properties prop = new Properties(); prop.setProperty(\"itheima001\",\"佟丽娅\"); prop.setProperty(\"itheima002\",\"赵丽颖\"); prop.setProperty(\"itheima003\",\"刘诗诗\"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\"); prop.store(fw,null); fw.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:4:3","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"4.4Properties集合练习【应用】 案例需求 在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件 实现步骤 创建Properties集合,将本地文件中的数据加载到集合中 获取集合中的键值对数据,封装到学生对象中 创建序列化流对象,将学生对象序列化到本地文件中 代码实现 学生类 public class Student implements Serializable { private static final long serialVersionUID = 1L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class Test { public static void main(String[] args) throws IOException { //1.创建Properties集合,将本地文件中的数据加载到集合中 Properties prop = new Properties(); FileReader fr = new FileReader(\"prop.properties\"); prop.load(fr); fr.close(); //2.获取集合中的键值对数据,封装到学生对象中 String name = prop.getProperty(\"name\"); int age = Integer.parseInt(prop.getProperty(\"age\")); Student s = new Student(name,age); //3.创建序列化流对象,将学生对象序列化到本地文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\")); oos.writeObject(s); oos.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8102/:4:4","tags":["Java","IO流"],"title":"IO流02","uri":"/posts/2023/01/io%E6%B5%8102/"},{"categories":["编程"],"content":"1.File类 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:0","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 方法名 说明 File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 示例代码 public class FileDemo01 { public static void main(String[] args) { //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1); //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例 File f2 = new File(\"E:\\\\itcast\",\"java.txt\"); System.out.println(f2); //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例 File f3 = new File(\"E:\\\\itcast\"); File f4 = new File(f3,\"java.txt\"); System.out.println(f4); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:1","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.2绝对路径和相对路径【理解】 绝对路径 是一个完整的路径,从盘符开始 相对路径 是一个简化的路径,相对当前项目下的路径 示例代码 public class FileDemo02 { public static void main(String[] args) { // 是一个完整的路径,从盘符开始 File file1 = new File(\"D:\\\\itheima\\\\a.txt\"); // 是一个简化的路径,从当前项目根目录开始 File file2 = new File(\"a.txt\"); File file3 = new File(\"模块名\\\\a.txt\"); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:2","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.3File类创建功能【应用】 方法分类 方法名 说明 public boolean createNewFile() 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir() 创建由此抽象路径名命名的目录 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 示例代码 public class FileDemo02 { public static void main(String[] args) throws IOException { //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1.createNewFile()); System.out.println(\"--------\"); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(\"E:\\\\itcast\\\\JavaSE\"); System.out.println(f2.mkdir()); System.out.println(\"--------\"); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\"); // System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(\"--------\"); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(\"E:\\\\itcast\\\\javase.txt\"); // System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:3","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.4File类删除功能【应用】 方法分类 方法名 说明 public boolean delete() 删除由此抽象路径名表示的文件或目录 示例代码 public class FileDemo03 { public static void main(String[] args) throws IOException { // File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(\"myFile\\\\java.txt\"); // System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(\"--------\"); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(\"myFile\\\\itcast\"); // System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(\"--------\"); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(\"myFile\\\\itcast\"); // System.out.println(f3.mkdir()); File f4 = new File(\"myFile\\\\itcast\\\\java.txt\"); // System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:4","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.5File类判断和获取功能【应用】 判断功能 方法名 说明 public boolean isDirectory() 测试此抽象路径名表示的File是否为目录 public boolean isFile() 测试此抽象路径名表示的File是否为文件 public boolean exists() 测试此抽象路径名表示的File是否存在 获取功能 方法名 说明 public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 public String getPath() 将此抽象路径名转换为路径名字符串 public String getName() 返回由此抽象路径名表示的文件或目录的名称 public File[] listFiles() 返回此抽象路径名表示的目录中的文件和目录的File对象数组 示例代码 public class FileDemo04 { public static void main(String[] args) { //创建一个File对象 File f = new File(\"myFile\\\\java.txt\"); // public boolean isDirectory()：测试此抽象路径名表示的File是否为目录 // public boolean isFile()：测试此抽象路径名表示的File是否为文件 // public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists()); // public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串 // public String getPath()：将此抽象路径名转换为路径名字符串 // public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(\"--------\"); // public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(\"E:\\\\itcast\"); File[] fileArray = f2.listFiles(); for(File file : fileArray) { // System.out.println(file); // System.out.println(file.getName()); if(file.isFile()) { System.out.println(file.getName()); } } } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:5","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.6File类练习一【应用】 案例需求 在当前模块下的aaa文件夹中创建一个a.txt文件 实现步骤 创建File对象,指向aaa文件夹 判断aaa文件夹是否存在,如果不存在则创建 创建File对象,指向aaa文件夹下的a.txt文件 创建这个文件 代码实现 public class Test1 { public static void main(String[] args) throws IOException { //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件 /* File file = new File(\"filemodule\\\\aaa\\\\a.txt\"); file.createNewFile();*/ //注意点:文件所在的文件夹必须要存在. //1.创建File对象,指向aaa文件夹 File file = new File(\"filemodule\\\\aaa\"); //2.判断aaa文件夹是否存在,如果不存在则创建 if(!file.exists()){ //如果文件夹不存在,就创建出来 file.mkdirs(); } //3.创建File对象,指向aaa文件夹下的a.txt文件 File newFile = new File(file,\"a.txt\"); //4.创建这个文件 newFile.createNewFile(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:6","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.7File类练习二【应用】 案例需求 删除一个多级文件夹 实现步骤 定义一个方法,接收一个File对象 遍历这个File对象,获取它下边的每个文件和文件夹对象 判断当前遍历到的File对象是文件还是文件夹 如果是文件,直接删除 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 代码实现 public class Test2 { public static void main(String[] args) { //练习二：删除一个多级文件夹 //delete方法 //只能删除文件和空文件夹. //如果现在要删除一个有内容的文件夹? //先删掉这个文件夹里面所有的内容. //最后再删除这个文件夹 File src = new File(\"C:\\\\Users\\\\apple\\\\Desktop\\\\src\"); deleteDir(src); } //1.定义一个方法,接收一个File对象 private static void deleteDir(File src) { //先删掉这个文件夹里面所有的内容. //递归 方法在方法体中自己调用自己. //注意: 可以解决所有文件夹和递归相结合的题目 //2.遍历这个File对象,获取它下边的每个文件和文件夹对象 File[] files = src.listFiles(); //3.判断当前遍历到的File对象是文件还是文件夹 for (File file : files) { //4.如果是文件,直接删除 if(file.isFile()){ file.delete(); }else{ //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象 } } //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 src.delete(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:7","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.8File类练习三【应用】 案例需求 统计一个文件夹中每种文件的个数并打印 打印格式如下： txt:3个 doc:4个 jpg:6个 … 实现步骤 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 遍历File对象,获取它下边的每一个文件和文件夹对象 判断当前File对象是文件还是文件夹 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 没出现过,将这种类型文件的后缀名存入集合中,次数存1 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象 代码实现 public class Test3 { public static void main(String[] args) { //统计一个文件夹中,每种文件出现的次数. //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件 //利用map集合进行数据统计,键 --- 文件后缀名 值 ---- 次数 File file = new File(\"filemodule\"); HashMap\u003cString, Integer\u003e hm = new HashMap\u003c\u003e(); getCount(hm, file); System.out.println(hm); } //1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 private static void getCount(HashMap\u003cString, Integer\u003e hm, File file) { //2.遍历File对象,获取它下边的每一个文件和文件夹对象 File[] files = file.listFiles(); for (File f : files) { //3.判断当前File对象是文件还是文件夹 if(f.isFile()){ //如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 String fileName = f.getName(); String[] fileNameArr = fileName.split(\"\\\\.\"); if(fileNameArr.length == 2){ String fileEndName = fileNameArr[1]; if(hm.containsKey(fileEndName)){ //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 Integer count = hm.get(fileEndName); //这种文件又出现了一次. count++; //把已经出现的次数给覆盖掉. hm.put(fileEndName,count); }else{ // 没出现过,将这种类型文件的后缀名存入集合中,次数存1 hm.put(fileEndName,1); } } }else{ //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现 getCount(hm,f); } } } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:1:8","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.字节流 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:0","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.1 IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输 IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件,优先使用字符流 如果操作的是图片、视频、音频等二进制文件,优先使用字节流 如果不确定文件类型,优先使用字节流.字节流是万能的流 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:1","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.2字节流写数据【应用】 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 public class FileOutputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输出流对象 /* 注意点: 1.如果文件不存在,会帮我们创建 2.如果文件存在,会把文件清空 */ //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //void write(int b)：将指定的字节写入此文件输出流 fos.write(97); // fos.write(57); // fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:2","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.3字节流写数据的三种方式【应用】 写数据的方法分类 方法名 说明 void write(int b) 将指定的字节写入此文件输出流 一次写一个字节数据 void write(byte[] b) 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 void write(byte[] b, int off, int len) 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 示例代码 public class FileOutputStreamDemo02 { public static void main(String[] args) throws IOException { //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件 // FileOutputStream fos = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //void write(int b)：将指定的字节写入此文件输出流 // fos.write(97); // fos.write(98); // fos.write(99); // fos.write(100); // fos.write(101); // void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流 // byte[] bys = {97, 98, 99, 100, 101}; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = \"abcde\".getBytes(); // fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 // fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:3","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.4字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 public class FileOutputStreamDemo03 { public static void main(String[] args) throws IOException { //创建字节输出流对象 // FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\",true); //写数据 for (int i = 0; i \u003c 10; i++) { fos.write(\"hello\".getBytes()); fos.write(\"\\r\\n\".getBytes()); } //释放资源 fos.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:4","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.5字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally try{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; }finally{ 执行所有清除操作; } finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 public class FileOutputStreamDemo04 { public static void main(String[] args) { //加入finally来实现释放资源 FileOutputStream fos = null; try { fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); fos.write(\"hello\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { if(fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:5","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.6字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 示例代码 public class FileInputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) { System.out.print((char)by); } //释放资源 fis.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:6","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.7字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” (文件可以是任意文件) 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt — 读数据 — InputStream — FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream 代码实现 public class CopyTxtDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\"); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) { fos.write(by); } //释放资源 fos.close(); fis.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:7","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.8字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 示例代码 public class FileInputStreamDemo02 { public static void main(String[] args) throws IOException { //创建字节输入流对象 FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); byte[] bys = new byte[1024]; //1024及其整数倍 int len; //循环读取 while ((len=fis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 fis.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:8","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"2.9字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” (文件可以是任意文件去) 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 public class CopyJpgDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\"); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) { fos.write(bys,0,len); } //释放资源 fos.close(); fis.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:2:9","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"3.字节缓冲流 ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:3:0","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"3.1字节缓冲流构造方法【应用】 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节 构造方法： 方法名 说明 BufferedOutputStream(OutputStream out) 创建字节缓冲输出流对象 BufferedInputStream(InputStream in) 创建字节缓冲输入流对象 示例代码 public class BufferStreamDemo { public static void main(String[] args) throws IOException { //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\bos.txt\")); //写数据 bos.write(\"hello\\r\\n\".getBytes()); bos.write(\"world\\r\\n\".getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"myByteStream\\\\bos.txt\")); //一次读取一个字节数据 // int by; // while ((by=bis.read())!=-1) { // System.out.print((char)by); // } //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 bis.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:3:1","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"3.2字节缓冲流复制视频【应用】 案例需求 把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制视频 释放资源 代码实现 public class CopyAviDemo { public static void main(String[] args) throws IOException { //复制视频 // method1(); method2(); } //字节缓冲流一次读写一个字节数组 public static void method2() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { bos.write(bys,0,len); } bos.close(); bis.close(); } //字节缓冲流一次读写一个字节 public static void method1() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); int by; while ((by=bis.read())!=-1) { bos.write(by); } bos.close(); bis.close(); } } ","date":"2023-01-29","objectID":"/posts/2023/01/io%E6%B5%8101/:3:2","tags":["Java","IO流"],"title":"IO流01","uri":"/posts/2023/01/io%E6%B5%8101/"},{"categories":["编程"],"content":"1.时间日期类 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:1:0","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"1.1 Date类（应用） 计算机中时间原点 1970年1月1日 00:00:00 时间换算单位 1秒 = 1000毫秒 Date类概述 Date 代表了一个特定的时间，精确到毫秒 Date类构造方法 方法名 说明 public Date() 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 public Date(long date) 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 示例代码 public class DateDemo01 { public static void main(String[] args) { //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 Date d1 = new Date(); System.out.println(d1); //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 long date = 1000*60*60; Date d2 = new Date(date); System.out.println(d2); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:1:1","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"1.2 Date类常用方法（应用） 常用方法 方法名 说明 public long getTime() 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 public void setTime(long time) 设置时间，给的是毫秒值 示例代码 public class DateDemo02 { public static void main(String[] args) { //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 // System.out.println(d.getTime()); // System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + \"年\"); //public void setTime(long time):设置时间，给的是毫秒值 // long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:1:2","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"1.3 SimpleDateFormat类（应用） SimpleDateFormat类概述 ​ SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。 ​ 我们重点学习日期格式化和解析 SimpleDateFormat类构造方法 方法名 说明 public SimpleDateFormat() 构造一个SimpleDateFormat，使用默认模式和日期格式 public SimpleDateFormat(String pattern) 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 SimpleDateFormat类的常用方法 格式化(从Date到String) public final String format(Date date)：将日期格式化成日期/时间字符串 解析(从String到Date) public Date parse(String source)：从给定字符串的开始解析文本以生成日期 示例代码 public class SimpleDateFormatDemo { public static void main(String[] args) throws ParseException { //格式化：从 Date 到 String Date d = new Date(); // SimpleDateFormat sdf = new SimpleDateFormat(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String s = sdf.format(d); System.out.println(s); System.out.println(\"--------\"); //从 String 到 Date String ss = \"2048-08-09 11:11:11\"; //ParseException SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date dd = sdf2.parse(ss); System.out.println(dd); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:1:3","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"1.4 时间日期类练习 (应用) 需求 秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动 实现步骤 判断下单时间是否在开始到结束的范围内 把字符串形式的时间变成毫秒值 代码实现 public class DateDemo5 { public static void main(String[] args) throws ParseException { //开始时间：2020年11月11日 0:0:0 //结束时间：2020年11月11日 0:10:0 //小贾2020年11月11日 0:03:47 //小皮2020年11月11日 0:10:11 //1.判断两位同学的下单时间是否在范围之内就可以了。 //2.要把每一个时间都换算成毫秒值。 String start = \"2020年11月11日 0:0:0\"; String end = \"2020年11月11日 0:10:0\"; String jia = \"2020年11月11日 0:03:47\"; String pi = \"2020年11月11日 0:10:11\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); long startTime = sdf.parse(start).getTime(); long endTime = sdf.parse(end).getTime(); // System.out.println(startTime); // System.out.println(endTime); long jiaTime = sdf.parse(jia).getTime(); long piTime = sdf.parse(pi).getTime(); if(jiaTime \u003e= startTime \u0026\u0026 jiaTime \u003c= endTime){ System.out.println(\"小贾同学参加上了秒杀活动\"); }else{ System.out.println(\"小贾同学没有参加上秒杀活动\"); } System.out.println(\"------------------------\"); if(piTime \u003e= startTime \u0026\u0026 piTime \u003c= endTime){ System.out.println(\"小皮同学参加上了秒杀活动\"); }else{ System.out.println(\"小皮同学没有参加上秒杀活动\"); } } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:1:4","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.JDK8时间日期类 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:0","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.1 JDK8新增日期类 (理解) LocalDate 表示日期（年月日） LocalTime 表示时间（时分秒） LocalDateTime 表示时间+ 日期 （年月日时分秒） ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:1","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.2 LocalDateTime创建方法 (应用) 方法说明 方法名 说明 public static LocalDateTime now() 获取当前系统时间 public static LocalDateTime of (年, 月 , 日, 时, 分, 秒) 使用指定年月日和时分秒初始化一个LocalDateTime对象 示例代码 public class JDK8DateDemo2 { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); System.out.println(now); LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11); System.out.println(localDateTime); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:2","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.3 LocalDateTime获取方法 (应用) 方法说明 方法名 说明 public int getYear() 获取年 public int getMonthValue() 获取月份（1-12） public int getDayOfMonth() 获取月份中的第几天（1-31） public int getDayOfYear() 获取一年中的第几天（1-366） public DayOfWeek getDayOfWeek() 获取星期 public int getMinute() 获取分钟 public int getHour() 获取小时 示例代码 public class JDK8DateDemo3 { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20); //public int getYear() 获取年 int year = localDateTime.getYear(); System.out.println(\"年为\" +year); //public int getMonthValue() 获取月份（1-12） int month = localDateTime.getMonthValue(); System.out.println(\"月份为\" + month); Month month1 = localDateTime.getMonth(); // System.out.println(month1); //public int getDayOfMonth() 获取月份中的第几天（1-31） int day = localDateTime.getDayOfMonth(); System.out.println(\"日期为\" + day); //public int getDayOfYear() 获取一年中的第几天（1-366） int dayOfYear = localDateTime.getDayOfYear(); System.out.println(\"这是一年中的第\" + dayOfYear + \"天\"); //public DayOfWeek getDayOfWeek()获取星期 DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); System.out.println(\"星期为\" + dayOfWeek); //public int getMinute() 获取分钟 int minute = localDateTime.getMinute(); System.out.println(\"分钟为\" + minute); //public int getHour() 获取小时 int hour = localDateTime.getHour(); System.out.println(\"小时为\" + hour); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:3","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.4 LocalDateTime转换方法 (应用) 方法说明 方法名 说明 public LocalDate toLocalDate () 转换成为一个LocalDate对象 public LocalTime toLocalTime () 转换成为一个LocalTime对象 示例代码 public class JDK8DateDemo4 { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12); //public LocalDate toLocalDate () 转换成为一个LocalDate对象 LocalDate localDate = localDateTime.toLocalDate(); System.out.println(localDate); //public LocalTime toLocalTime () 转换成为一个LocalTime对象 LocalTime localTime = localDateTime.toLocalTime(); System.out.println(localTime); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:4","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.5 LocalDateTime格式化和解析 (应用) 方法说明 方法名 说明 public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 public LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 public static DateTimeFormatter ofPattern(String pattern) 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 示例代码 public class JDK8DateDemo5 { public static void main(String[] args) { //method1(); //method2(); } private static void method2() { //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 String s = \"2020年11月12日 13:14:15\"; DateTimeFormatter pattern = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); LocalDateTime parse = LocalDateTime.parse(s, pattern); System.out.println(parse); } private static void method1() { LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15); System.out.println(localDateTime); //public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 DateTimeFormatter pattern = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); String s = localDateTime.format(pattern); System.out.println(s); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:5","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.6 LocalDateTime增加或者减少时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime plusYears (long years) 添加或者减去年 public LocalDateTime plusMonths(long months) 添加或者减去月 public LocalDateTime plusDays(long days) 添加或者减去日 public LocalDateTime plusHours(long hours) 添加或者减去时 public LocalDateTime plusMinutes(long minutes) 添加或者减去分 public LocalDateTime plusSeconds(long seconds) 添加或者减去秒 public LocalDateTime plusWeeks(long weeks) 添加或者减去周 示例代码 /** * JDK8 时间类添加或者减去时间的方法 */ public class JDK8DateDemo6 { public static void main(String[] args) { //public LocalDateTime plusYears (long years) 添加或者减去年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.plusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.plusYears(-1); System.out.println(newLocalDateTime); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:6","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.7 LocalDateTime减少或者增加时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime minusYears (long years) 减去或者添加年 public LocalDateTime minusMonths(long months) 减去或者添加月 public LocalDateTime minusDays(long days) 减去或者添加日 public LocalDateTime minusHours(long hours) 减去或者添加时 public LocalDateTime minusMinutes(long minutes) 减去或者添加分 public LocalDateTime minusSeconds(long seconds) 减去或者添加秒 public LocalDateTime minusWeeks(long weeks) 减去或者添加周 示例代码 /** * JDK8 时间类减少或者添加时间的方法 */ public class JDK8DateDemo7 { public static void main(String[] args) { //public LocalDateTime minusYears (long years) 减去或者添加年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.minusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.minusYears(-1); System.out.println(newLocalDateTime); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:7","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.8 LocalDateTime修改方法 (应用) 方法说明 方法名 说明 public LocalDateTime withYear(int year) 直接修改年 public LocalDateTime withMonth(int month) 直接修改月 public LocalDateTime withDayOfMonth(int dayofmonth) 直接修改日期(一个月中的第几天) public LocalDateTime withDayOfYear(int dayOfYear) 直接修改日期(一年中的第几天) public LocalDateTime withHour(int hour) 直接修改小时 public LocalDateTime withMinute(int minute) 直接修改分钟 public LocalDateTime withSecond(int second) 直接修改秒 示例代码 /** * JDK8 时间类修改时间 */ public class JDK8DateDemo8 { public static void main(String[] args) { //public LocalDateTime withYear(int year) 修改年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); // LocalDateTime newLocalDateTime = localDateTime.withYear(2048); // System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.withMonth(20); System.out.println(newLocalDateTime); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:8","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.9 Period (应用) 方法说明 方法名 说明 public static Period between(开始时间,结束时间) 计算两个“时间\"的间隔 public int getYears() 获得这段时间的年数 public int getMonths() 获得此期间的总月数 public int getDays() 获得此期间的天数 public long toTotalMonths() 获取此期间的总月数 示例代码 /** * 计算两个时间的间隔 */ public class JDK8DateDemo9 { public static void main(String[] args) { //public static Period between(开始时间,结束时间) 计算两个\"时间\"的间隔 LocalDate localDate1 = LocalDate.of(2020, 1, 1); LocalDate localDate2 = LocalDate.of(2048, 12, 12); Period period = Period.between(localDate1, localDate2); System.out.println(period);//P28Y11M11D //public int getYears() 获得这段时间的年数 System.out.println(period.getYears());//28 //public int getMonths() 获得此期间的月数 System.out.println(period.getMonths());//11 //public int getDays() 获得此期间的天数 System.out.println(period.getDays());//11 //public long toTotalMonths() 获取此期间的总月数 System.out.println(period.toTotalMonths());//347 } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:9","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"2.10 Duration (应用) 方法说明 方法名 说明 public static Durationbetween(开始时间,结束时间) 计算两个“时间\"的间隔 public long toSeconds() 获得此时间间隔的秒 public int toMillis() 获得此时间间隔的毫秒 public int toNanos() 获得此时间间隔的纳秒 示例代码 /** * 计算两个时间的间隔 */ public class JDK8DateDemo10 { public static void main(String[] args) { //public static Duration between(开始时间,结束时间) 计算两个“时间\"的间隔 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15); LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13); Duration duration = Duration.between(localDateTime1, localDateTime2); System.out.println(duration);//PT21H57M58S //public long toSeconds() 获得此时间间隔的秒 System.out.println(duration.toSeconds());//79078 //public int toMillis() 获得此时间间隔的毫秒 System.out.println(duration.toMillis());//79078000 //public int toNanos() 获得此时间间隔的纳秒 System.out.println(duration.toNanos());//79078000000000 } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:2:10","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.异常 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:0","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.1 异常（记忆） 异常的概述 ​ 异常就是程序出现了不正常的情况 异常的体系结构 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:1","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.2 编译时异常和运行时异常的区别（记忆） 编译时异常 都是Exception类及其子类 必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常 都是RuntimeException类及其子类 无需显示处理，也可以和编译时异常一样处理 图示 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:2","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.3 JVM默认处理异常的方式（理解） 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤： 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台 程序停止执行 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:3","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.4 查看异常信息 (理解) 控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置 我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:4","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.5 throws方式处理异常（应用） 定义格式 public void 方法() throws 异常类名 { } 示例代码 public class ExceptionDemo { public static void main(String[] args) throws ParseException{ System.out.println(\"开始\"); // method(); method2(); System.out.println(\"结束\"); } //编译时异常 public static void method2() throws ParseException { String s = \"2048-08-09\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date d = sdf.parse(s); System.out.println(d); } //运行时异常 public static void method() throws ArrayIndexOutOfBoundsException { int[] arr = {1, 2, 3}; System.out.println(arr[3]); } } 注意事项 这个throws格式是跟在方法的括号后面的 编译时异常必须要进行处理，两种处理方案：try…catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:5","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.6 throw抛出异常 (应用) 格式 throw new 异常(); 注意 这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了 throws和throw的区别 throws throw 用在方法声明后面，跟的是异常类名 用在方法体内，跟的是异常对象名 表示声明异常，调用该方法有可能会出现这样的异常 表示手动抛出异常对象，由方法体内的语句处理 示例代码 public class ExceptionDemo8 { public static void main(String[] args) { //int [] arr = {1,2,3,4,5}; int [] arr = null; printArr(arr);//就会 接收到一个异常. //我们还需要自己处理一下异常. } private static void printArr(int[] arr) { if(arr == null){ //调用者知道成功打印了吗? //System.out.println(\"参数不能为null\"); throw new NullPointerException(); //当参数为null的时候 //手动创建了一个异常对象,抛给了调用者,产生了一个异常 }else{ for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } } } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:6","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.7 try-catch方式处理异常（应用） 定义格式 try { 可能出现异常的代码; } catch(异常类名 变量名) { 异常的处理代码; } 执行流程 程序从 try 里面的代码开始执行 出现异常，就会跳转到对应的 catch 里面去执行 执行完毕之后，程序还可以继续往下执行 示例代码 public class ExceptionDemo01 { public static void main(String[] args) { System.out.println(\"开始\"); method(); System.out.println(\"结束\"); } public static void method() { try { int[] arr = {1, 2, 3}; System.out.println(arr[3]); System.out.println(\"这里能够访问到吗\"); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"你访问的数组索引不存在，请回去修改为正确的索引\"); } } } 注意 如果 try 中没有遇到问题，怎么执行？ 会把try中所有的代码全部执行完毕,不会执行catch里面的代码 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？ 那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了 当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码 如果出现的问题没有被捕获，那么程序如何运行？ 那么try…catch就相当于没有写.那么也就是自己没有处理. 默认交给虚拟机处理. 同时有可能出现多个异常怎么处理？ 出现多个异常,那么就写多个catch就可以了. 注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面 ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:7","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.8 Throwable成员方法（应用） 常用方法 方法名 说明 public String getMessage() 返回此 throwable 的详细消息字符串 public String toString() 返回此可抛出的简短描述 public void printStackTrace() 把异常的错误信息输出在控制台 示例代码 public class ExceptionDemo02 { public static void main(String[] args) { System.out.println(\"开始\"); method(); System.out.println(\"结束\"); } public static void method() { try { int[] arr = {1, 2, 3}; System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException(); System.out.println(\"这里能够访问到吗\"); } catch (ArrayIndexOutOfBoundsException e) { //new ArrayIndexOutOfBoundsException(); // e.printStackTrace(); //public String getMessage():返回此 throwable 的详细消息字符串 // System.out.println(e.getMessage()); //Index 3 out of bounds for length 3 //public String toString():返回此可抛出的简短描述 // System.out.println(e.toString()); //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 //public void printStackTrace():把异常的错误信息输出在控制台 e.printStackTrace(); // java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 // at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18) // at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11) } } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:8","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.9 异常的练习 (应用) 需求 键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止 实现步骤 创建学生对象 键盘录入姓名和年龄，并赋值给学生对象 如果是非法数据就再次录入 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { if(age \u003e= 18 \u0026\u0026 age \u003c= 25){ this.age = age; }else{ //当年龄不合法时,产生一个异常 throw new RuntimeException(\"年龄超出了范围\"); } } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class ExceptionDemo12 { public static void main(String[] args) { // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true){ System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try { int age = Integer.parseInt(ageStr); s.setAge(age); break; } catch (NumberFormatException e) { System.out.println(\"请输入一个整数\"); continue; } catch (AgeOutOfBoundsException e) { System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; } /*if(age \u003e= 18 \u0026\u0026 age \u003c=25){ s.setAge(age); break; }else{ System.out.println(\"请输入符合要求的年龄\"); continue; }*/ } System.out.println(s); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:9","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"3.10 自定义异常（应用） 自定义异常概述 当Java中提供的异常不能满足我们的需求时,我们可以自定义异常 实现步骤 定义异常类 写继承关系 提供空参构造 提供带参构造 代码实现 异常类 public class AgeOutOfBoundsException extends RuntimeException { public AgeOutOfBoundsException() { } public AgeOutOfBoundsException(String message) { super(message); } } 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { if(age \u003e= 18 \u0026\u0026 age \u003c= 25){ this.age = age; }else{ //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常 throw new AgeOutOfBoundsException(\"年龄超出了范围\"); } } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class ExceptionDemo12 { public static void main(String[] args) { // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true){ System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try { int age = Integer.parseInt(ageStr); s.setAge(age); break; } catch (NumberFormatException e) { System.out.println(\"请输入一个整数\"); continue; } catch (AgeOutOfBoundsException e) { System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; } /*if(age \u003e= 18 \u0026\u0026 age \u003c=25){ s.setAge(age); break; }else{ System.out.println(\"请输入符合要求的年龄\"); continue; }*/ } System.out.println(s); } } ","date":"2023-01-29","objectID":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/:3:10","tags":["Java","异常"],"title":"时间日期类API和异常","uri":"/posts/2023/01/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BBapi%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"1.API ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:1:0","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"1.1 API概述-帮助文档的使用 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 如何使用API帮助文档 : 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:1:1","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"1.2 键盘录入字符串 Scanner类 : ​ next() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键 ​ nextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符 代码实现 : package com.itheima.api; import java.util.Scanner; public class Demo1Scanner { /* next() : 遇到了空格, 就不再录入数据了 结束标记: 空格, tab键 nextLine() : 可以将数据完整的接收过来 结束标记: 回车换行符 */ public static void main(String[] args) { // 1. 创建Scanner对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); // 2. 调用nextLine方法接收字符串 // ctrl + alt + v : 快速生成方法的返回值 String s = sc.nextLine(); System.out.println(s); } } package com.itheima.api; import java.util.Scanner; public class Demo2Scanner { /* nextInt和nextLine方法配合使用的时候, nextLine方法就没有键盘录入的机会了 建议: 今后键盘录入数据的时候, 如果是字符串和整数一起接受, 建议使用next方法接受字符串. */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"请输入整数:\"); int num = sc.nextInt(); // 10 + 回车换行 System.out.println(\"请输入字符串:\"); String s = sc.nextLine(); System.out.println(num); System.out.println(s); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:1:2","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2. String类 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:0","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.1 String概述 ​ 1 String 类在 java.lang 包下，所以使用的时候不需要导包 ​ 2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象 ​ 3 字符串不可变，它们的值在创建后不能被更改 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:1","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.2 String类的构造方法 常用的构造方法 示例代码 package com.itheima.string; public class Demo2StringConstructor { /* String类常见构造方法: public String() : 创建一个空白字符串对象，不含有任何内容 public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s = “abc”; 直接赋值的方式创建字符串对象，内容就是abc 注意: String这个类比较特殊, 打印其对象名的时候, 不会出现内存地址 而是该对象所记录的真实内容. 面向对象-继承, Object类 */ public static void main(String[] args) { // public String() : 创建一个空白字符串对象，不含有任何内容 String s1 = new String(); System.out.println(s1); // public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 char[] chs = {'a','b','c'}; String s2 = new String(chs); System.out.println(s2); // public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s3 = new String(\"123\"); System.out.println(s3); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:2","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.4 创建字符串对象的区别对比 通过构造方法创建 ​ 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同 直接赋值方式创建 ​ 以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:3","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.5 字符串的比较 2.5.1 字符串的比较 == 比较基本数据类型：比较的是具体的值 == 比较引用数据类型：比较的是对象地址值 String类 : public boolean equals(String s) 比较两个字符串内容是否相同、区分大小写 代码 : package com.itheima.stringmethod; public class Demo1Equals { public static void main(String[] args) { String s1 = \"abc\"; String s2 = \"ABC\"; String s3 = \"abc\"; // equals : 比较字符串内容, 区分大小写 System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); // equalsIgnoreCase : 比较字符串内容, 忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:4","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.6 用户登录案例【应用】 案例需求 : ​ 已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示 **实现步骤 : ** 已知用户名和密码，定义两个字符串表示即可 键盘录入要登录的用户名和密码，用 Scanner 实现 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test1 { /* 需求：已知用户名和密码，请用程序实现模拟用户登录。 总共给三次机会，登录之后，给出相应的提示 思路： 1. 已知用户名和密码，定义两个字符串表示即可 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 4. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环 */ public static void main(String[] args) { // 1. 已知用户名和密码，定义两个字符串表示即可 String username = \"admin\"; String password = \"123456\"; // 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 Scanner sc = new Scanner(System.in); // 4. 用循环实现多次机会，这里的次数明确，采用for循环实现 for(int i = 1; i \u003c= 3; i++){ System.out.println(\"请输入用户名:\"); String scUsername = sc.nextLine(); System.out.println(\"请输入密码:\"); String scPassword = sc.nextLine(); // 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 if(username.equals(scUsername) \u0026\u0026 password.equals(scPassword)){ System.out.println(\"登录成功\"); break; }else{ if(i == 3){ System.out.println(\"您的登录次数已达到今日上限, 请明天再来\"); }else{ System.out.println(\"登录失败,您还剩余\" + (3-i) +\"次机会\"); } } } } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:5","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.7 遍历字符串案例【应用】 案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 遍历字符串，首先要能够获取到字符串中的每一个字符, public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 遍历字符串，其次要能够获取到字符串的长度, public int length()：返回此字符串的长度 遍历打印 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test2 { /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 3. 遍历字符串，其次要能够获取到字符串的长度 public int length()：返回此字符串的长度 4. 遍历打印 9 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 for(int i = 0; i \u003c s.length(); i++){ // i : 字符串的每一个索引 char c = s.charAt(i); System.out.println(c); } } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:6","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.8 统计字符次数案例【应用】 案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 将字符串拆分为字符数组 , public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 遍历字符数 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test3 { /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 将字符串拆分为字符数组 public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 3. 遍历字符数组 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 将字符串拆分为字符数组 char[] chars = s.toCharArray(); // 3. 遍历字符数组 for (int i = 0; i \u003c chars.length; i++) { System.out.println(chars[i]); } } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:7","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.9 手机号屏蔽-字符串截取 案例需求 : ​ 以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 ​ 最终效果为：156****1234 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 截取字符串前三位 截取字符串后四位 将截取后的两个字符串，中间加上****进行拼接，输出结果 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test5 { /* 需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 最终效果为：156****1234 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 截取字符串前三位 3. 截取字符串后四位 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入手机号:\"); String telString = sc.nextLine(); // 2. 截取字符串前三位 String start = telString.substring(0,3); // 3. 截取字符串后四位 String end = telString.substring(7); // 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 System.out.println(start + \"****\" + end); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:8","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.10 敏感词替换-字符串替换 案例需求 : ​ 键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 替换敏感词 String replace(CharSequence target, CharSequence replacement) 将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 输出结果 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test6 { /* 需求：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 替换敏感词 String replace(CharSequence target, CharSequence replacement) 将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 3. 输出结果 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 替换敏感词 String result = s.replace(\"TMD\",\"***\"); // 3. 输出结果 System.out.println(result); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:9","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.11 切割字符串 案例需求 : ​ 以字符串的形式从键盘录入学生信息，例如：“张三 , 23” ​ 从该字符串中切割出有效数据,封装为Student学生对象 实现步骤 : 编写Student类，用于封装数据 键盘录入一个字符串，用 Scanner 实现 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割 将切割后的内容存入字符串数组中，并将字符串数组返回 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 调用对象getXxx方法，取出数据并打印。 代码实现 : package com.itheima.test; import com.itheima.domain.Student; import java.util.Scanner; public class Test7 { /* 需求：以字符串的形式从键盘录入学生信息，例如：“张三 , 23” 从该字符串中切割出有效数据,封装为Student学生对象 思路： 1. 编写Student类，用于封装数据 2. 键盘录入一个字符串，用 Scanner 实现 3. 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割 将切割后的内容存入字符串数组中，并将字符串数组返回 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 5. 调用对象getXxx方法，取出数据并打印。 */ public static void main(String[] args) { // 2. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入学生信息:\"); String stuInfo = sc.nextLine(); // stuInfo = \"张三,23\"; // 3. 根据逗号切割字符串，得到（张三）（23） String[] sArr = stuInfo.split(\",\"); // System.out.println(sArr[0]); // System.out.println(sArr[1]); // 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 Student stu = new Student(sArr[0],sArr[1]); // 5. 调用对象getXxx方法，取出数据并打印。 System.out.println(stu.getName() + \"...\" + stu.getAge()); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:10","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"2.12 String方法小结 String类的常用方法 : ​ public boolean equals(Object anObject) 比较字符串的内容，严格区分大小写 ​ public boolean equalsIgnoreCase(String anotherString) 比较字符串的内容，忽略大小写 ​ public int length() 返回此字符串的长度 ​ public char charAt(int index) 返回指定索引处的 char 值 ​ public char[] toCharArray() 将字符串拆分为字符数组后返回 ​ public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包含头，不包含尾） ​ public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串 ​ public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 ​ public String[] split(String regex) 根据传入的规则切割字符串，得到字符串数组 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:2:11","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"3 StringBuilder类 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:3:0","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"3.1 StringBuilder类概述 ​ 概述 : StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:3:1","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"3.2 StringBuilder类和String类的区别 **String类：**内容是不可变的 **StringBuilder类：**内容是可变的 ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:3:2","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"3.3StringBuilder类的构造方法 常用的构造方法 方法名 说明 public StringBuilder() 创建一个空白可变字符串对象，不含有任何内容 public StringBuilder(String str) 根据字符串的内容，来创建可变字符串对象 示例代码 public class StringBuilderDemo01 { public static void main(String[] args) { //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容 StringBuilder sb = new StringBuilder(); System.out.println(\"sb:\" + sb); System.out.println(\"sb.length():\" + sb.length()); //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象 StringBuilder sb2 = new StringBuilder(\"hello\"); System.out.println(\"sb2:\" + sb2); System.out.println(\"sb2.length():\" + sb2.length()); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:3:3","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"3.4 StringBuilder常用的成员方法 添加和反转方法 方法名 说明 public StringBuilder append(任意类型) 添加数据，并返回对象本身 public StringBuilder reverse() 返回相反的字符序列 示例代码 public class StringBuilderDemo01 { public static void main(String[] args) { //创建对象 StringBuilder sb = new StringBuilder(); //public StringBuilder append(任意类型)：添加数据，并返回对象本身 // StringBuilder sb2 = sb.append(\"hello\"); // // System.out.println(\"sb:\" + sb); // System.out.println(\"sb2:\" + sb2); // System.out.println(sb == sb2); // sb.append(\"hello\"); // sb.append(\"world\"); // sb.append(\"java\"); // sb.append(100); //链式编程 sb.append(\"hello\").append(\"world\").append(\"java\").append(100); System.out.println(\"sb:\" + sb); //public StringBuilder reverse()：返回相反的字符序列 sb.reverse(); System.out.println(\"sb:\" + sb); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:3:4","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"3.5StringBuilder和String相互转换【应用】 StringBuilder转换为String ​ public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String转换为StringBuilder ​ public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder 示例代码 public class StringBuilderDemo02 { public static void main(String[] args) { /* //StringBuilder 转换为 String StringBuilder sb = new StringBuilder(); sb.append(\"hello\"); //String s = sb; //这个是错误的做法 //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String s = sb.toString(); System.out.println(s); */ //String 转换为 StringBuilder String s = \"hello\"; //StringBuilder sb = s; //这个是错误的做法 //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder StringBuilder sb = new StringBuilder(s); System.out.println(sb); } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:3:5","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"},{"categories":["编程"],"content":"3.6 StringBuilder拼接字符串案例 案例需求 : ​ 定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， ​ 并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3] 实现步骤 : 定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 返回值类型 String，参数列表 int[] arr 在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 调用方法，用一个变量接收结果 输出结果 代码实现 : /* 思路： 1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 返回值类型 String，参数列表 int[] arr 3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 4:调用方法，用一个变量接收结果 5:输出结果 */ public class StringBuilderTest01 { public static void main(String[] args) { //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 int[] arr = {1, 2, 3}; //调用方法，用一个变量接收结果 String s = arrayToString(arr); //输出结果 System.out.println(\"s:\" + s); } //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回 /* 两个明确： 返回值类型：String 参数：int[] arr */ public static String arrayToString(int[] arr) { //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for(int i=0; i\u003carr.length; i++) { if(i == arr.length-1) { sb.append(arr[i]); } else { sb.append(arr[i]).append(\", \"); } } sb.append(\"]\"); String s = sb.toString(); return s; } } ","date":"2023-01-29","objectID":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/:3:6","tags":["Java","API"],"title":"java常用API基础","uri":"/posts/2023/01/java%E5%B8%B8%E7%94%A8api%E5%9F%BA%E7%A1%80/"}]